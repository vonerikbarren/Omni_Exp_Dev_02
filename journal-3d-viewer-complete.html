<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Journal Viewer - MySpace</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0a0a14 70%, #000000 100%);
            font-family: 'Orbitron', sans-serif;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            cursor: default;
        }

        #canvas-container.fps-mode {
            cursor: crosshair;
        }

        /* Behavior Mode Buttons */
        .behavior-mode-btn {
            background: rgba(128, 128, 128, 0.3) !important;
            border: 1px solid rgba(128, 128, 128, 0.5) !important;
            transition: all 0.3s;
        }

        .behavior-mode-btn.active {
            background: rgba(128, 128, 128, 0.5) !important;
            border: 1px solid rgba(255, 255, 255, 0.7) !important;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8), 
                        0 0 25px rgba(255, 255, 255, 0.5),
                        inset 0 0 10px rgba(255, 255, 255, 0.3) !important;
        }

        /* MySpace Grid Buttons */
        .myspace-grid-btn {
            background: rgba(128, 128, 128, 0.3) !important;
            border: 1px solid rgba(128, 128, 128, 0.5) !important;
            transition: all 0.3s;
        }

        .myspace-grid-btn.active {
            background: rgba(128, 128, 128, 0.5) !important;
            border: 1px solid rgba(255, 255, 255, 0.7) !important;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8), 
                        0 0 25px rgba(255, 255, 255, 0.5),
                        inset 0 0 10px rgba(255, 255, 255, 0.3) !important;
        }

        /* Inspector Panel */
        #inspector-panel {
            position: fixed;
            left: 70px;
            top: 90px;
            width: 320px;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            color: #fff;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #inspector-panel.visible {
            left: 70px;
            top: 90px;
        }

        #inspector-panel.minimized {
            height: auto;
            width: 200px; /* Consistent width */
            max-height: none;
        }
        
        #inspector-panel.minimized .panel-header {
            padding: 8px 12px; /* Smaller padding */
        }
        
        #inspector-panel.minimized .panel-title {
            font-size: 11px; /* Smaller font */
        }

        /* MySpace Panel */
        #myspace-panel {
            position: fixed;
            left: 410px;
            top: 90px;
            width: 320px;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            color: #fff;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #myspace-panel.visible {
            left: 410px;
            top: 90px;
        }

        #myspace-panel.minimized {
            height: auto;
            width: auto;
            max-height: none;
        }

        .myspace-control-btn:hover {
            background: rgba(128, 128, 128, 0.5);
            border-color: rgba(128, 128, 128, 0.7);
        }

        .myspace-control-btn.active {
            background: rgba(128, 128, 128, 0.5);
            border-color: rgba(128, 128, 128, 0.8);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        /* Help Panel */
        #help-panel {
            position: fixed;
            left: 750px;
            top: 90px;
            width: 320px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            color: #fff;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #help-panel.visible {
            left: 750px;
            top: 90px;
        }

        #help-panel.minimized {
            height: auto;
            width: 200px; /* Shorter width when minimized */
            max-height: none;
        }
        
        #help-panel.minimized .panel-header {
            padding: 8px 12px; /* Smaller padding */
        }
        
        #help-panel.minimized .panel-title {
            font-size: 11px; /* Smaller font */
        }

        /* Orbit Controls Panel */
        #orbit-controls-panel {
            position: fixed;
            left: 80px;
            top: 90px;
            width: 320px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            color: #fff;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #orbit-controls-panel.minimized {
            height: auto;
            width: auto;
            max-height: none;
        }

        /* Particle Behavior Panel */
        #particle-behavior-panel {
            position: fixed;
            left: 80px;
            top: 150px;
            width: 320px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            color: #fff;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #particle-behavior-panel.minimized {
            height: auto;
            width: auto;
            max-height: none;
        }

        /* User Controls Panel */
        #user-controls-panel {
            position: fixed;
            left: 80px;
            top: 210px;
            width: 320px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            color: #fff;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #user-controls-panel.minimized {
            height: auto;
            width: auto;
            max-height: none;
        }

        /* Default Space Panel */
        #default-space-panel {
            position: fixed;
            left: 80px;
            top: 270px;
            width: 320px;
            max-height: calc(100vh - 300px);
            overflow-y: auto;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.1);
            color: #fff;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #default-space-panel.minimized {
            height: auto;
            width: auto;
            max-height: none;
        }

        .panel-header {
            position: sticky;
            top: 0;
            padding: 12px 16px;
            background: rgba(25, 25, 30, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(128, 128, 128, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            user-select: none;
            z-index: 10;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .panel-controls {
            display: flex;
            gap: 8px;
        }

        .panel-btn {
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .panel-btn:hover {
            background: rgba(128, 128, 128, 0.3);
        }

        .close-btn:hover {
            background: rgba(226, 74, 74, 0.3);
        }

        .panel-content {
            padding: 20px;
        }

        .panel-content.hidden {
            display: none;
        }

        .info-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-value {
            font-size: 16px;
            color: #808080;
            font-weight: 600;
            margin-bottom: 20px;
        }

        .info-text {
            font-size: 14px;
            color: #fff;
            margin-bottom: 24px;
        }

        .slider-container {
            margin-bottom: 12px;
        }

        .slider {
            width: 100%;
            height: 4px;
            background: rgba(128, 128, 128, 0.2);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #808080;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #808080;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .info-box {
            margin-top: 20px;
            padding: 12px;
            background: rgba(128, 128, 128, 0.1);
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.7);
        }

        .summon-buttons {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .summon-btn {
            padding: 10px 12px;
            background: rgba(128, 128, 128, 0.3);
            border: 1px solid rgba(128, 128, 128, 0.5);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .summon-btn:hover {
            background: rgba(128, 128, 128, 0.5);
            border-color: rgba(128, 128, 128, 0.8);
            transform: translateX(3px);
        }

        .summon-btn:active {
            transform: scale(0.98);
        }

        /* Mobile Movement Control */
        #movement-control {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            z-index: 1000;
        }

        /* Right Hand Movement Control */
        #rh-movement-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            z-index: 1000;
        }

        /* Conscious Hand Movement Control */
        #ch-movement-control {
            position: fixed;
            top: 90px; /* Right under navbar */
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 150px;
            z-index: 1000;
        }

        .joystick-base {
            width: 150px;
            height: 150px;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(128, 128, 128, 0.3);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 8px 32px rgba(255, 255, 255, 0.4), 
                        0 4px 16px rgba(255, 255, 255, 0.3),
                        0 0 30px rgba(255, 255, 255, 0.2);
        }

        .joystick-stick {
            width: 60px;
            height: 60px;
            background: rgba(128, 128, 128, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: background 0.1s;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.9), 
                        0 0 35px rgba(255, 255, 255, 0.7),
                        0 0 50px rgba(255, 255, 255, 0.5),
                        inset 0 0 25px rgba(255, 255, 255, 0.3);
        }

        .joystick-stick:active {
            background: rgba(128, 128, 128, 0.9);
            box-shadow: 0 0 25px rgba(255, 255, 255, 1.0), 
                        0 0 45px rgba(255, 255, 255, 0.8),
                        0 0 60px rgba(255, 255, 255, 0.6),
                        inset 0 0 30px rgba(255, 255, 255, 0.4);
        }

        /* Control Buttons Grid */
        .control-buttons {
            position: fixed;
            bottom: 20px;
            left: 190px;
            display: grid;
            grid-template-columns: repeat(5, 35px);
            grid-template-rows: repeat(3, 35px);
            gap: 6px;
            z-index: 1000;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55), opacity 0.3s;
        }
        
        .control-buttons.hidden {
            transform: translateX(-250px);
            opacity: 0;
            pointer-events: none;
        }

        .control-btn {
            width: 35px;
            height: 35px;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .vertical-btn {
            font-size: 16px;
        }

        .control-btn:hover {
            background: rgba(128, 128, 128, 0.3);
            border-color: rgba(128, 128, 128, 0.6);
        }

        .control-btn.active {
            background: rgba(128, 128, 128, 0.6);
            border-color: rgba(128, 128, 128, 0.9);
        }
        
        .control-btn.hidden {
            display: none;
        }

        /* Transform Panel */
        #transform-panel {
            position: fixed;
            bottom: 200px;
            left: 20px;
            width: 280px;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 999;
            display: none;
        }

        /* FAQ Panel */
        #faq-panel {
            position: fixed;
            top: -100%;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            max-width: 90vw;
            background: rgba(25, 25, 30, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 1001;
            transition: top 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #faq-panel.visible {
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .faq-content {
            padding: 20px;
            max-height: 70vh;
            overflow-y: auto;
        }

        .faq-content::-webkit-scrollbar {
            width: 8px;
        }

        .faq-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .faq-content::-webkit-scrollbar-thumb {
            background: rgba(128, 128, 128, 0.5);
            border-radius: 4px;
        }

        .faq-content::-webkit-scrollbar-thumb:hover {
            background: rgba(128, 128, 128, 0.7);
        }

        .faq-item {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(128, 128, 128, 0.2);
        }

        .faq-item:last-child {
            border-bottom: none;
        }

        .faq-question {
            font-size: 13px;
            color: #808080;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .faq-answer {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.6;
        }

        /* Camera Rotation Circle */
        #camera-circle {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border: 2px solid rgba(128, 128, 128, 0.2);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
            transition: all 0.2s;
            opacity: 0;
            display: none;
        }

        .fps-mode #camera-circle {
            border-color: rgba(128, 128, 128, 0.6);
            border-width: 3px;
            opacity: 1;
            display: block;
        }

        #camera-circle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: rgba(128, 128, 128, 0.5);
            border-radius: 50%;
            transition: all 0.2s;
        }

        .fps-mode #camera-circle::before {
            width: 8px;
            height: 8px;
            background: rgba(128, 128, 128, 0.9);
        }

        /* Top Left Info Panel */
        #info-panel {
            position: fixed;
            top: 20px;
            left: 190px;
            padding: 16px 20px;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 12px;
            z-index: 1000;
            min-width: 200px;
            transition: all 0.3s ease;
        }

        .info-space-title {
            font-size: 16px;
            font-weight: 700;
            color: #808080;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }

        .info-username {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 8px;
        }

        .info-timer {
            font-size: 14px;
            font-weight: 700;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        /* Top Right Search Panel */
        #search-panel {
            position: fixed;
            top: 90px;
            right: 65px;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 12px;
            z-index: 1000;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            overflow: hidden;
        }

        #search-panel.collapsed {
            width: 35px;
            height: 35px;
            cursor: pointer;
        }

        #search-panel.expanded {
            width: 300px;
            height: auto;
            padding: 12px 16px;
        }

        .search-icon {
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #808080;
            cursor: pointer;
        }

        .search-content {
            display: none;
        }

        #search-panel.expanded .search-icon {
            display: none;
        }

        #search-panel.expanded .search-content {
            display: block;
        }

        .search-input {
            width: 100%;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            outline: none;
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .search-input:focus {
            border-color: rgba(128, 128, 128, 0.6);
            background: rgba(128, 128, 128, 0.1);
        }

        /* Hamburger Menus */
        .hamburger-btn {
            position: fixed;
            top: 90px;
            width: 35px;
            height: 35px;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 6px;
            cursor: pointer;
            z-index: 1002;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.3s;
        }

        .hamburger-btn:hover {
            background: rgba(128, 128, 128, 0.3);
            border-color: rgba(128, 128, 128, 0.6);
        }

        .hamburger-btn span {
            width: 20px;
            height: 2px;
            background: #808080;
            border-radius: 2px;
            transition: all 0.3s;
        }

        #left-hamburger {
            left: 20px;
        }

        #left-hamburger.menu-open {
            left: 320px;
        }

        #right-hamburger {
            right: 20px;
        }

        #right-hamburger.menu-open {
            right: 320px;
        }

        /* Side Menus */
        .side-menu {
            position: fixed;
            top: 0;
            width: 300px;
            height: 100vh;
            background: rgba(25, 25, 30, 0.7);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            z-index: 1001;
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            overflow-y: auto;
        }

        .side-menu::-webkit-scrollbar {
            width: 8px;
        }

        .side-menu::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .side-menu::-webkit-scrollbar-thumb {
            background: rgba(128, 128, 128, 0.5);
            border-radius: 4px;
        }

        #left-menu {
            left: 0;
            transform: translateX(-100%);
            border-right: 1px solid rgba(128, 128, 128, 0.3);
            border-left: none;
        }

        #left-menu.open {
            transform: translateX(0);
        }

        #right-menu {
            right: 0;
            transform: translateX(100%);
            border-left: 1px solid rgba(128, 128, 128, 0.3);
            border-right: none;
        }

        #right-menu.open {
            transform: translateX(0);
        }

        .menu-header {
            padding: 20px;
            background: rgba(128, 128, 128, 0.15);
            border-bottom: 1px solid rgba(128, 128, 128, 0.3);
        }

        .menu-title {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 1px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .menu-items {
            padding: 20px;
        }

        .menu-item {
            padding: 15px 20px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(128, 128, 128, 0.2);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        .menu-item:hover {
            background: rgba(128, 128, 128, 0.2);
            border-color: rgba(128, 128, 128, 0.5);
            transform: translateX(5px);
        }

        .menu-item.active {
            background: rgba(128, 128, 128, 0.4);
            border-color: rgba(128, 128, 128, 0.7);
        }

        /* Breadcrumb Navigation */
        .breadcrumb {
            padding: 15px 20px;
            background: rgba(128, 128, 128, 0.1);
            border-bottom: 1px solid rgba(128, 128, 128, 0.2);
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            gap: 8px;
            overflow-x: auto;
            white-space: nowrap;
        }

        .breadcrumb-item {
            cursor: pointer;
            transition: color 0.2s;
        }

        .breadcrumb-item:hover {
            color: #808080;
        }

        .breadcrumb-separator {
            color: rgba(255, 255, 255, 0.3);
        }

        .breadcrumb-current {
            color: #808080;
            font-weight: 600;
        }

        /* Submenu */
        .submenu {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            margin-left: 20px;
        }

        .menu-item.expanded .submenu {
            max-height: 500px;
        }

        .submenu-item {
            padding: 10px 15px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(128, 128, 128, 0.15);
            border-radius: 6px;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
        }

        .submenu-item:hover {
            background: rgba(128, 128, 128, 0.15);
            border-color: rgba(128, 128, 128, 0.4);
            transform: translateX(3px);
        }

        .menu-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .expand-icon {
            font-size: 10px;
            transition: transform 0.3s;
        }

        .menu-item.expanded .expand-icon {
            transform: rotate(90deg);
        }

        .submenu-item.has-children {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Prompt Modal */
        .prompt-modal {
            position: fixed;
            top: -100%;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            max-width: 90vw;
            background: rgba(25, 25, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 2000;
            transition: top 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            padding: 24px;
        }

        .prompt-modal.visible {
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .prompt-title {
            font-size: 18px;
            font-weight: 700;
            color: #808080;
            margin-bottom: 16px;
            text-align: center;
        }

        .prompt-message {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 20px;
            line-height: 1.6;
            text-align: center;
        }

        .prompt-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .prompt-btn {
            padding: 10px 20px;
            background: rgba(128, 128, 128, 0.3);
            border: 1px solid rgba(128, 128, 128, 0.5);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .prompt-btn:hover {
            background: rgba(128, 128, 128, 0.5);
            border-color: rgba(128, 128, 128, 0.8);
        }

        .prompt-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 24px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .prompt-close:hover {
            background: rgba(226, 74, 74, 0.3);
        }

        /* Theme Selection */
        .theme-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 16px;
        }

        .theme-option {
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 11px;
        }

        .theme-option:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(128, 128, 128, 0.5);
        }

        .theme-option.active {
            border-color: rgba(128, 128, 128, 0.9);
            background: rgba(128, 128, 128, 0.2);
        }

        .theme-color-preview {
            width: 100%;
            height: 40px;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        /* Hand Menus */
        .hand-menu {
            position: fixed;
            width: 200px;
            height: 200px;
            pointer-events: none;
            z-index: 1500;
            transition: opacity 0.3s;
            opacity: 0;
        }

        .hand-menu.visible {
            opacity: 1;
            pointer-events: all;
        }

        #left-hand {
            left: 20%;
            top: 70%;
            transform: translate(-50%, -50%);
        }

        #right-hand {
            right: 20%;
            top: 70%;
            transform: translate(50%, -50%);
        }

        #conscious-hand {
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .hand-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8), 
                        0 0 40px rgba(255, 255, 255, 0.6),
                        inset 0 0 20px rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 700;
            color: #333;
            cursor: pointer;
        }

        .radial-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%);
        }

        .radial-item {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.85);
            border: 2px solid rgba(128, 128, 128, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(128, 128, 128, 0.4);
        }

        .radial-item:hover {
            background: rgba(128, 128, 128, 0.9);
            color: #fff;
            transform: scale(1.15);
            box-shadow: 0 0 20px rgba(128, 128, 128, 0.8);
        }

        /* Pause Menu Overlay */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 2500;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .pause-overlay.visible {
            display: flex;
        }

        .pause-menu {
            background: rgba(25, 25, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(128, 128, 128, 0.6);
            border-radius: 20px;
            padding: 60px 80px;
            text-align: center;
            box-shadow: 0 0 40px rgba(128, 128, 128, 0.4);
        }

        .pause-title {
            font-size: 48px;
            font-weight: 700;
            color: #808080;
            margin-bottom: 30px;
            letter-spacing: 4px;
        }

        .pause-btn {
            padding: 15px 40px;
            background: rgba(128, 128, 128, 0.4);
            border: 2px solid rgba(128, 128, 128, 0.7);
            border-radius: 12px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .pause-btn:hover {
            background: rgba(128, 128, 128, 0.7);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(128, 128, 128, 0.6);
        }

        /* Pocket Panel */
        .pocket-panel {
            position: fixed;
            right: -600px;
            top: 50%;
            transform: translateY(-50%);
            width: 550px;
            height: 600px;
            background: rgba(25, 25, 30, 0.65);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(128, 128, 128, 0.4);
            border-right: none;
            border-radius: 20px 0 0 20px;
            z-index: 1800;
            transition: right 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            padding: 30px;
        }

        .pocket-panel.visible {
            right: 0;
        }

        .pocket-header {
            font-size: 24px;
            font-weight: 700;
            color: #808080;
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 2px;
        }

        .pocket-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 12px;
            height: calc(100% - 60px);
        }

        .pocket-slot {
            background: rgba(255, 255, 255, 0.35);
            border: 2px solid rgba(128, 128, 128, 0.5);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .pocket-slot:hover {
            background: rgba(128, 128, 128, 0.5);
            border-color: rgba(128, 128, 128, 0.9);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(128, 128, 128, 0.6);
        }

        .pocket-slot.in-scene {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(128, 128, 128, 0.3);
        }

        .pocket-slot.empty {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(128, 128, 128, 0.3);
        }

        .pocket-slot-number {
            position: absolute;
            top: 5px;
            left: 8px;
            font-size: 10px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.6);
        }

        .pocket-slot-content {
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            text-align: center;
            padding: 5px;
        }

        .pocket-slot-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        /* Virtual Keyboard */
        #virtual-keyboard {
            position: fixed;
            bottom: -400px;
            right: 20px;
            width: 600px;
            max-width: 90vw;
            background: rgba(25, 25, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(128, 128, 128, 0.4);
            border-radius: 16px 16px 0 0;
            padding: 20px;
            z-index: 2000;
            transition: bottom 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        #virtual-keyboard.visible {
            bottom: 0;
        }

        .keyboard-row {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            justify-content: center;
        }

        .key-btn {
            min-width: 40px;
            height: 40px;
            padding: 0 10px;
            background: rgba(128, 128, 128, 0.3);
            border: 1px solid rgba(128, 128, 128, 0.5);
            border-radius: 6px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .key-btn:hover {
            background: rgba(128, 128, 128, 0.6);
            transform: translateY(-2px);
        }

        .key-btn:active {
            transform: translateY(0);
            background: rgba(128, 128, 128, 0.8);
        }

        .key-btn.wide {
            min-width: 80px;
        }

        /* Text color classes for theme support */
        .theme-text {
            transition: color 0.3s;
        }

        /* Rainbow animations */
        @keyframes rainbowFlow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        @keyframes rainbowBorder {
            0% { border-color: #ff0000; }
            14% { border-color: #ff7f00; }
            28% { border-color: #ffff00; }
            42% { border-color: #00ff00; }
            57% { border-color: #0000ff; }
            71% { border-color: #4b0082; }
            85% { border-color: #9400d3; }
            100% { border-color: #ff0000; }
        }

        @keyframes rainbowGlow {
            0% { box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000; }
            14% { box-shadow: 0 0 20px #ff7f00, 0 0 40px #ff7f00; }
            28% { box-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00; }
            42% { box-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00; }
            57% { box-shadow: 0 0 20px #0000ff, 0 0 40px #0000ff; }
            71% { box-shadow: 0 0 20px #4b0082, 0 0 40px #4b0082; }
            85% { box-shadow: 0 0 20px #9400d3, 0 0 40px #9400d3; }
            100% { box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000; }
        }

        .rainbow-animated {
            animation: rainbowFlow 9.2s linear infinite;
        }

        .rainbow-border {
            animation: rainbowBorder 9.2s linear infinite;
        }

        .rainbow-glow {
            animation: rainbowGlow 9.2s linear infinite;
        }

        /* Docks */
        .dock {
            position: fixed;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            z-index: 999;
            display: flex;
            gap: 10px;
            padding: 10px;
            transition: all 0.3s;
        }

        .dock.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #dock-bottom {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row;
            border-radius: 16px 16px 0 0;
            border-bottom: none;
            margin-bottom: 0;
        }

        #dock-top {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            flex-direction: row;
            border-radius: 0 0 16px 16px;
            border-top: none;
            margin-top: 0;
        }

        #dock-left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            flex-direction: column;
            border-radius: 0 16px 16px 0;
            border-left: none;
            margin-left: 0;
        }

        #dock-right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            flex-direction: column;
            border-radius: 16px 0 0 16px;
            border-right: none;
            margin-right: 0;
        }

        .dock-item {
            width: 60px;
            height: 60px;
            background: rgba(128, 128, 128, 0.3);
            border: 1px solid rgba(128, 128, 128, 0.5);
            border-radius: 8px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            user-select: none;
        }

        .dock-item:hover {
            background: rgba(128, 128, 128, 0.5);
            transform: scale(1.1);
        }

        .dock-item:active {
            cursor: grabbing;
        }

        .dock-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .dock.drag-over {
            background: rgba(128, 128, 128, 0.2);
            border-color: rgba(128, 128, 128, 0.7);
        }

        .transform-header {
            padding: 12px 16px;
            background: rgba(128, 128, 128, 0.15);
            border-bottom: 1px solid rgba(128, 128, 128, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .transform-content {
            padding: 16px;
        }

        .transform-row {
            margin-bottom: 16px;
        }

        .transform-label {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .transform-inputs {
            display: flex;
            gap: 8px;
        }

        .transform-input {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 6px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            text-align: center;
        }

        .transform-input:focus {
            outline: none;
            border-color: rgba(128, 128, 128, 0.6);
            background: rgba(128, 128, 128, 0.1);
        }

        .step-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .step-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            min-width: 40px;
        }

        .step-input {
            flex: 1;
            padding: 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 4px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
        }

        .transform-submit-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
        }

        .transform-submit-btn {
            width: 100%;
            padding: 12px;
            background: rgba(128, 128, 128, 0.4);
            border: 1px solid rgba(128, 128, 128, 0.6);
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }

        .transform-submit-btn:hover {
            background: rgba(128, 128, 128, 0.6);
            border-color: rgba(128, 128, 128, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(128, 128, 128, 0.4);
        }

        .transform-submit-btn:active {
            transform: translateY(0);
        }

        /* Action Button Grid */
        #action-grid {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: grid;
            grid-template-columns: repeat(6, 50px);
            gap: 8px;
            z-index: 1000;
        }

        #action-grid.hidden {
            display: none;
        }

        .action-btn {
            width: 50px;
            height: 50px;
            background: rgba(25, 25, 30, 0.85);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(128, 128, 128, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
        }

        .action-btn:hover {
            background: rgba(128, 128, 128, 0.3);
            border-color: rgba(128, 128, 128, 0.6);
        }

        .action-btn.active {
            background: rgba(128, 128, 128, 0.6);
            border-color: rgba(128, 128, 128, 0.9);
        }

        /* Responsive adjustments */
        @media (orientation: portrait) {
            #action-grid {
                grid-template-columns: repeat(5, 50px);
            }
        }

        @media (orientation: landscape) {
            #action-grid {
                grid-template-columns: repeat(6, 50px);
            }
        }

        @media (max-width: 768px) {
            #inspector-panel {
                width: 280px;
            }
            
            .panel-content {
                padding: 16px;
            }
        }

        /* Tool Menus - Positioned Directionally */
        /* RH Tool Menu - Right Side */
        #rh-tool-menu {
            position: fixed;
            top: 30%;
            right: 20px;
            width: 45%;
            max-width: 700px;
            z-index: 2000;
            cursor: move;
        }

        /* LH Tool Menu - Left Side */
        #lh-tool-menu {
            position: fixed;
            top: 30%;
            left: 20px;
            width: 45%;
            max-width: 700px;
            z-index: 2000;
            cursor: move;
        }

        /* CH Tool Menu - Top Center */
        #ch-tool-menu {
            position: fixed;
            top: 250px;
            left: 50%;
            transform: translateX(-50%);
            width: 45%;
            max-width: 700px;
            z-index: 2000;
            cursor: move;
        }

        #lh-tool-menu .tool-menu-container {
            /* More transparent overall */
            background: linear-gradient(90deg, 
                rgba(25, 25, 30, 0.2) 0%,
                rgba(25, 25, 30, 0.4) 20%,
                rgba(25, 25, 30, 0.25) 50%,
                rgba(25, 25, 30, 0.4) 80%,
                rgba(25, 25, 30, 0.5) 100%
            );
            backdrop-filter: blur(20px);
            border: 2px solid rgba(128, 128, 128, 0.4);
            border-radius: 16px;
            padding: 10px 16px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8),
                        0 0 40px rgba(255, 255, 255, 0.3);
            /* Complete fade on left edge - fades border and everything */
            -webkit-mask-image: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0, 0, 0, 0.3) 5%,
                rgba(0, 0, 0, 1) 15%, 
                rgba(0, 0, 0, 1) 100%
            );
            mask-image: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0, 0, 0, 0.3) 5%,
                rgba(0, 0, 0, 1) 15%, 
                rgba(0, 0, 0, 1) 100%
            );
        }

        #rh-tool-menu .tool-menu-container {
            /* More transparent overall */
            background: linear-gradient(90deg, 
                rgba(25, 25, 30, 0.5) 0%,
                rgba(25, 25, 30, 0.4) 20%,
                rgba(25, 25, 30, 0.25) 50%,
                rgba(25, 25, 30, 0.4) 80%,
                rgba(25, 25, 30, 0.2) 100%
            );
            backdrop-filter: blur(20px);
            border: 2px solid rgba(128, 128, 128, 0.4);
            border-radius: 16px;
            padding: 10px 16px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8),
                        0 0 40px rgba(255, 255, 255, 0.3);
            /* Complete fade on right edge - fades border and everything */
            -webkit-mask-image: linear-gradient(90deg, 
                rgba(0, 0, 0, 1) 0%, 
                rgba(0, 0, 0, 1) 85%, 
                rgba(0, 0, 0, 0.3) 95%,
                transparent 100%
            );
            mask-image: linear-gradient(90deg, 
                rgba(0, 0, 0, 1) 0%, 
                rgba(0, 0, 0, 1) 85%, 
                rgba(0, 0, 0, 0.3) 95%,
                transparent 100%
            );
        }

        #ch-tool-menu .tool-menu-container {
            /* More transparent overall */
            background: linear-gradient(90deg, 
                rgba(25, 25, 30, 0.2) 0%,
                rgba(25, 25, 30, 0.4) 20%,
                rgba(25, 25, 30, 0.25) 50%,
                rgba(25, 25, 30, 0.4) 80%,
                rgba(25, 25, 30, 0.2) 100%
            );
            backdrop-filter: blur(20px);
            border: 2px solid rgba(128, 128, 128, 0.4);
            border-radius: 16px;
            padding: 10px 16px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8),
                        0 0 40px rgba(255, 255, 255, 0.3);
            /* Complete fade on BOTH left and right edges */
            -webkit-mask-image: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0, 0, 0, 0.3) 5%,
                rgba(0, 0, 0, 1) 15%, 
                rgba(0, 0, 0, 1) 85%, 
                rgba(0, 0, 0, 0.3) 95%,
                transparent 100%
            );
            mask-image: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0, 0, 0, 0.3) 5%,
                rgba(0, 0, 0, 1) 15%, 
                rgba(0, 0, 0, 1) 85%, 
                rgba(0, 0, 0, 0.3) 95%,
                transparent 100%
            );
        }

        .tool-menu-header {
            font-size: 14px;
            font-weight: 700;
            color: #fff;
            text-align: center;
            margin-bottom: 10px;
            letter-spacing: 2px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.9),
                         0 0 30px rgba(255, 255, 255, 0.6);
        }

        .tool-menu-items {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding: 8px 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(128, 128, 128, 0.5) transparent;
        }

        .tool-menu-items::-webkit-scrollbar {
            height: 4px;
        }

        .tool-menu-items::-webkit-scrollbar-track {
            background: transparent;
        }

        .tool-menu-items::-webkit-scrollbar-thumb {
            background: rgba(128, 128, 128, 0.5);
            border-radius: 3px;
        }

        .tool-item {
            min-width: 80px;
            height: 80px;
            background: rgba(128, 128, 128, 0.2);
            border: 2px solid rgba(128, 128, 128, 0.4);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        .tool-item:hover,
        .tool-item.selected {
            background: rgba(128, 128, 128, 0.4);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8),
                        0 0 35px rgba(255, 255, 255, 0.5),
                        inset 0 0 15px rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .tool-menu-footer {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(128, 128, 128, 0.3);
            text-align: center;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            min-height: 30px;
        }

        /* Rotating Gradient Circles for Hand Menus */
        .hand-menu::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 180px;
            height: 180px;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                transparent 0%,
                rgba(255, 255, 255, 0.8) 25%,
                transparent 50%,
                rgba(255, 255, 255, 0.8) 75%,
                transparent 100%
            );
            border: 2px solid transparent;
            pointer-events: none;
            z-index: -1;
        }

        /* LH - Clockwise rotation */
        #left-hand::before {
            animation: rotateClockwise 4s linear infinite;
        }

        /* RH - Counter-clockwise rotation */
        #right-hand::before {
            animation: rotateCounterClockwise 4s linear infinite;
        }

        /* CH - X-axis rotation (double dutch style) */
        #conscious-hand::before {
            animation: rotateXAxis 4s linear infinite;
            transform-style: preserve-3d;
        }

        @keyframes rotateClockwise {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        @keyframes rotateCounterClockwise {
            from { transform: translate(-50%, -50%) rotate(360deg); }
            to { transform: translate(-50%, -50%) rotate(0deg); }
        }

        @keyframes rotateXAxis {
            from { transform: translate(-50%, -50%) rotateX(0deg); }
            to { transform: translate(-50%, -50%) rotateX(360deg); }
        }
    </style>
</head>
<body>
<body>
    <div id="canvas-container"></div>
    
    <!-- Particles for Entrance -->
    <div id="particles-js" style="position: fixed; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none; z-index: 1; opacity: 0.4; transition: opacity 1s; background: transparent;"></div>

    <!-- Compact Header Bar -->
    <div id="header-bar" style="position: fixed; top: 10px; left: 20px; right: 20px; height: 60px; background: rgba(25, 25, 30, 0.85); backdrop-filter: blur(20px); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 12px; padding: 8px 16px; z-index: 1000; display: flex; align-items: center; gap: 8px;">
        
        <!-- Profile Picture -->
        <div id="profile-image-container" style="width: 44px; height: 44px; border-radius: 50%; border: 2px solid rgba(128, 128, 128, 0.5); overflow: hidden; cursor: pointer; background: rgba(128, 128, 128, 0.2); display: flex; align-items: center; justify-content: center; font-size: 24px; color: rgba(128, 128, 128, 0.8); flex-shrink: 0;">
            
        </div>
        <input type="file" id="profile-image-input" accept="image/*" style="display: none;">
        
        <!-- User Info Column -->
        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 150px;">
            <div style="display: flex; align-items: center; gap: 6px;">
                <span style="font-size: 11px; color: rgba(255, 255, 255, 0.6); font-weight: 600;">USER:</span>
                <div id="header-username" contenteditable="true" style="font-size: 12px; font-weight: 700; color: #fff; border: 1px solid transparent; padding: 2px 4px; border-radius: 3px; outline: none; cursor: text;">undefined</div>
            </div>
            <div id="header-description" contenteditable="true" style="font-size: 10px; color: rgba(255, 255, 255, 0.5); border: 1px solid transparent; padding: 2px 4px; border-radius: 3px; outline: none; cursor: text; min-width: 100px;">Add description...</div>
        </div>
        
        <!-- Divider -->
        <div style="width: 1px; height: 40px; background: rgba(128, 128, 128, 0.2); flex-shrink: 0;"></div>
        
        <!-- Primary Space Info Column -->
        <div style="display: flex; flex-direction: column; gap: 4px; min-width: 140px;">
            <div style="font-size: 9px; font-weight: 700; color: #fff; letter-spacing: 0.5px; margin-bottom: 2px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">PRIMARY SPACE</div>
            <div style="display: flex; flex-direction: column; gap: 2px;">
                <div id="session-timer" style="font-size: 11px; font-weight: 700; color: #fff; font-family: 'Courier New', monospace;">00:00:00.000</div>
                <div id="timezone-display" style="font-size: 10px; font-weight: 700; color: #fff; cursor: pointer; position: relative; font-family: 'Courier New', monospace; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">
                    <span id="current-time">--:--:-- --</span>
                    <span id="timezone-abbr" style="margin-left: 4px;">EST</span>
                </div>
                <!-- Timezone Selector Dropdown -->
                <div id="timezone-selector" style="display: none; position: absolute; top: 100%; left: 0; background: rgba(25, 25, 30, 0.95); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 8px; padding: 8px; min-width: 200px; max-height: 300px; overflow-y: auto; z-index: 10000; backdrop-filter: blur(20px); box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);">
                    <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid rgba(128, 128, 128, 0.2);">SELECT TIMEZONE</div>
                    <div class="timezone-option" data-tz="America/New_York" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(255, 255, 255, 0.8); border-radius: 4px;">EST - Eastern</div>
                    <div class="timezone-option" data-tz="America/Chicago" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(255, 255, 255, 0.8); border-radius: 4px;">CST - Central</div>
                    <div class="timezone-option" data-tz="America/Denver" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(255, 255, 255, 0.8); border-radius: 4px;">MST - Mountain</div>
                    <div class="timezone-option" data-tz="America/Los_Angeles" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(255, 255, 255, 0.8); border-radius: 4px;">PST - Pacific</div>
                    <div class="timezone-option" data-tz="Europe/London" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(255, 255, 255, 0.8); border-radius: 4px;">GMT - London</div>
                    <div class="timezone-option" data-tz="Europe/Paris" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(255, 255, 255, 0.8); border-radius: 4px;">CET - Paris</div>
                    <div class="timezone-option" data-tz="Asia/Tokyo" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(255, 255, 255, 0.8); border-radius: 4px;">JST - Tokyo</div>
                    <div class="timezone-option" data-tz="Australia/Sydney" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(255, 255, 255, 0.8); border-radius: 4px;">AEDT - Sydney</div>
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(128, 128, 128, 0.2);">
                        <div id="auto-detect-tz" style="padding: 6px; cursor: pointer; font-size: 10px; color: rgba(74, 144, 226, 0.9); border-radius: 4px; text-align: center;"> Auto-Detect Location</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Divider -->
        <div style="width: 1px; height: 40px; background: rgba(128, 128, 128, 0.2); flex-shrink: 0;"></div>
        
        <!-- Coordinate Guide: Position -->
        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 90px;">
            <div style="font-size: 8px; font-weight: 700; color: #fff; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">POS</div>
            <div style="font-family: 'Courier New', monospace; font-size: 9px; color: rgba(255, 255, 255, 0.8);">
                <div id="coord-pos-x">X: 0.00</div>
                <div id="coord-pos-y">Y: 0.00</div>
                <div id="coord-pos-z">Z: 0.00</div>
            </div>
        </div>
        
        <!-- Coordinate Guide: Rotation -->
        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 90px;">
            <div style="font-size: 8px; font-weight: 700; color: #fff; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">ROT</div>
            <div style="font-family: 'Courier New', monospace; font-size: 9px; color: rgba(255, 255, 255, 0.8);">
                <div id="coord-rot-x">X: 0.00</div>
                <div id="coord-rot-y">Y: 0.00</div>
                <div id="coord-rot-z">Z: 0.00</div>
            </div>
        </div>
        
        <!-- Coordinate Guide: Scale -->
        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 90px;">
            <div style="font-size: 8px; font-weight: 700; color: #fff; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">SCA</div>
            <div style="font-family: 'Courier New', monospace; font-size: 9px; color: rgba(255, 255, 255, 0.8);">
                <div id="coord-sca-x">X: 1.00</div>
                <div id="coord-sca-y">Y: 1.00</div>
                <div id="coord-sca-z">Z: 1.00</div>
            </div>
        </div>
        
        <!-- Divider -->
        <div style="width: 1px; height: 40px; background: rgba(128, 128, 128, 0.2); flex-shrink: 0;"></div>
        
        <!-- FPS Column -->
        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 40px;">
            <div style="font-size: 8px; font-weight: 700; color: #fff; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">FPS</div>
            <div style="font-family: 'Courier New', monospace; font-size: 11px; color: rgba(255, 255, 255, 0.9);">
                <div id="fps-counter">60</div>
            </div>
        </div>
        
        <!-- Divider -->
        <div style="width: 1px; height: 40px; background: rgba(128, 128, 128, 0.2); flex-shrink: 0;"></div>
        
        <!-- Performance Metrics Column -->
        <div style="display: flex; flex-direction: column; gap: 1px; min-width: 50px;">
            <div style="font-size: 8px; font-weight: 700; color: #fff; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">PERF</div>
            <div style="font-family: 'Courier New', monospace; font-size: 7px; color: rgba(255, 255, 255, 0.7); line-height: 1.3;">
                <div id="frame-time">16ms</div>
                <div id="particle-count">0p</div>
                <div id="cam-pos">0,0,0</div>
            </div>
        </div>
        
        <!-- Divider -->
        <div style="width: 1px; height: 40px; background: rgba(128, 128, 128, 0.2); flex-shrink: 0;"></div>
        
        <!-- System Column -->
        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 100px;">
            <div style="font-size: 8px; font-weight: 700; color: #fff; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">SYSTEM</div>
            <div style="font-family: 'Courier New', monospace; font-size: 9px; color: rgba(255, 255, 255, 0.8);">
                <div style="display: flex; justify-content: space-between;">
                    <span>Root:</span>
                    <span id="root-system" style="color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">default</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Parent:</span>
                    <span id="parent-system" style="color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">default</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Child:</span>
                    <span id="child-system" style="color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">default</span>
                </div>
            </div>
        </div>
        
        <!-- Divider -->
        <div style="width: 1px; height: 40px; background: rgba(128, 128, 128, 0.2); flex-shrink: 0;"></div>
        
        <!-- Dimensional Column -->
        <div style="display: flex; flex-direction: column; gap: 2px; min-width: 110px;">
            <div style="font-size: 8px; font-weight: 700; color: #fff; letter-spacing: 0.5px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">DIMENSIONAL</div>
            <div style="font-family: 'Courier New', monospace; font-size: 9px; color: rgba(255, 255, 255, 0.8);">
                <div style="display: flex; justify-content: space-between;">
                    <span>Exp:</span>
                    <span id="dimensional-experience" style="color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">undefined</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Per:</span>
                    <span id="dimensional-perspective" style="color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">undefined</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Time:</span>
                    <span id="dimensional-time" style="color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">undefined</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>Space:</span>
                    <span id="dimensional-space" style="color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">undefined</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Top Right Search Panel -->
    <div id="search-panel" class="collapsed">
        <div class="search-icon"></div>
        <div class="search-content">
            <input type="text" class="search-input" placeholder="Search..." id="search-input">
        </div>
    </div>

    <!-- Camera Rotation Circle -->
    <div id="camera-circle"></div>

    <!-- Hamburger Menu Buttons -->
    <div class="hamburger-btn" id="left-hamburger">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <div class="hamburger-btn" id="right-hamburger">
        <span></span>
        <span></span>
        <span></span>
    </div>

    <!-- Left Side Menu (Admin/System) -->
    <div class="side-menu" id="left-menu">
        <div class="menu-header">
            <div class="menu-title">- ADMIN & SYSTEM</div>
        </div>
        <div class="breadcrumb" id="left-breadcrumb">
            <span class="breadcrumb-item breadcrumb-current">Admin & System</span>
        </div>
        <div class="menu-items">
            <!-- Governance Section -->
            <div class="menu-item" data-page="governance">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Governance</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item has-children" data-submenu="governance-admin">
                         Admin
                        <span class="expand-icon"></span>
                    </div>
                    <div class="submenu-item" data-submenu="governance-security"> Security</div>
                    <div class="submenu-item has-children" data-submenu="governance-settings">
                         Settings
                        <span class="expand-icon"></span>
                    </div>
                </div>
            </div>
            
            <!-- System Section -->
            <div class="menu-item" data-page="system">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> System</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item has-children" data-submenu="system-systems">
                         Systems
                        <span class="expand-icon"></span>
                    </div>
                    <div class="submenu-item" data-submenu="system-interfaces"> Interfaces</div>
                    <div class="submenu-item" data-submenu="system-objects"> Objects</div>
                </div>
            </div>
            
            <!-- Intelligence Section -->
            <div class="menu-item" data-page="intelligence">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Intelligence</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="intelligence-logic"> Logic</div>
                    <div class="submenu-item" data-submenu="intelligence-memory"> Memory</div>
                    <div class="submenu-item" data-submenu="intelligence-states"> States</div>
                </div>
            </div>
            
            <!-- Infrastructure Section -->
            <div class="menu-item" data-page="infrastructure">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Infrastructure</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="infra-processes"> Processes</div>
                    <div class="submenu-item" data-submenu="infra-networks"> Networks</div>
                    <div class="submenu-item" data-submenu="infra-energies"> Energies</div>
                </div>
            </div>
            
            <!-- Experience Section -->
            <div class="menu-item" data-page="experience">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Experience</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="exp-experiences"> Experiences</div>
                    <div class="submenu-item" data-submenu="exp-expressions"> Expressions</div>
                    <div class="submenu-item" data-submenu="exp-perspectives"> Perspectives</div>
                </div>
            </div>
            
            <!-- Reality Section -->
            <div class="menu-item" data-page="reality">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Reality</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="reality-gravities"> Gravities</div>
                    <div class="submenu-item" data-submenu="reality-times"> Times</div>
                    <div class="submenu-item has-children" data-submenu="reality-spaces">
                         Spaces
                        <span class="expand-icon"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Nested Submenu Content for Left Menu -->
    <div id="submenu-content-governance-settings" class="nested-submenu" style="display: none;">
        <div class="submenu-item" data-submenu="settings-ui-transparency" style="flex-direction: column; align-items: flex-start; padding: 12px;">
            <div style="margin-bottom: 8px; font-weight: 600;"> UI Transparency</div>
            <input type="range" id="ui-transparency-slider" min="0" max="100" value="100" 
                   style="width: 100%; cursor: pointer;">
            <div style="display: flex; justify-content: space-between; width: 100%; font-size: 10px; margin-top: 4px;">
                <span>Hidden</span>
                <span id="transparency-value">100%</span>
                <span>Opaque</span>
            </div>
        </div>
        <div class="submenu-item" data-submenu="settings-preferences"> Preferences</div>
        <div class="submenu-item" data-submenu="settings-display"> Display</div>
        <div class="submenu-item" data-submenu="settings-controls"> Controls</div>
    </div>

    <div id="submenu-content-governance-admin" class="nested-submenu" style="display: none;">
        <div class="submenu-item" data-submenu="admin-particle"> Particle Behavior</div>
        <div class="submenu-item has-children" data-submenu="admin-theme">
             Theme
            <span class="expand-icon"></span>
        </div>
        <div class="submenu-item has-children" data-submenu="admin-restart">
             Restart App
            <span class="expand-icon"></span>
        </div>
        <div class="submenu-item" data-submenu="admin-users"> Users</div>
        <div class="submenu-item" data-submenu="admin-permissions"> Permissions</div>
    </div>

    <div id="submenu-content-system-systems" class="nested-submenu" style="display: none;">
        <div class="submenu-item" data-submenu="systems-myspace"> MySpace</div>
        <div class="submenu-item" data-submenu="systems-controllers"> Controllers</div>
        <div class="submenu-item" data-submenu="systems-nav"> NAV</div>
        <div class="submenu-item" data-submenu="systems-rendering"> Rendering</div>
        <div class="submenu-item" data-submenu="systems-audio"> Audio</div>
        <div class="submenu-item" data-submenu="systems-input"> Input</div>
        <div class="submenu-item" data-submenu="systems-network"> Network</div>
    </div>

    <div id="submenu-content-reality-spaces" class="nested-submenu" style="display: none;">
        <div class="submenu-item" data-submenu="spaces-default"> Default Space</div>
        <div class="submenu-item" data-submenu="spaces-myspace"> MySpace</div>
        <div class="submenu-item" data-submenu="spaces-workspace"> Workspace</div>
        <div class="submenu-item" data-submenu="spaces-mindspace"> MindSpace</div>
        <div class="submenu-item" data-submenu="spaces-timespace"> TimeSpace</div>
        <div class="submenu-item" data-submenu="spaces-innerspace"> InnerSpace</div>
        <div class="submenu-item" data-submenu="spaces-outerspace"> OuterSpace</div>
    </div>

    <div id="submenu-content-admin-theme" class="nested-submenu" style="display: none;">
        <div class="submenu-item" data-submenu="theme-dark"> Dark Mode</div>
        <div class="submenu-item" data-submenu="theme-light"> Light Mode</div>
        <div class="submenu-item" data-submenu="theme-custom"> Custom Theme</div>
    </div>

    <div id="submenu-content-admin-restart" class="nested-submenu" style="display: none;">
        <div class="submenu-item" data-submenu="restart-soft"> Soft Restart</div>
        <div class="submenu-item" data-submenu="restart-hard"> Hard Restart</div>
        <div class="submenu-item" data-submenu="restart-factory"> Factory Reset</div>
    </div>

    <!-- Right Side Menu (Site Pages) -->
    <div class="side-menu" id="right-menu">
        <div class="menu-header">
            <div class="menu-title">- NAVIGATION</div>
        </div>
        <div class="breadcrumb" id="right-breadcrumb">
            <span class="breadcrumb-item breadcrumb-current">Navigation</span>
        </div>
        <div class="menu-items">
            <!-- Account with submenu -->
            <div class="menu-item" data-page="account">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Account</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="account-login"> Login</div>
                    <div class="submenu-item" data-submenu="account-profile"> Profile</div>
                    <div class="submenu-item" data-submenu="account-dashboard"> Dashboard</div>
                </div>
            </div>
            
            <!-- Home -->
            <div class="menu-item" data-page="home">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Home</span>
                </div>
            </div>
            
            <!-- About with submenu -->
            <div class="menu-item" data-page="about">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> About</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="about-me"> About Me</div>
                    <div class="submenu-item" data-submenu="about-supporters"> Supporters</div>
                </div>
            </div>
            
            <!-- Work with submenu -->
            <div class="menu-item" data-page="work">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Work</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="work-portfolio"> Portfolio</div>
                </div>
            </div>
            
            <!-- Offerings with submenu -->
            <div class="menu-item" data-page="offerings">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Offerings</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="offerings-products"> Products</div>
                    <div class="submenu-item" data-submenu="offerings-services"> Services</div>
                </div>
            </div>
            
            <!-- Resources -->
            <div class="menu-item" data-page="resources">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Resources</span>
                </div>
            </div>
            
            <!-- Network with submenu -->
            <div class="menu-item" data-page="network">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Network</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="network-social"> Social Links</div>
                    <div class="submenu-item" data-submenu="network-communities"> Communities</div>
                    <div class="submenu-item" data-submenu="network-collaborators"> Collaborators</div>
                    <div class="submenu-item" data-submenu="network-spaces"> Spaces</div>
                </div>
            </div>
            
            <!-- OmniChannel with submenu -->
            <div class="menu-item" data-page="omnichannel">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> OmniChannel</span>
                    <span class="expand-icon"></span>
                </div>
                <div class="submenu">
                    <div class="submenu-item" data-submenu="omni-updates"> OmniFeed: Updates</div>
                    <div class="submenu-item" data-submenu="omni-logs"> OmniFeed: Logs</div>
                    <div class="submenu-item" data-submenu="omni-drops"> OmniFeed: Drops</div>
                    <div class="submenu-item" data-submenu="omni-perspectives"> OmniFeed: Perspectives</div>
                    <div class="submenu-item" data-submenu="omni-experiments"> OmniFeed: Experiments</div>
                    <div class="submenu-item" data-submenu="omni-media"> OmniFeed: Media</div>
                </div>
            </div>
            
            <!-- Contact -->
            <div class="menu-item" data-page="contact">
                <div class="menu-item-header">
                    <span style="text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);"> Contact</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Docks -->
    <div class="dock hidden" id="dock-bottom">
        <!-- Manually populated panel cubes -->
        <div class="dock-item dock-cube" draggable="true" data-panel-id="cube-face-panel" style="width: 50px; height: 50px; background: rgba(25, 25, 30, 0.95); border: 1px solid rgba(0, 102, 255, 0.5); border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: grab; position: relative; transition: all 0.3s; margin: 4px;">
            <div style="transform: rotate(-45deg); font-size: 8px; font-weight: 700; color: rgba(255, 255, 255, 0.9); letter-spacing: 0.5px; font-family: 'Orbitron', sans-serif; text-align: center; line-height: 1.2; word-break: break-word; max-width: 40px; pointer-events: none;">CUBE FC</div>
        </div>
        <div class="dock-item dock-cube" draggable="true" data-panel-id="omnisense-panel" style="width: 50px; height: 50px; background: rgba(25, 25, 30, 0.95); border: 1px solid rgba(0, 102, 255, 0.5); border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: grab; position: relative; transition: all 0.3s; margin: 4px;">
            <div style="transform: rotate(-45deg); font-size: 8px; font-weight: 700; color: rgba(255, 255, 255, 0.9); letter-spacing: 0.5px; font-family: 'Orbitron', sans-serif; text-align: center; line-height: 1.2; word-break: break-word; max-width: 40px; pointer-events: none;">OMNISENS</div>
        </div>
        <div class="dock-item dock-cube" draggable="true" data-panel-id="particle-behavior-panel" style="width: 50px; height: 50px; background: rgba(25, 25, 30, 0.95); border: 1px solid rgba(0, 102, 255, 0.5); border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: grab; position: relative; transition: all 0.3s; margin: 4px;">
            <div style="transform: rotate(-45deg); font-size: 8px; font-weight: 700; color: rgba(255, 255, 255, 0.9); letter-spacing: 0.5px; font-family: 'Orbitron', sans-serif; text-align: center; line-height: 1.2; word-break: break-word; max-width: 40px; pointer-events: none;">PARTICL</div>
        </div>
    </div>

    <div class="dock hidden" id="dock-top">
        <!-- Available for manual organization -->
    </div>

    <div class="dock hidden" id="dock-left">
        <!-- Manually populated panel cubes -->
        <div class="dock-item dock-cube" draggable="true" data-panel-id="user-controls-panel" style="width: 50px; height: 50px; background: rgba(25, 25, 30, 0.95); border: 1px solid rgba(0, 102, 255, 0.5); border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: grab; position: relative; transition: all 0.3s; margin: 4px;">
            <div style="transform: rotate(-45deg); font-size: 8px; font-weight: 700; color: rgba(255, 255, 255, 0.9); letter-spacing: 0.5px; font-family: 'Orbitron', sans-serif; text-align: center; line-height: 1.2; word-break: break-word; max-width: 40px; pointer-events: none;">USER</div>
        </div>
        <div class="dock-item dock-cube" draggable="true" data-panel-id="default-space-panel" style="width: 50px; height: 50px; background: rgba(25, 25, 30, 0.95); border: 1px solid rgba(0, 102, 255, 0.5); border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: grab; position: relative; transition: all 0.3s; margin: 4px;">
            <div style="transform: rotate(-45deg); font-size: 8px; font-weight: 700; color: rgba(255, 255, 255, 0.9); letter-spacing: 0.5px; font-family: 'Orbitron', sans-serif; text-align: center; line-height: 1.2; word-break: break-word; max-width: 40px; pointer-events: none;">DEFLT SP</div>
        </div>
        <div class="dock-item dock-cube" draggable="true" data-panel-id="orbit-controls-panel" style="width: 50px; height: 50px; background: rgba(25, 25, 30, 0.95); border: 1px solid rgba(0, 102, 255, 0.5); border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: grab; position: relative; transition: all 0.3s; margin: 4px;">
            <div style="transform: rotate(-45deg); font-size: 8px; font-weight: 700; color: rgba(255, 255, 255, 0.9); letter-spacing: 0.5px; font-family: 'Orbitron', sans-serif; text-align: center; line-height: 1.2; word-break: break-word; max-width: 40px; pointer-events: none;">ORBIT</div>
        </div>
    </div>

    <div class="dock hidden" id="dock-right">
        <!-- Available for user organization -->
    </div>

    <!-- Restart Prompt Modal -->
    <div class="prompt-modal" id="restart-prompt">
        <button class="prompt-close" onclick="document.getElementById('restart-prompt').classList.remove('visible')"></button>
        <div class="prompt-title">Restart Application?</div>
        <div class="prompt-message">Are you sure you want to restart the application? All unsaved progress will be lost.</div>
        <div class="prompt-buttons">
            <button class="prompt-btn" onclick="location.reload()">Yes</button>
            <button class="prompt-btn" onclick="document.getElementById('restart-prompt').classList.remove('visible')">No</button>
            <button class="prompt-btn" onclick="showWisdomPrompt()">Not Sure</button>
        </div>
    </div>

    <!-- Wisdom Prompt Modal -->
    <div class="prompt-modal" id="wisdom-prompt">
        <button class="prompt-close" onclick="document.getElementById('wisdom-prompt').classList.remove('visible')"></button>
        <div class="prompt-title">Maybe This Will Help...</div>
        <div class="prompt-message" id="wisdom-text"></div>
        <div class="prompt-buttons">
            <button class="prompt-btn" onclick="document.getElementById('wisdom-prompt').classList.remove('visible')">Close</button>
        </div>
    </div>

    <!-- Theme Selector Modal -->
    <div class="prompt-modal" id="theme-prompt">
        <button class="prompt-close" onclick="document.getElementById('theme-prompt').classList.remove('visible')"></button>
        <div class="prompt-title">Select Theme</div>
        <div class="theme-grid" id="theme-grid"></div>
    </div>

    <!-- Left Hand Menu -->
    <div class="hand-menu" id="left-hand">
        <div class="hand-circle">LH</div>
        <div class="radial-menu" id="lh-radial"></div>
    </div>

    <!-- Right Hand Menu -->
    <div class="hand-menu" id="right-hand">
        <div class="hand-circle">RH</div>
        <div class="radial-menu" id="rh-radial"></div>
    </div>

    <!-- Conscious Hand Menu -->
    <div class="hand-menu" id="conscious-hand">
        <div class="hand-circle">CH</div>
        <div class="radial-menu" id="ch-radial"></div>
    </div>

    <!-- RH Horizontal Tool Selection Menu (BotW style) -->
    <div id="rh-tool-menu" style="display: none;">
        <div class="tool-menu-container">
            <div class="tool-menu-header">- RIGHT HAND TOOLS</div>
            <div class="tool-menu-items" id="rh-tool-menu-items">
                <!-- Tools will be populated here -->
            </div>
            <div class="tool-menu-footer">
                <span id="rh-tool-description">Select a tool to view details</span>
            </div>
        </div>
    </div>

    <!-- LH Horizontal Tool Selection Menu -->
    <div id="lh-tool-menu" style="display: none;">
        <div class="tool-menu-container">
            <div class="tool-menu-header">- LEFT HAND TOOLS</div>
            <div class="tool-menu-items" id="lh-tool-menu-items">
                <!-- Tools will be populated here -->
            </div>
            <div class="tool-menu-footer">
                <span id="lh-tool-description">Select a tool to view details</span>
            </div>
        </div>
    </div>

    <!-- CH Horizontal Tool Selection Menu -->
    <div id="ch-tool-menu" style="display: none;">
        <div class="tool-menu-container">
            <div class="tool-menu-header">- CONSCIOUS HAND TOOLS</div>
            <div class="tool-menu-items" id="ch-tool-menu-items">
                <!-- Tools will be populated here -->
            </div>
            <div class="tool-menu-footer">
                <span id="ch-tool-description">Select a tool to view details</span>
            </div>
        </div>
    </div>

    <!-- Pause Overlay -->
    <div class="pause-overlay" id="pause-overlay">
        <div class="pause-menu">
            <div class="pause-title">PAUSED</div>
            <button class="pause-btn" id="resume-btn">Resume</button>
        </div>
    </div>

    <!-- Pocket Panel -->
    <div class="pocket-panel" id="pocket-panel">
        <div class="pocket-header">USER POCKET</div>
        <div class="pocket-grid" id="pocket-grid"></div>
        <div class="pocket-pagination" style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-top: 15px; padding: 10px;">
            <button id="pocket-prev-page" style="padding: 6px 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px;"> PREV</button>
            <span id="pocket-page-info" style="font-size: 12px; color: #fff; min-width: 80px; text-align: center;">Page 1 / 10</span>
            <button id="pocket-next-page" style="padding: 6px 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px;">NEXT </button>
        </div>
    </div>


    <!-- Orbit Controls Panel -->
    <div id="orbit-controls-panel" class="minimized" style="display: none;">
        <div class="panel-header" id="orbit-panel-header">
            <span class="panel-title"> ORBIT CONTROLS</span>
            <div class="panel-controls">
                <button class="panel-btn" id="orbit-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="orbit-minimize-btn">_</button>
                <button class="panel-btn close-btn" id="orbit-close-btn"></button>
            </div>
        </div>
        <div class="panel-content hidden" id="orbit-panel-content" style="padding: 16px;">
            
            <!-- Enable/Disable -->
            <div style="margin-bottom: 20px;">
                <button id="orbit-enabled-btn" class="myspace-control-btn active" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                     ENABLED
                </button>
            </div>
            
            <!-- Auto Rotate -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Auto Rotate</div>
                <button id="orbit-autorotate-btn" class="myspace-control-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                    AUTO ROTATE OFF
                </button>
            </div>
            
            <!-- Auto Rotate Speed -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Auto Rotate Speed</div>
                <input type="range" id="orbit-autorotate-speed" min="0" max="10" value="2" step="0.1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-autorotate-speed-value">2.0</span>
                    <span>10</span>
                </div>
            </div>
            
            <!-- Damping -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Enable Damping</div>
                <button id="orbit-damping-btn" class="myspace-control-btn active" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                     DAMPING ON
                </button>
            </div>
            
            <!-- Damping Factor -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Damping Factor</div>
                <input type="range" id="orbit-damping-factor" min="0" max="1" value="0.05" step="0.01" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-damping-factor-value">0.05</span>
                    <span>1</span>
                </div>
            </div>
            
            <!-- Rotate Speed -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Rotate Speed</div>
                <input type="range" id="orbit-rotate-speed" min="0" max="5" value="1" step="0.1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-rotate-speed-value">1.0</span>
                    <span>5</span>
                </div>
            </div>
            
            <!-- Pan Speed -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Pan Speed</div>
                <input type="range" id="orbit-pan-speed" min="0" max="5" value="1" step="0.1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-pan-speed-value">1.0</span>
                    <span>5</span>
                </div>
            </div>
            
            <!-- Zoom Speed -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Zoom Speed</div>
                <input type="range" id="orbit-zoom-speed" min="0" max="5" value="1" step="0.1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-zoom-speed-value">1.0</span>
                    <span>5</span>
                </div>
            </div>
            
            <!-- Min Distance -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Min Distance</div>
                <input type="range" id="orbit-min-distance" min="0" max="1000" value="0" step="10" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-min-distance-value">0</span>
                    <span>1000</span>
                </div>
            </div>
            
            <!-- Max Distance -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Max Distance</div>
                <input type="range" id="orbit-max-distance" min="0" max="10000" value="Infinity" step="100" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-max-distance-value"></span>
                    <span>10000</span>
                </div>
            </div>
            
            <!-- Min Polar Angle -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Min Polar Angle (deg)</div>
                <input type="range" id="orbit-min-polar" min="0" max="180" value="0" step="1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-min-polar-value">0</span>
                    <span>180</span>
                </div>
            </div>
            
            <!-- Max Polar Angle -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Max Polar Angle (deg)</div>
                <input type="range" id="orbit-max-polar" min="0" max="180" value="180" step="1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="orbit-max-polar-value">180</span>
                    <span>180</span>
                </div>
            </div>
            
            <!-- Min Azimuth Angle -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Min Azimuth Angle (deg)</div>
                <input type="range" id="orbit-min-azimuth" min="-180" max="180" value="-180" step="1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>-180</span>
                    <span id="orbit-min-azimuth-value">-</span>
                    <span>180</span>
                </div>
            </div>
            
            <!-- Max Azimuth Angle -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Max Azimuth Angle (deg)</div>
                <input type="range" id="orbit-max-azimuth" min="-180" max="180" value="180" step="1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>-180</span>
                    <span id="orbit-max-azimuth-value"></span>
                    <span>180</span>
                </div>
            </div>
            
            <!-- Enable Pan -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Enable Pan</div>
                <button id="orbit-enable-pan-btn" class="myspace-control-btn active" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                     PAN ON
                </button>
            </div>
            
            <!-- Enable Zoom -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Enable Zoom</div>
                <button id="orbit-enable-zoom-btn" class="myspace-control-btn active" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                     ZOOM ON
                </button>
            </div>
            
            <!-- Enable Rotate -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Enable Rotate</div>
                <button id="orbit-enable-rotate-btn" class="myspace-control-btn active" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                     ROTATE ON
                </button>
            </div>
            
            <!-- Update Button -->
            <div style="margin-top: 30px;">
                <button id="orbit-update-btn" class="myspace-control-btn" style="width: 100%; padding: 14px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700; transition: all 0.3s; box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);">
                     UPDATE CONTROLS
                </button>
            </div>
            
        </div>
        <!-- Resize Handle -->
        <div class="resize-handle"></div>
    </div>

    <!-- User Controls Panel -->
    <div id="user-controls-panel" class="minimized" style="display: none;">
        <div class="panel-header" id="user-panel-header">
            <span class="panel-title"> USER CONTROLS</span>
            <div class="panel-controls">
                <button class="panel-btn" id="user-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="user-minimize-btn">_</button>
                <button class="panel-btn close-btn" id="user-close-btn"></button>
            </div>
        </div>
        <div class="panel-content hidden" id="user-panel-content" style="padding: 16px;">
            
            <!-- God Mode -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">God Mode</div>
                <button id="user-godmode-btn" class="myspace-control-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                    GOD MODE OFF
                </button>
                <div style="font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-top: 6px;">Super fast movement & no gravity</div>
            </div>
            
            <!-- Movement Speed -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Movement Speed</div>
                <input type="range" id="user-move-speed" min="0.1" max="10" value="0.2" step="0.1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0.1</span>
                    <span id="user-move-speed-value">0.2</span>
                    <span>10.0</span>
                </div>
            </div>
            
            <!-- Jump Speed -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Jump Speed</div>
                <input type="range" id="user-jump-speed" min="0.1" max="5" value="1" step="0.1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0.1</span>
                    <span id="user-jump-speed-value">1.0</span>
                    <span>5.0</span>
                </div>
            </div>
            
            <!-- Sprint Multiplier -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Sprint Multiplier</div>
                <input type="range" id="user-sprint-mult" min="1" max="5" value="2" step="0.5" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>1x</span>
                    <span id="user-sprint-mult-value">2.0x</span>
                    <span>5x</span>
                </div>
            </div>
            
            <!-- Gravity -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Gravity</div>
                <input type="range" id="user-gravity" min="0" max="2" value="0.5" step="0.1" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>0</span>
                    <span id="user-gravity-value">0.5</span>
                    <span>2.0</span>
                </div>
            </div>
            
            <!-- Look Sensitivity -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Look Sensitivity</div>
                <input type="range" id="user-look-sens" min="0.0001" max="0.01" value="0.002" step="0.0001" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>Low</span>
                    <span id="user-look-sens-value">0.002</span>
                    <span>High</span>
                </div>
            </div>
            
            <!-- Enable Invert Y -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Invert Y-Axis</div>
                <button id="user-invert-y-btn" class="myspace-control-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                    INVERT Y OFF
                </button>
            </div>
            
            <!-- Update Button -->
            <div style="margin-top: 30px;">
                <button id="user-update-btn" class="myspace-control-btn" style="width: 100%; padding: 14px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700; transition: all 0.3s; box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);">
                     UPDATE CONTROLS
                </button>
            </div>
            
        </div>
        <!-- Resize Handle -->
        <div class="resize-handle"></div>
    </div>

    <!-- Default Space Panel -->
    <div id="default-space-panel" class="minimized" style="display: none;">
        <div class="panel-header" id="default-space-header">
            <span class="panel-title"> DEFAULT SPACE</span>
            <div class="panel-controls">
                <button class="panel-btn" id="default-space-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="default-space-minimize-btn">_</button>
                <button class="panel-btn close-btn" id="default-space-close-btn"></button>
            </div>
        </div>
        <div class="panel-content hidden" id="default-space-content" style="padding: 16px;">
            
            <!-- Dark Mode -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Dark Mode</div>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="dark-mode-checkbox" checked style="width: 20px; height: 20px; cursor: pointer; margin-right: 10px;">
                    <span style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">Enable Dark Background</span>
                </label>
            </div>
            
            <!-- Light Mode -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Light Mode</div>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="light-mode-checkbox" style="width: 20px; height: 20px; cursor: pointer; margin-right: 10px;">
                    <span style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">Enable Light Background</span>
                </label>
            </div>
            
            <!-- Divider -->
            <div style="margin: 25px 0; height: 1px; background: rgba(128, 128, 128, 0.3);"></div>
            
            <!-- Default Color Picker -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Default Background Color</div>
                <input type="color" id="default-bg-color-picker" value="#a1a1a1" style="width: 100%; height: 50px; cursor: pointer; border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; background: transparent;">
            </div>
            
            <!-- Grid Color Picker -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Grid Color</div>
                <input type="color" id="grid-color-picker" value="#ffffff" style="width: 100%; height: 50px; cursor: pointer; border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; background: transparent;">
            </div>
            
            <!-- Divider -->
            <div style="margin: 25px 0; height: 1px; background: rgba(128, 128, 128, 0.3);"></div>
            
            <!-- Skybox Image/Video Upload -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Skybox Image/Video</div>
                <div style="margin-bottom: 10px;">
                    <label for="skybox-file-input" style="display: block; width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; text-align: center; transition: all 0.3s;">
                         CHOOSE FILE
                    </label>
                    <input type="file" id="skybox-file-input" accept="image/*,video/*" style="display: none;">
                </div>
                <div id="skybox-filename" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-top: 8px; text-align: center;">
                    No file selected
                </div>
            </div>
            
            <!-- Remove Skybox Button -->
            <div style="margin-bottom: 20px;">
                <button id="remove-skybox-btn" class="myspace-control-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                     REMOVE SKYBOX
                </button>
            </div>
            
            <!-- Update Button -->
            <div style="margin-top: 30px;">
                <button id="default-space-update-btn" class="myspace-control-btn" style="width: 100%; padding: 14px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 13px; font-weight: 700; transition: all 0.3s; box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);">
                     UPDATE SPACE
                </button>
            </div>
            
        </div>
        <!-- Resize Handle -->
        <div class="resize-handle"></div>
    </div>

    <!-- MySpace Panel -->
        <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 25px 0;"></div>
        
        <!-- Particle Count -->
        <div style="margin-bottom: 20px;">
            <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px;">Particle Count</div>
            <input type="range" id="particle-count-slider" min="3000" max="6000" value="3000" step="100" style="width: 100%; cursor: pointer; margin-bottom: 8px;">
            <div style="display: flex; justify-content: space-between; font-size: 11px;">
                <span>3,000</span>
                <span id="particle-count-value">3,000</span>
                <span>6,000</span>
            </div>
        </div>
        
        <!-- Divider -->
        <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 25px 0;"></div>
        
        <!-- Particle System Rotation -->
        <div style="margin-bottom: 20px;">
            <div style="font-weight: 600; margin-bottom: 15px; font-size: 14px;">Particle System Rotation</div>
            
            <!-- X Rotation -->
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">X-Axis</span>
                    <span id="particle-rot-x-value" style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">0</span>
                </div>
                <input type="range" id="particle-rot-x-slider" min="0" max="360" value="0" style="width: 100%; cursor: pointer;">
            </div>
            
            <!-- Y Rotation -->
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">Y-Axis</span>
                    <span id="particle-rot-y-value" style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">0</span>
                </div>
                <input type="range" id="particle-rot-y-slider" min="0" max="360" value="0" style="width: 100%; cursor: pointer;">
            </div>
            
            <!-- Z Rotation -->
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                    <span style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">Z-Axis</span>
                    <span id="particle-rot-z-value" style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">71</span>
                </div>
                <input type="range" id="particle-rot-z-slider" min="0" max="360" value="71" style="width: 100%; cursor: pointer;">
            </div>
            
            <button id="particle-rot-reset" style="width: 100%; padding: 8px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600;">
                RESET ROTATION
            </button>
        </div>
    </div>

    <!-- FAQ Panel -->
    <div id="faq-panel">
        <div class="panel-header">
            <span class="panel-title">- CONTROLS & FAQ</span>
            <button class="panel-btn close-btn" id="faq-close"></button>
        </div>
        <div class="faq-content">
            <div class="faq-item">
                <div class="faq-question"> Keyboard Controls</div>
                <div class="faq-answer" style="line-height: 2;">
                    <strong>W</strong> - Move forward<br>
                    <strong>A</strong> - Move left<br>
                    <strong>S</strong> - Move backward<br>
                    <strong>D</strong> - Move right<br>
                    <strong>R</strong> - Move up<br>
                    <strong>F</strong> - Move down<br>
                    <strong>C</strong> - Hold to enable mouse look (FPS mode)<br>
                    <strong>O</strong> - Reset camera to origin (0, 0, 10)<br>
                    <strong>0</strong> - Toggle MySpace (collapse/expand grid)<br>
                    <strong>9</strong> - Toggle User Pocket<br>
                    <strong>Q</strong> - Toggle Controls & FAQ panel<br>
                    <strong>X</strong> - Toggle Inspector panel<br>
                    <strong>Z</strong> - Toggle docks visibility<br>
                    <strong>Left Shift</strong> - Toggle Left Hand menu<br>
                    <strong>Right Shift</strong> - Toggle Right Hand menu<br>
                    <strong>Enter</strong> - Toggle Conscious Hand menu
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question"> Mouse Controls</div>
                <div class="faq-answer">
                    <strong>Hold C + Move mouse</strong> - Look around (FPS style)<br>
                    <strong>Click objects</strong> - Select journal pages or grid panels<br>
                    <strong>Click + Drag</strong> - Orbit camera around scene
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question"> Mobile Controls</div>
                <div class="faq-answer">
                    <strong>Joystick (bottom left)</strong> - Move camera position<br>
                    <strong>Single finger touch on screen</strong> - Look around (FPS camera rotation)<br>
                    <strong>POS/ROT/SCL buttons</strong> - Adjust position, rotation, scale<br>
                    <strong>Action buttons (A1-A30)</strong> - Custom quick actions
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question"> UI Panels</div>
                <div class="faq-answer">
                    <strong>Top Left</strong> - Session info (space title, username, timer)<br>
                    <strong>Top Right</strong> - Search panel (click icon to expand)<br>
                    <strong>Inspector (X key)</strong> - Object properties and transparency<br>
                    <strong>Side Menus</strong> - Click hamburger icons for navigation
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question"> Hand Menus</div>
                <div class="faq-answer">
                    <strong>Left Hand (LH)</strong> - Left Shift key or LH button - Radial menu with 10 options<br>
                    <strong>Right Hand (RH)</strong> - Right Shift key or RH button - Radial menu with 10 options<br>
                    <strong>Conscious Hand (CH)</strong> - Enter key or CH button - Main menu controls including Pause Menu<br>
                    Click on radial menu items to select options. Only one hand menu visible at a time.
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question"> MySpace (Grid Sphere)</div>
                <div class="faq-answer">
                    The spherical grid is your personal space. Press <strong>0 key</strong> or the <strong>MS button</strong> to collapse/expand it. When collapsed, panels animate one-by-one into a smaller sphere. Access also via Conscious Hand menu  MySpace option.
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question"> User Pocket</div>
                <div class="faq-answer">
                    Your pocket stores up to <strong>20 items</strong>. Press <strong>9 key</strong> or select from Conscious Hand menu. The pocket panel slides in from the right with a 4x5 grid.<br><br>
                    <strong>Cell States:</strong><br>
                     Empty slots: Dashed border, ready for items<br>
                     Items in pocket: 35% opacity (stored)<br>
                     Items deployed in scene: 20% opacity (active)<br><br>
                    Click slots to deploy/recall items. Items can have password protection for security.
                </div>
            </div>
            <div class="faq-item">
                <div class="faq-question">How do I navigate the site?</div>
                <div class="faq-answer">Click the hamburger menus () at the top left (Admin/System) and top right (Site Pages) to access different sections. Click outside the menu to close it.</div>
            </div>
            <div class="faq-item">
                <div class="faq-question">What are the docks?</div>
                <div class="faq-answer">Docks are located on all four edges (top, bottom, left, right). They contain draggable items (D1-D14) you can move between docks by clicking and dragging. Press <strong>Z</strong> to show/hide all docks.</div>
            </div>
            <div class="faq-item">
                <div class="faq-question">How do I select and manipulate objects?</div>
                <div class="faq-answer">Click on any journal page or grid panel to select it. Selected objects turn blue and the camera animates to focus on them. Press <strong>X</strong> to open the Inspector panel where you can adjust transparency (10-100%) and view object details.</div>
            </div>
            <div class="faq-item">
                <div class="faq-question">What do the transform buttons do?</div>
                <div class="faq-answer">The <strong>POS</strong>, <strong>ROT</strong>, and <strong>SCL</strong> buttons open transform panels to adjust position, rotation, and scale of selected objects with precise control. Use the step size control to determine how much each adjustment changes the values (range: -1000 to 1000).</div>
            </div>
        </div>
    </div>

    <!-- Inspector Panel (Hidden - merged into OmniKeys Panel) -->
    <div id="inspector-panel" class="minimized" style="position: fixed; left: 20px; top: 120px; display: none;">
        <div class="panel-header" id="panel-header">
            <span class="panel-title"> INSPECTOR</span>
            <div class="panel-controls">
                <button class="panel-btn" id="inspector-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="minimize-btn">_</button>
                <button class="panel-btn close-btn" id="close-btn"></button>
            </div>
        </div>
        <div class="panel-content hidden" id="panel-content" style="padding: 16px;">
            <!-- Selected Object Name -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 6px;">SELECTED OBJECT</div>
                <div class="info-value" id="selected-name" style="font-size: 14px; font-weight: 700; color: #808080;">None</div>
            </div>
            
            <!-- Object Transform Properties -->
            <div id="object-details" style="display: none;">
                <!-- Position -->
                <div style="margin-bottom: 15px;">
                    <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 6px;">POSITION</div>
                    <div id="object-position" style="font-family: 'Courier New', monospace; font-size: 12px; color: #fff; background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 6px; border: 1px solid rgba(128, 128, 128, 0.3);">
                        X: 0.00 | Y: 0.00 | Z: 0.00
                    </div>
                </div>
                
                <!-- Rotation -->
                <div style="margin-bottom: 15px;">
                    <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 6px;">ROTATION</div>
                    <div id="object-rotation" style="font-family: 'Courier New', monospace; font-size: 12px; color: #fff; background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 6px; border: 1px solid rgba(128, 128, 128, 0.3);">
                        X: 0.00 | Y: 0.00 | Z: 0.00
                    </div>
                </div>
                
                <!-- Scale -->
                <div style="margin-bottom: 20px;">
                    <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 6px;">SCALE</div>
                    <div id="object-scale" style="font-family: 'Courier New', monospace; font-size: 12px; color: #fff; background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 6px; border: 1px solid rgba(128, 128, 128, 0.3);">
                        X: 1.00 | Y: 1.00 | Z: 1.00
                    </div>
                </div>
                
                <!-- Divider -->
                <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
                
                <!-- Object Data Section -->
                <div style="margin-bottom: 20px;">
                    <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">OBJECT DATA</div>
                    
                    <!-- Header Field -->
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Header</label>
                        <input type="text" id="object-data-header" placeholder="Enter header..." style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 12px; outline: none;">
                    </div>
                    
                    <!-- Body Field -->
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Body</label>
                        <textarea id="object-data-body" placeholder="Enter body content..." style="width: 100%; min-height: 120px; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 11px; outline: none; resize: vertical;"></textarea>
                    </div>
                    
                    <!-- Footer Field -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Footer</label>
                        <input type="text" id="object-data-footer" placeholder="Enter footer..." style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 12px; outline: none;">
                    </div>
                    
                    <!-- Icon Selector Section -->
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 8px;">Icon/Image</label>
                        
                        <!-- Icon Type Selector -->
                        <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                            <button class="icon-type-btn active" data-type="emoji" style="flex: 1; padding: 6px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 4px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600;"> EMOJI</button>
                            <button class="icon-type-btn" data-type="image" style="flex: 1; padding: 6px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 4px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600;"> IMAGE</button>
                            <button class="icon-type-btn" data-type="fontawesome" style="flex: 1; padding: 6px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 4px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600;"> ICON</button>
                        </div>
                        
                        <!-- Emoji Picker -->
                        <div id="emoji-picker" class="icon-picker-content" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; max-height: 150px; overflow-y: auto; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px;">
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                            <button class="emoji-option" data-emoji="" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 20px;"></button>
                        </div>
                        
                        <!-- Image Upload -->
                        <div id="image-picker" class="icon-picker-content" style="display: none;">
                            <input type="file" id="icon-image-upload" accept="image/*" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-size: 10px; cursor: pointer;">
                            <div id="image-preview" style="margin-top: 8px; min-height: 60px; display: flex; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: rgba(255, 255, 255, 0.4); font-size: 10px;">No image selected</div>
                        </div>
                        
                        <!-- Font Awesome Icons -->
                        <div id="fontawesome-picker" class="icon-picker-content" style="display: none; grid-template-columns: repeat(6, 1fr); gap: 4px; max-height: 150px; overflow-y: auto; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px;">
                            <button class="fa-option" data-icon="fa-home" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 16px;"></button>
                            <button class="fa-option" data-icon="fa-user" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 16px;"></button>
                            <button class="fa-option" data-icon="fa-heart" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 16px;"></button>
                            <button class="fa-option" data-icon="fa-star" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 16px;"></button>
                            <button class="fa-option" data-icon="fa-cog" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 16px;"></button>
                            <button class="fa-option" data-icon="fa-check" style="padding: 8px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 4px; cursor: pointer; font-size: 16px;"></button>
                        </div>
                        
                        <!-- Selected Icon Display -->
                        <div id="selected-icon-display" style="margin-top: 8px; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: rgba(255, 255, 255, 0.6); font-size: 10px; text-align: center;">
                            <span id="selected-icon-text">No icon selected</span>
                        </div>
                    </div>
                    
                    <!-- Submit Button -->
                    <button id="object-data-submit" style="width: 100%; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s; margin-bottom: 10px;">
                        SAVE DATA
                    </button>
                    
                    <!-- View Panel Button -->
                    <button id="open-view-panel-btn" style="width: 100%; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                         VIEW PANEL
                    </button>
                </div>
            </div>
            
            <!-- Info Section (Logic-style, expandable) -->
            <div id="info-section" style="margin-top: 20px;">
                <!-- Info Toggle Header -->
                <div id="info-toggle" style="display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; background: rgba(128, 128, 128, 0.2); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; cursor: pointer; margin-bottom: 0; transition: all 0.3s;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span id="info-arrow" style="font-size: 12px; transition: transform 0.3s;"></span>
                        <span style="font-size: 11px; font-weight: 700; color: rgba(255, 255, 255, 0.8); letter-spacing: 0.5px;">INFO</span>
                    </div>
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.5);">Click to expand</span>
                </div>
                
                <!-- Info Content (Collapsible) -->
                <div id="info-content" style="display: none; border: 1px solid rgba(128, 128, 128, 0.3); border-top: none; border-radius: 0 0 6px 6px; overflow: hidden; background: rgba(0, 0, 0, 0.2);">
                    <!-- Keyboard Shortcuts Section -->
                    <div style="padding: 12px; border-bottom: 1px solid rgba(128, 128, 128, 0.2);">
                        <div style="font-size: 10px; font-weight: 700; color: rgba(255, 255, 255, 0.6); margin-bottom: 8px; letter-spacing: 0.5px;">KEYBOARD SHORTCUTS</div>
                        <div style="font-family: 'Courier New', monospace; font-size: 10px; color: rgba(255, 255, 255, 0.8); line-height: 1.6;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: rgba(255, 255, 255, 0.5);">POS Mode:</span>
                                <span style="background: rgba(128, 128, 128, 0.3); padding: 2px 6px; border-radius: 3px;">P</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: rgba(255, 255, 255, 0.5);">ROT Mode:</span>
                                <span style="background: rgba(128, 128, 128, 0.3); padding: 2px 6px; border-radius: 3px;">R</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: rgba(255, 255, 255, 0.5);">SCL Mode:</span>
                                <span style="background: rgba(128, 128, 128, 0.3); padding: 2px 6px; border-radius: 3px;">S</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: rgba(255, 255, 255, 0.5);">Inspector:</span>
                                <span style="background: rgba(128, 128, 128, 0.3); padding: 2px 6px; border-radius: 3px;">X</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span style="color: rgba(255, 255, 255, 0.5);">Reset Camera:</span>
                                <span style="background: rgba(128, 128, 128, 0.3); padding: 2px 6px; border-radius: 3px;">O</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: rgba(255, 255, 255, 0.5);">Balance View:</span>
                                <span style="background: rgba(128, 128, 128, 0.3); padding: 2px 6px; border-radius: 3px;">B</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Header Section -->
                    <div style="padding: 12px; border-bottom: 1px solid rgba(128, 128, 128, 0.2);">
                        <div style="font-size: 10px; font-weight: 700; color: rgba(255, 255, 255, 0.6); margin-bottom: 6px; letter-spacing: 0.5px;">HEADER</div>
                        <div id="info-header" style="font-size: 11px; color: rgba(255, 255, 255, 0.9); line-height: 1.5;">
                            mniExp 3D Journal Viewer
                        </div>
                    </div>
                    
                    <!-- Body Section -->
                    <div style="padding: 12px; border-bottom: 1px solid rgba(128, 128, 128, 0.2);">
                        <div style="font-size: 10px; font-weight: 700; color: rgba(255, 255, 255, 0.6); margin-bottom: 6px; letter-spacing: 0.5px;">BODY</div>
                        <div id="info-body" style="font-size: 10px; color: rgba(255, 255, 255, 0.7); line-height: 1.6; max-height: 200px; overflow-y: auto;">
                            Navigate your consciousness through MySpace. Use POS, ROT, and SCL controls to transform yourself or selected objects. When nothing is selected, controls affect your camera position. Select any grid panel to modify objects in the space.
                        </div>
                    </div>
                    
                    <!-- Footer Section -->
                    <div style="padding: 12px;">
                        <div style="font-size: 10px; font-weight: 700; color: rgba(255, 255, 255, 0.6); margin-bottom: 6px; letter-spacing: 0.5px;">FOOTER</div>
                        <div id="info-footer" style="font-size: 9px; color: rgba(255, 255, 255, 0.5); font-style: italic;">
                            Current Mode: <span id="info-current-mode" style="color: rgba(255, 255, 255, 0.8); font-weight: 600;">Navigation</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Resize Handle -->
        <div id="inspector-resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; background: linear-gradient(135deg, transparent 50%, rgba(128, 128, 128, 0.5) 50%); border-bottom-right-radius: 16px;"></div>
    </div>

    <!-- MySpace Control Panel -->
    <div id="myspace-panel" class="minimized">
        <div class="panel-header" id="myspace-panel-header">
            <span class="panel-title"> MYSPACE</span>
            <div class="panel-controls">
                <button class="panel-btn" id="myspace-minimize-btn">_</button>
                <button class="panel-btn close-btn" id="myspace-close-btn"></button>
            </div>
        </div>
        <div class="panel-content hidden" id="myspace-panel-content" style="padding: 16px;">
            
            <!-- Summon / DeSummon -->
            <div style="margin-bottom: 20px;">
                <button id="summon-toggle-btn" class="myspace-control-btn active" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                     SUMMONED
                </button>
            </div>
            
            <!-- MyZone Toggle -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">MyZone</div>
                <button id="myzone-toggle-btn" class="myspace-control-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                    LOCK TO VIEW
                </button>
                <div style="font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-top: 6px;">Sticks MySpace to camera view</div>
            </div>
            
            <!-- Rotation Controls -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Rotate Grid View</div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                    <div></div>
                    <button id="rotate-up-btn" class="myspace-control-btn" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-size: 16px; transition: all 0.3s;"></button>
                    <div></div>
                    
                    <button id="rotate-left-btn" class="myspace-control-btn" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-size: 16px; transition: all 0.3s;"></button>
                    <button id="center-sphere-btn" class="myspace-control-btn" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-size: 20px; transition: all 0.3s;"></button>
                    <button id="rotate-right-btn" class="myspace-control-btn" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-size: 16px; transition: all 0.3s;"></button>
                    
                    <div></div>
                    <button id="rotate-down-btn" class="myspace-control-btn" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-size: 16px; transition: all 0.3s;"></button>
                    <div></div>
                </div>
            </div>
            
            <!-- Reset MySpace -->
            <div style="margin-bottom: 20px;">
                <button id="reset-myspace-btn" class="myspace-control-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                     RESET POSITION
                </button>
            </div>
            
            <!-- Wallpaper Control -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Change Wallpaper</div>
                <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                    <button id="wallpaper-image-btn" class="myspace-control-btn active" style="flex: 1; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.3s;">
                         IMAGE
                    </button>
                    <button id="wallpaper-video-btn" class="myspace-control-btn" style="flex: 1; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.3s;">
                         VIDEO
                    </button>
                    <button id="wallpaper-default-btn" class="myspace-control-btn" style="flex: 1; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600; transition: all 0.3s;">
                         DEFAULT
                    </button>
                </div>
                <input type="file" id="wallpaper-upload" accept="image/*,video/*" style="display: none;">
                <button id="wallpaper-upload-trigger" style="width: 100%; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.3s;">
                     UPLOAD FILE
                </button>
                <div id="wallpaper-preview" style="margin-top: 8px; font-size: 10px; color: rgba(255, 255, 255, 0.6);">
                    Current: Default Gradient
                </div>
            </div>
            
            <!-- Divider -->
            <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
            
            <!-- Sphere Rotation Controls -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Sphere Auto-Rotation</div>
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: rgba(128, 128, 128, 0.2); border-radius: 6px; transition: all 0.3s;">
                        <input type="checkbox" id="sphere-rotate-x" style="cursor: pointer; width: 18px; height: 18px;">
                        <span style="font-size: 12px; color: rgba(255, 255, 255, 0.9);">Rotate on X-axis</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: rgba(128, 128, 128, 0.2); border-radius: 6px; transition: all 0.3s;">
                        <input type="checkbox" id="sphere-rotate-y" style="cursor: pointer; width: 18px; height: 18px;">
                        <span style="font-size: 12px; color: rgba(255, 255, 255, 0.9);">Rotate on Y-axis</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: rgba(128, 128, 128, 0.2); border-radius: 6px; transition: all 0.3s;">
                        <input type="checkbox" id="sphere-rotate-z" style="cursor: pointer; width: 18px; height: 18px;">
                        <span style="font-size: 12px; color: rgba(255, 255, 255, 0.9);">Rotate on Z-axis</span>
                    </label>
                </div>
                <div style="font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-top: 6px;">Enable continuous rotation on selected axes</div>
            </div>
            
            <!-- Divider -->
            <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
            
            <!-- Grid Configuration -->
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Grid Type</div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                    <button class="myspace-grid-btn active" data-grid-type="spherical" style="padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 10px; font-weight: 600; transition: all 0.3s;">
                         SPHERICAL
                    </button>
                    <button class="myspace-grid-btn" data-grid-type="planar" style="padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 10px; font-weight: 600; transition: all 0.3s;">
                         PLANAR
                    </button>
                    <button class="myspace-grid-btn" data-grid-type="helix" style="padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 10px; font-weight: 600; transition: all 0.3s;">
                         HELIX
                    </button>
                    <button class="myspace-grid-btn" data-grid-type="cube" style="padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 10px; font-weight: 600; transition: all 0.3s;">
                         CUBE
                    </button>
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Grid Size</div>
                <input type="range" id="grid-size-slider" min="5" max="25" value="15" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>Small (5)</span>
                    <span id="grid-size-value">15</span>
                    <span>Large (25)</span>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Grid Spacing</div>
                <input type="range" id="grid-spacing-slider" min="1" max="5" value="2" step="0.5" style="width: 100%; cursor: pointer; margin-bottom: 6px;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                    <span>Tight (1)</span>
                    <span id="grid-spacing-value">2</span>
                    <span>Wide (5)</span>
                </div>
            </div>
            
            <button id="apply-grid-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.4); border: 1px solid rgba(128, 128, 128, 0.6); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
                 APPLY CHANGES
            </button>
        </div>
        <!-- Resize Handle -->
        <div id="myspace-resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; background: linear-gradient(135deg, transparent 50%, rgba(128, 128, 128, 0.5) 50%); border-bottom-right-radius: 16px;"></div>
    </div>

    <!-- mniKeys Control Panel -->
    <div id="omnikeys-panel" style="position: fixed; left: 20px; top: 120px; display: none;">
        <div class="panel-header" id="omnikeys-panel-header">
            <span class="panel-title">MNIKEYS INSPECTOR</span>
            <div class="panel-controls">
                <button class="panel-btn" id="omnikeys-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="omnikeys-minimize-btn">_</button>
                <button class="panel-btn close-btn" id="omnikeys-close-btn"></button>
            </div>
        </div>
        <div class="panel-content" id="omnikeys-panel-content" style="padding: 16px; max-height: calc(100vh - 200px); overflow-y: auto;">
            
            <!-- Selected Key Inspector -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">SELECTED KEY</div>
                <div id="selected-key-name" style="font-size: 14px; font-weight: 700; color: #ffffff; margin-bottom: 15px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; border: 1px solid rgba(128, 128, 128, 0.3);">
                    None
                </div>
                
                <!-- Entity Field -->
                <div style="margin-bottom: 12px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Surface Level Entity</label>
                    <input type="text" id="key-entity" placeholder="Enter entity..." style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 12px; outline: none;">
                </div>
                
                <!-- Function/Action Field -->
                <div style="margin-bottom: 12px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Desired Function / Action</label>
                    <textarea id="key-function" placeholder="Enter function or action..." style="width: 100%; min-height: 80px; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 11px; outline: none; resize: vertical;"></textarea>
                </div>
                
                <!-- Submit Button -->
                <button id="key-submit-btn" style="width: 100%; padding: 10px; background: rgba(128, 128, 128, 0.4); border: 1px solid rgba(128, 128, 128, 0.6); border-radius: 6px; color: #fff; cursor: pointer; font-size: 11px; font-weight: 600; font-family: 'Orbitron', sans-serif;">
                    APPLY TO KEY
                </button>
            </div>
            
            <!-- Divider -->
            <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
            
            <!-- Position Controls -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">POSITION (Camera Relative)</div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>X-Axis</span>
                        <span id="kb-pos-x-value">0.00</span>
                    </label>
                    <input type="range" id="kb-pos-x" min="-20" max="20" step="0.1" value="0" style="width: 100%;">
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Y-Axis</span>
                        <span id="kb-pos-y-value">-1.50</span>
                    </label>
                    <input type="range" id="kb-pos-y" min="-10" max="10" step="0.1" value="-1.5" style="width: 100%;">
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Z-Axis (Depth)</span>
                        <span id="kb-pos-z-value">-8.60</span>
                    </label>
                    <input type="range" id="kb-pos-z" min="-20" max="0" step="0.1" value="-8.6" style="width: 100%;">
                </div>
            </div>
            
            <!-- Divider -->
            <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
            
            <!-- Rotation Controls -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">ROTATION</div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>= X-Axis (Tilt Up/Down)</span>
                        <span id="kb-rot-x-value">0.90</span>
                    </label>
                    <input type="range" id="kb-rot-x" min="-1.57" max="1.57" step="0.01" value="0.9" style="width: 100%;">
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>[ ] Y-Axis (Spin Left/Right)</span>
                        <span id="kb-rot-y-value">0.00</span>
                    </label>
                    <input type="range" id="kb-rot-y" min="-3.14" max="3.14" step="0.01" value="0" style="width: 100%;">
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>' Z-Axis (Roll)</span>
                        <span id="kb-rot-z-value">0.00</span>
                    </label>
                    <input type="range" id="kb-rot-z" min="-3.14" max="3.14" step="0.01" value="0" style="width: 100%;">
                </div>
            </div>
            
            <!-- Divider -->
            <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
            
            <!-- Scale Controls -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">SCALE</div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Uniform Scale</span>
                        <span id="kb-scale-value">0.20</span>
                    </label>
                    <input type="range" id="kb-scale" min="0.1" max="3" step="0.1" value="0.2" style="width: 100%;">
                </div>
            </div>
            
            <!-- Divider -->
            <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
            
            <!-- Spacing Controls -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">KEY SPACING</div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Horizontal Gap</span>
                        <span id="kb-spacing-value">2.60</span>
                    </label>
                    <input type="range" id="kb-spacing" min="1" max="10" step="0.1" value="2.6" style="width: 100%;">
                </div>
                
                <div style="margin-bottom: 10px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Vertical Gap (Rows)</span>
                        <span id="kb-row-spacing-value">3.20</span>
                    </label>
                    <input type="range" id="kb-row-spacing" min="1" max="10" step="0.1" value="3.2" style="width: 100%;">
                </div>
            </div>
            
            <!-- Divider -->
            <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
            
            <!-- Quick Actions -->
            <div style="margin-bottom: 10px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">QUICK ACTIONS</div>
                
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button id="kb-reset-position" style="flex: 1; min-width: 80px; padding: 8px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600;">RESET POS</button>
                    <button id="kb-reset-rotation" style="flex: 1; min-width: 80px; padding: 8px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600;">RESET ROT</button>
                    <button id="kb-reset-all" style="flex: 1 1 100%; padding: 8px; background: rgba(128, 128, 128, 0.4); border: 1px solid rgba(128, 128, 128, 0.6); border-radius: 6px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600;">RESET ALL</button>
                </div>
            </div>
            
            <!-- Divider -->
            <div style="height: 1px; background: rgba(128, 128, 128, 0.2); margin: 20px 0;"></div>
            
            <!-- Still Mode -->
            <div style="margin-bottom: 10px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">KEYBOARD MODE</div>
                
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; border: 1px solid rgba(128, 128, 128, 0.3);">
                    <input type="checkbox" id="kb-still-mode" style="width: 16px; height: 16px; cursor: pointer;">
                    <span style="font-size: 11px; color: rgba(255, 255, 255, 0.8);">Still Mode (Typable)</span>
                </label>
                
                <div style="font-size: 9px; color: rgba(255, 255, 255, 0.4); margin-top: 6px; padding-left: 8px;">
                     Keys jump when typed<br>
                     Movement controls disabled<br>
                     Auto-disconnect on text fields
                </div>
            </div>
            
        </div>
        <!-- Resize Handle -->
        <div id="omnikeys-resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; background: linear-gradient(135deg, transparent 50%, rgba(128, 128, 128, 0.5) 50%); border-bottom-right-radius: 16px;"></div>
    </div>

    <!-- Help Panel -->
    <div id="help-panel" class="minimized" style="position: fixed; right: 20px; top: 120px;">
        <div class="panel-header" id="help-panel-header">
            <span class="panel-title">?-Help</span>
            <div class="panel-controls">
                <button class="panel-btn" id="help-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="help-minimize-btn"></button>
                <button class="panel-btn close-btn" id="help-close-btn"></button>
            </div>
        </div>
        <div class="panel-content hidden" id="help-panel-content" style="padding: 12px; max-width: 280px;">
            <div style="font-size: 11px; font-weight: 600; color: rgba(255, 255, 255, 0.9); margin-bottom: 12px;">KEYBOARD SHORTCUTS</div>
            <div style="font-family: 'Courier New', monospace; font-size: 10px; line-height: 1.6; color: rgba(255, 255, 255, 0.8);">
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span>Movement</span>
                    <span style="color: rgba(255, 255, 255, 0.5);">WASD</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span>Up/Down</span>
                    <span style="color: rgba(255, 255, 255, 0.5);">R/F</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span>Mouse Look</span>
                    <span style="color: rgba(255, 255, 255, 0.5);">Hold C</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span>Reset Camera</span>
                    <span style="color: rgba(255, 255, 255, 0.5);">O</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span>OmniSense Mode</span>
                    <span style="color: rgba(255, 255, 255, 0.5);">L</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                    <span>Toggle Docks</span>
                    <span style="color: rgba(255, 255, 255, 0.5);">Z</span>
                </div>
            </div>
        </div>
    </div>
    </div>

    <!-- OmniConduit Navigation Map Panel -->
    <div id="omnimap-panel" class="minimized" style="position: fixed; right: 20px; top: 450px;">
        <div class="panel-header" id="omnimap-panel-header">
            <span class="panel-title"> NODE MAP</span>
            <div class="panel-controls">
                <button class="panel-btn" id="omnimap-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="omnimap-minimize-btn">_</button>
                <button class="panel-btn close-btn" id="omnimap-close-btn"></button>
            </div>
        </div>
        <div class="panel-content hidden" id="omnimap-panel-content" style="padding: 16px;">
            
            <!-- Current Location -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 8px;">CURRENT NODE</div>
                <div id="current-node-display" style="font-size: 14px; font-weight: 700; color: #00ff00; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 255, 0, 0.5); border-radius: 6px; text-align: center;">
                    MySpace Landing Zone
                </div>
            </div>
            
            <!-- 3D Network Map -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">REALITY NODE NETWORK</div>
                
                <!-- Visual Map Grid -->
                <div style="background: rgba(0, 0, 0, 0.4); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 8px; padding: 15px; font-family: monospace; font-size: 9px; line-height: 1.8;">
                    
                    <!-- Top Row (Diagonal Upper) -->
                    <div style="display: flex; justify-content: space-around; margin-bottom: 10px;">
                        <button class="node-btn" data-node="topDiagonalLeft" style="width: 50px; height: 35px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 6px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            L<br>TOP
                        </button>
                        <div style="width: 50px;"></div>
                        <button class="node-btn" data-node="topDiagonalRight" style="width: 50px; height: 35px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 6px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            R<br>TOP
                        </button>
                    </div>
                    
                    <!-- Upper Middle Row (Front row) -->
                    <div style="display: flex; justify-content: space-around; margin-bottom: 10px;">
                        <button class="node-btn" data-node="frontLeftSpace" style="width: 45px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            F-L
                        </button>
                        <button class="node-btn" data-node="frontSpace" style="width: 45px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            FWD
                        </button>
                        <button class="node-btn" data-node="frontRightSpace" style="width: 45px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            F-R
                        </button>
                    </div>
                    
                    <!-- Center Row (MySpace row) -->
                    <div style="display: flex; justify-content: space-around; align-items: center; margin-bottom: 10px;">
                        <button class="node-btn" data-node="leftSpace" style="width: 45px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            LEFT
                        </button>
                        <button class="node-btn active-node" data-node="mySpace" style="width: 60px; height: 45px; background: rgba(0, 255, 0, 0.3); border: 2px solid rgba(0, 255, 0, 0.8); border-radius: 8px; color: #00ff00; cursor: pointer; font-size: 9px; font-weight: 700; font-family: 'Orbitron', sans-serif; box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);">
                            <br>MY
                        </button>
                        <button class="node-btn" data-node="rightSpace" style="width: 45px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            RGT
                        </button>
                    </div>
                    
                    <!-- Lower Middle Row (Back row) -->
                    <div style="display: flex; justify-content: space-around; margin-bottom: 10px;">
                        <button class="node-btn" data-node="rearLeftSpace" style="width: 45px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            R-L
                        </button>
                        <button class="node-btn" data-node="backSpace" style="width: 45px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            BACK
                        </button>
                        <button class="node-btn" data-node="rearRightSpace" style="width: 45px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            R-R
                        </button>
                    </div>
                    
                    <!-- Rear Layer -->
                    <div style="display: flex; justify-content: center; margin-bottom: 10px;">
                        <button class="node-btn" data-node="behindSpace" style="width: 50px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 5px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            REAR
                        </button>
                    </div>
                    
                    <!-- Bottom Row (Diagonal Lower) -->
                    <div style="display: flex; justify-content: space-around;">
                        <button class="node-btn" data-node="bottomDiagonalLeft" style="width: 50px; height: 35px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 6px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            L<br>BOT
                        </button>
                        <div style="width: 50px;"></div>
                        <button class="node-btn" data-node="bottomDiagonalRight" style="width: 50px; height: 35px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 6px; color: #fff; cursor: pointer; font-size: 7px; font-family: 'Orbitron', sans-serif;">
                            R<br>BOT
                        </button>
                    </div>
                    
                </div>
            </div>
            
            <!-- Connection Info -->
            <div style="margin-bottom: 15px;">
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 8px;">ACTIVE CONDUITS</div>
                <div style="font-size: 10px; color: rgba(255, 255, 255, 0.7); padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px;">
                    <div style="margin-bottom: 4px;"> 13 OmniConduits Active</div>
                    <div style="margin-bottom: 4px;"> All Paths Open</div>
                    <div> Two-Way Traversal</div>
                </div>
            </div>
            
            <!-- Legend -->
            <div>
                <div class="info-label" style="font-size: 11px; color: rgba(255, 255, 255, 0.6); margin-bottom: 8px;">LEGEND</div>
                <div style="font-size: 9px; color: rgba(255, 255, 255, 0.6); line-height: 1.6;">
                    <div> = Current Node</div>
                    <div> = Available Node</div>
                    <div> = Click to Traverse</div>
                </div>
            </div>
            
        </div>
        <!-- Resize Handle -->
        <div id="omnimap-resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; background: linear-gradient(135deg, transparent 50%, rgba(128, 128, 128, 0.5) 50%); border-bottom-right-radius: 16px;"></div>
    </div>

    <!-- Particle.js Control Panel -->
    <div id="particle-panel" class="minimized" style="position: fixed; right: 20px; top: 280px;">
        <div class="panel-header" id="particle-panel-header">
            <span class="panel-title">Particles.js</span>
            <div class="panel-controls">
                <button class="panel-btn" id="particle-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="particle-minimize-btn">_</button>
                <button class="panel-btn close-btn" id="particle-close-btn"></button>
            </div>
        </div>
        <div class="panel-content hidden" id="particle-panel-content" style="padding: 16px; max-height: calc(100vh - 400px); overflow-y: auto;">
            
            <!-- PARTICLES SECTION -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 12px; color: rgba(255, 255, 255, 0.8); margin-bottom: 15px; font-weight: 700; border-bottom: 1px solid rgba(128, 128, 128, 0.3); padding-bottom: 8px;">PARTICLES</div>
                
                <!-- Number -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Number</span>
                        <span id="p-number-value">80</span>
                    </label>
                    <input type="range" id="p-number" min="10" max="300" step="10" value="80" style="width: 100%;">
                </div>
                
                <!-- Color -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Color</label>
                    <input type="color" id="p-color" value="#ffffff" style="width: 100%; height: 35px; border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; background: rgba(0, 0, 0, 0.3); cursor: pointer;">
                </div>
                
                <!-- Shape -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Shape</label>
                    <select id="p-shape" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 11px; cursor: pointer;">
                        <option value="circle">Circle</option>
                        <option value="edge">Edge</option>
                        <option value="triangle">Triangle</option>
                        <option value="polygon">Polygon</option>
                        <option value="star">Star</option>
                        <option value="image">Image</option>
                    </select>
                </div>
                
                <!-- Size -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Size</span>
                        <span id="p-size-value">3</span>
                    </label>
                    <input type="range" id="p-size" min="0.5" max="20" step="0.5" value="3" style="width: 100%;">
                </div>
                
                <!-- Size Random -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-size-random" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Random Size</span>
                    </label>
                </div>
                
                <!-- Size Animation -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-size-anim" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Animate Size</span>
                    </label>
                </div>
                
                <!-- Size Animation Speed -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Size Anim Speed</span>
                        <span id="p-size-anim-speed-value">3</span>
                    </label>
                    <input type="range" id="p-size-anim-speed" min="0" max="10" step="0.5" value="3" style="width: 100%;">
                </div>
                
                <!-- Opacity -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Opacity</span>
                        <span id="p-opacity-value">0.7</span>
                    </label>
                    <input type="range" id="p-opacity" min="0" max="1" step="0.1" value="0.7" style="width: 100%;">
                </div>
                
                <!-- Opacity Random -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-opacity-random" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Random Opacity</span>
                    </label>
                </div>
                
                <!-- Opacity Animation -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-opacity-anim" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Animate Opacity</span>
                    </label>
                </div>
            </div>
            
            <!-- LINE LINKED SECTION -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 12px; color: rgba(255, 255, 255, 0.8); margin-bottom: 15px; font-weight: 700; border-bottom: 1px solid rgba(128, 128, 128, 0.3); padding-bottom: 8px;">LINES / CONNECTIONS</div>
                
                <!-- Enable Lines -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-line-enable" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Enable Lines</span>
                    </label>
                </div>
                
                <!-- Line Color -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Line Color</label>
                    <input type="color" id="p-line-color" value="#ffffff" style="width: 100%; height: 35px; border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; background: rgba(0, 0, 0, 0.3); cursor: pointer;">
                </div>
                
                <!-- Line Distance -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Distance</span>
                        <span id="p-line-distance-value">150</span>
                    </label>
                    <input type="range" id="p-line-distance" min="50" max="400" step="10" value="150" style="width: 100%;">
                </div>
                
                <!-- Line Opacity -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Line Opacity</span>
                        <span id="p-line-opacity-value">0.4</span>
                    </label>
                    <input type="range" id="p-line-opacity" min="0" max="1" step="0.05" value="0.4" style="width: 100%;">
                </div>
                
                <!-- Line Width -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Line Width</span>
                        <span id="p-line-width-value">1</span>
                    </label>
                    <input type="range" id="p-line-width" min="0.5" max="5" step="0.5" value="1" style="width: 100%;">
                </div>
            </div>
            
            <!-- MOVEMENT SECTION -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 12px; color: rgba(255, 255, 255, 0.8); margin-bottom: 15px; font-weight: 700; border-bottom: 1px solid rgba(128, 128, 128, 0.3); padding-bottom: 8px;">MOVEMENT</div>
                
                <!-- Enable Movement -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-move-enable" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Enable Movement</span>
                    </label>
                </div>
                
                <!-- Speed -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Speed</span>
                        <span id="p-move-speed-value">6</span>
                    </label>
                    <input type="range" id="p-move-speed" min="0" max="20" step="0.5" value="6" style="width: 100%;">
                </div>
                
                <!-- Direction -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Direction</label>
                    <select id="p-move-direction" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 11px; cursor: pointer;">
                        <option value="none">None</option>
                        <option value="top">Top</option>
                        <option value="top-right">Top Right</option>
                        <option value="right">Right</option>
                        <option value="bottom-right">Bottom Right</option>
                        <option value="bottom">Bottom</option>
                        <option value="bottom-left">Bottom Left</option>
                        <option value="left">Left</option>
                        <option value="top-left">Top Left</option>
                    </select>
                </div>
                
                <!-- Random Movement -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-move-random" style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Random Movement</span>
                    </label>
                </div>
                
                <!-- Straight Lines -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-move-straight" style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Straight Lines</span>
                    </label>
                </div>
                
                <!-- Out Mode -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Out Mode</label>
                    <select id="p-move-out-mode" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 11px; cursor: pointer;">
                        <option value="out">Out</option>
                        <option value="bounce">Bounce</option>
                    </select>
                </div>
                
                <!-- Bounce -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-move-bounce" style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Bounce</span>
                    </label>
                </div>
            </div>
            
            <!-- INTERACTIVITY SECTION -->
            <div style="margin-bottom: 20px;">
                <div class="info-label" style="font-size: 12px; color: rgba(255, 255, 255, 0.8); margin-bottom: 15px; font-weight: 700; border-bottom: 1px solid rgba(128, 128, 128, 0.3); padding-bottom: 8px;">INTERACTIVITY</div>
                
                <!-- Hover Mode -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-hover-enable" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Enable Hover</span>
                    </label>
                </div>
                
                <!-- Hover Mode Type -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Hover Mode</label>
                    <select id="p-hover-mode" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 11px; cursor: pointer;">
                        <option value="grab">Grab</option>
                        <option value="bubble">Bubble</option>
                        <option value="repulse">Repulse</option>
                    </select>
                </div>
                
                <!-- Click Mode -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="p-click-enable" checked style="width: 16px; height: 16px; cursor: pointer;">
                        <span style="font-size: 10px; color: rgba(255, 255, 255, 0.5);">Enable Click</span>
                    </label>
                </div>
                
                <!-- Click Mode Type -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Click Mode</label>
                    <select id="p-click-mode" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif; font-size: 11px; cursor: pointer;">
                        <option value="push">Push</option>
                        <option value="remove">Remove</option>
                        <option value="bubble">Bubble</option>
                        <option value="repulse">Repulse</option>
                    </select>
                </div>
                
                <!-- Repulse Distance -->
                <div style="margin-bottom: 15px;">
                    <label style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">
                        <span>Repulse Distance</span>
                        <span id="p-repulse-distance-value">200</span>
                    </label>
                    <input type="range" id="p-repulse-distance" min="50" max="500" step="10" value="200" style="width: 100%;">
                </div>
            </div>
            
            <!-- Reset Button -->
            <button id="particle-reset-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.4); border: 1px solid rgba(128, 128, 128, 0.6); border-radius: 6px; color: #fff; cursor: pointer; font-size: 11px; font-weight: 600; font-family: 'Orbitron', sans-serif;">
                RESET TO DEFAULTS
            </button>
            
        </div>
        <!-- Resize Handle -->
        <div id="particle-resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; background: linear-gradient(135deg, transparent 50%, rgba(128, 128, 128, 0.5) 50%); border-bottom-right-radius: 16px;"></div>
    </div>

    <!-- Cube Face Control Panel -->
    <div id="cube-face-panel" class="panel" style="display: none; position: fixed; left: 100px; top: 120px; width: 380px; max-height: 600px; overflow-y: auto; background: rgba(25, 25, 30, 0.95); backdrop-filter: blur(20px); border: 2px solid rgba(0, 102, 255, 0.5); border-radius: 16px; box-shadow: 0 8px 32px rgba(0, 102, 255, 0.3); z-index: 1050;">
        <div class="panel-header" id="cube-face-panel-header" style="display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; background: rgba(0, 102, 255, 0.15); border-bottom: 1px solid rgba(0, 102, 255, 0.3); cursor: move;">
            <span style="font-size: 14px; font-weight: 700; letter-spacing: 0.5px; color: #fff;"> <span id="cube-face-title">CUBE FACE</span></span>
            <div style="display: flex; gap: 8px;">
                <button class="panel-btn" id="cube-face-dock-btn" title="Auto Dock"></button>
                <button class="panel-btn" id="cube-face-minimize-btn"></button>
                <button class="panel-btn close-btn" id="cube-face-close-btn"></button>
            </div>
        </div>
        <div class="panel-content" id="cube-face-panel-content" style="padding: 16px;">
            
            <!-- Cube Rotation Control -->
            <div style="margin-bottom: 20px; padding: 12px; background: rgba(0, 102, 255, 0.1); border: 1px solid rgba(0, 102, 255, 0.3); border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <span style="font-size: 12px; font-weight: 600; color: rgba(255, 255, 255, 0.9);">Cube Rotation</span>
                    <button id="cube-rotation-toggle" class="active" style="padding: 6px 12px; background: rgba(0, 255, 0, 0.3); border: 1px solid rgba(0, 255, 0, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 10px; font-weight: 600;"> ROTATING</button>
                </div>
                <div style="font-size: 10px; color: rgba(255, 255, 255, 0.6);">
                    Click to pause/resume cube rotation
                </div>
            </div>
            
            <!-- Face-Specific Content Container -->
            <div id="cube-face-content">
                <!-- Content will be dynamically loaded based on clicked face -->
            </div>
            
        </div>
        <div class="resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize;"></div>
    </div>

    <!-- Object Data View Panel -->
    <div id="view-panel" style="display: none; position: fixed; left: 360px; top: 135px; width: 400px; max-height: calc(100vh - 400px); overflow-y: auto; background: rgba(25, 25, 30, 0.95); backdrop-filter: blur(20px); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 16px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); color: #fff; z-index: 1000;">
        <div id="view-panel-header" style="display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; background: rgba(128, 128, 128, 0.15); border-bottom: 1px solid rgba(128, 128, 128, 0.3); cursor: move; user-select: none; border-top-left-radius: 16px; border-top-right-radius: 16px;">
            <span style="font-size: 14px; font-weight: 600; letter-spacing: 0.5px;">OBJECT DATA VIEW</span>
            <button id="view-panel-close" style="width: 24px; height: 24px; border-radius: 50%; background: rgba(255, 0, 0, 0.2); border: 1px solid rgba(255, 0, 0, 0.5); color: #fff; cursor: pointer; font-size: 18px; line-height: 1;"></button>
        </div>
        
        <div style="padding: 16px;">
        <!-- Header -->
        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div style="font-size: 11px; color: rgba(255, 255, 255, 0.6); font-weight: 600;">HEADER</div>
                <button class="copy-btn" data-copy="header" style="padding: 4px 8px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 4px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 9px; font-weight: 600;"> COPY</button>
            </div>
            <div id="view-header" style="padding: 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 13px; word-wrap: break-word; min-height: 40px;">
                
            </div>
        </div>
        
        <!-- Body -->
        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div style="font-size: 11px; color: rgba(255, 255, 255, 0.6); font-weight: 600;">BODY</div>
                <button class="copy-btn" data-copy="body" style="padding: 4px 8px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 4px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 9px; font-weight: 600;"> COPY</button>
            </div>
            <div id="view-body" style="padding: 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 12px; white-space: pre-wrap; word-wrap: break-word; min-height: 120px; max-height: 300px; overflow-y: auto;">
                
            </div>
        </div>
        
        <!-- Footer -->
        <div style="margin-bottom: 0;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <div style="font-size: 11px; color: rgba(255, 255, 255, 0.6); font-weight: 600;">FOOTER</div>
                <button class="copy-btn" data-copy="footer" style="padding: 4px 8px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 4px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 9px; font-weight: 600;"> COPY</button>
            </div>
            <div id="view-footer" style="padding: 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.3); border-radius: 8px; font-family: 'Orbitron', sans-serif; font-size: 13px; word-wrap: break-word; min-height: 40px;">
                
            </div>
        </div>
        </div>
        
        <!-- Resize Handle -->
        <div id="view-panel-resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize; background: linear-gradient(135deg, transparent 50%, rgba(128, 128, 128, 0.5) 50%); border-bottom-right-radius: 16px;"></div>
    </div>

    <!-- MySpace Grid Panel -->
    <div id="myspace-grid-panel" class="side-menu" style="display: none; right: 120px; top: 80px; width: 350px; max-height: 600px; overflow-y: auto;">
        <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <span class="panel-title" style="font-size: 18px; font-weight: 700;">- MYSPACE GRID</span>
            <button class="panel-btn close-btn" id="myspace-grid-close" style="background: none; border: none; color: #fff; font-size: 24px; cursor: pointer;"></button>
        </div>
        
        <div style="margin-bottom: 25px;">
            <div style="font-weight: 600; margin-bottom: 15px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Grid Type</div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                <button class="myspace-grid-btn active" data-grid-type="spherical" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.3s;">
                     SPHERICAL
                </button>
                <button class="myspace-grid-btn" data-grid-type="planar" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.3s;">
                     PLANAR WALLS
                </button>
                <button class="myspace-grid-btn" data-grid-type="helix" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.3s;">
                     HELIX
                </button>
                <button class="myspace-grid-btn" data-grid-type="cube" style="padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600; transition: all 0.3s;">
                     CUBE
                </button>
            </div>
        </div>
        
        <!-- Grid Settings -->
        <div style="margin-bottom: 20px;">
            <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Grid Size</div>
            <input type="range" id="grid-size-slider" min="5" max="25" value="15" style="width: 100%; cursor: pointer; margin-bottom: 8px;">
            <div style="display: flex; justify-content: space-between; font-size: 11px; color: rgba(255, 255, 255, 0.7);">
                <span>Small (5)</span>
                <span id="grid-size-value">15</span>
                <span>Large (25)</span>
            </div>
        </div>
        
        <div style="margin-bottom: 20px;">
            <div style="font-weight: 600; margin-bottom: 10px; font-size: 14px; color: rgba(255, 255, 255, 0.9);">Grid Spacing</div>
            <input type="range" id="grid-spacing-slider" min="1" max="5" value="2" step="0.5" style="width: 100%; cursor: pointer; margin-bottom: 8px;">
            <div style="display: flex; justify-content: space-between; font-size: 11px; color: rgba(255, 255, 255, 0.7);">
                <span>Tight (1)</span>
                <span id="grid-spacing-value">2</span>
                <span>Wide (5)</span>
            </div>
        </div>
        
        <button id="apply-grid-btn" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.4); border: 1px solid rgba(128, 128, 128, 0.6); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; transition: all 0.3s;">
             APPLY CHANGES
        </button>
    </div>

    <!-- OmniSense Controls Panel -->
    <div id="omnisense-panel" class="panel minimized" style="display: none; position: fixed; left: 20px; bottom: 20px; width: 500px; height: 60px; background: rgba(25, 25, 30, 0.95); backdrop-filter: blur(20px); border: 2px solid rgba(0, 102, 255, 0.5); border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 102, 255, 0.3); z-index: 1050; transition: all 0.3s; overflow: hidden;">
        <div class="panel-header" id="omnisense-panel-header" style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(0, 102, 255, 0.15); border-bottom: 1px solid rgba(0, 102, 255, 0.3); cursor: move;">
            <span style="font-size: 12px; font-weight: 700; letter-spacing: 0.5px; color: #fff;"> OMNISENSE</span>
            <div style="display: flex; gap: 6px;">
                <button class="panel-btn" id="omnisense-minimize-btn">_</button>
                <button class="panel-btn close-btn" id="omnisense-close-btn"></button>
            </div>
        </div>
        <div class="panel-content" id="omnisense-panel-content" style="padding: 12px; display: none;">
            
            <!-- Tools Header Area -->
            <div style="background: rgba(0, 102, 255, 0.1); border: 1px solid rgba(0, 102, 255, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                
                <!-- Camera Height Slider -->
                <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <span style="font-size: 11px; font-weight: 600; color: rgba(255, 255, 255, 0.9);">Camera Height</span>
                        <span id="omnisense-height-value" style="font-family: 'Courier New', monospace; font-size: 11px; color: rgba(255, 255, 255, 0.7);">200</span>
                    </div>
                    <input type="range" id="omnisense-height-slider" min="0" max="600" value="200" step="10" style="width: 100%;">
                    <div style="display: flex; justify-content: space-between; font-size: 9px; color: rgba(255, 255, 255, 0.5); margin-top: 4px;">
                        <span>Close (0)</span>
                        <span>Multiple Realities (600)</span>
                    </div>
                </div>
                
                <!-- Grid Opacity Slider -->
                <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <span style="font-size: 11px; font-weight: 600; color: rgba(255, 255, 255, 0.9);">Grid Brightness</span>
                        <span id="omnisense-grid-opacity-value" style="font-family: 'Courier New', monospace; font-size: 11px; color: rgba(255, 255, 255, 0.7);">60%</span>
                    </div>
                    <input type="range" id="omnisense-grid-opacity-slider" min="0" max="100" value="60" step="5" style="width: 100%;">
                </div>
                
                <!-- Cube Rotation Speed -->
                <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                        <span style="font-size: 11px; font-weight: 600; color: rgba(255, 255, 255, 0.9);">Cube Rotation Speed</span>
                        <span id="omnisense-rotation-speed-value" style="font-family: 'Courier New', monospace; font-size: 11px; color: rgba(255, 255, 255, 0.7);">1.0</span>
                    </div>
                    <input type="range" id="omnisense-rotation-speed-slider" min="0" max="10" value="1" step="0.1" style="width: 100%;">
                </div>
                
                <!-- Tool Buttons -->
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button id="omnisense-save-state" class="update-btn" style="flex: 1; padding: 8px; font-size: 10px;"> SAVE</button>
                    <button id="omnisense-load-state" class="update-btn" style="flex: 1; padding: 8px; font-size: 10px;"> LOAD</button>
                    <button id="omnisense-reset" class="update-btn" style="flex: 1; padding: 8px; font-size: 10px;"> RESET</button>
                </div>
            </div>
            
            <!-- Grid Body Area -->
            <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 102, 255, 0.3); border-radius: 8px; padding: 12px; min-height: 200px; max-height: 400px; overflow: auto;">
                <div style="font-size: 10px; color: rgba(255, 255, 255, 0.5); margin-bottom: 12px; text-align: center;">
                    Grid Visualization Matching Space
                </div>
                
                <!-- Grid Canvas -->
                <canvas id="omnisense-grid-canvas" width="400" height="300" style="width: 100%; border: 1px solid rgba(0, 102, 255, 0.2); border-radius: 4px; background: rgba(0, 0, 0, 0.5);"></canvas>
                
                <!-- Grid Info -->
                <div style="margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; font-size: 10px;">
                    <div style="background: rgba(0, 102, 255, 0.1); padding: 8px; border-radius: 4px; border: 1px solid rgba(0, 102, 255, 0.2);">
                        <div style="color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Grid Size</div>
                        <div id="grid-info-size" style="color: rgba(255, 255, 255, 0.9); font-family: 'Courier New', monospace;">2500</div>
                    </div>
                    <div style="background: rgba(0, 102, 255, 0.1); padding: 8px; border-radius: 4px; border: 1px solid rgba(0, 102, 255, 0.2);">
                        <div style="color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Divisions</div>
                        <div id="grid-info-divisions" style="color: rgba(255, 255, 255, 0.9); font-family: 'Courier New', monospace;">100</div>
                    </div>
                    <div style="background: rgba(0, 102, 255, 0.1); padding: 8px; border-radius: 4px; border: 1px solid rgba(0, 102, 255, 0.2);">
                        <div style="color: rgba(255, 255, 255, 0.5); margin-bottom: 4px;">Focus</div>
                        <div id="grid-info-focus" style="color: rgba(255, 255, 255, 0.9); font-family: 'Courier New', monospace;">0,0,0</div>
                    </div>
                </div>
            </div>
            
        </div>
        <div class="resize-handle" style="position: absolute; bottom: 0; right: 0; width: 20px; height: 20px; cursor: nwse-resize;"></div>
    </div>

    <!-- Mobile Movement Control -->
    <div id="movement-control">
        <div class="joystick-base">
            <div class="joystick-stick" id="joystick-stick"></div>
            <!-- Directional buttons for mobile -->
            <button class="joystick-dir-btn" id="joy-btn-north" style="position: absolute; top: 5px; left: 50%; transform: translateX(-50%); width: 35px; height: 35px; background: rgba(128, 128, 128, 0.5); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 50%; color: #fff; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"></button>
            <button class="joystick-dir-btn" id="joy-btn-south" style="position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%); width: 35px; height: 35px; background: rgba(128, 128, 128, 0.5); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 50%; color: #fff; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"></button>
            <button class="joystick-dir-btn" id="joy-btn-west" style="position: absolute; left: 5px; top: 50%; transform: translateY(-50%); width: 35px; height: 35px; background: rgba(128, 128, 128, 0.5); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 50%; color: #fff; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"></button>
            <button class="joystick-dir-btn" id="joy-btn-east" style="position: absolute; right: 5px; top: 50%; transform: translateY(-50%); width: 35px; height: 35px; background: rgba(128, 128, 128, 0.5); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 50%; color: #fff; font-size: 18px; cursor: pointer; display: flex; align-items: center; justify-content: center;"></button>
        </div>
        <div class="control-buttons">
            <!-- Column 1: Vertical Movement -->
            <button class="control-btn vertical-btn" id="btn-up" title="Move Up (R)"></button>
            <button class="control-btn vertical-btn" id="btn-down" title="Move Down (F)"></button>
            <button class="control-btn vertical-btn" id="btn-center" title="Reset Camera (O)"></button>
            
            <!-- Column 2: Transform Controls -->
            <button class="control-btn" id="btn-pos" title="Position">POS</button>
            <button class="control-btn" id="btn-rot" title="Rotation">ROT</button>
            <button class="control-btn" id="btn-scale" title="Scale">SCL</button>
            
            <!-- Column 3: Hand Menus -->
            <button class="control-btn" id="btn-lh" title="Left Hand">LH</button>
            <button class="control-btn" id="btn-rh" title="Right Hand">RH</button>
            <button class="control-btn" id="btn-ch" title="Conscious Hand">CH</button>
            
            <!-- Column 4: UI Toggles -->
            <button class="control-btn" id="btn-docks" title="Docks">DO</button>
            <button class="control-btn" id="btn-keyboard" title="Keyboard">KB</button>
            <button class="control-btn" id="btn-action-grid" title="Action Grid">GKB</button>
            
            <!-- Column 5: Tray & Future Buttons -->
            <button class="control-btn" id="btn-tray" title="Toggle Tray">TRAY</button>
            <button class="control-btn" id="btn-chat" title="Toggle Chat">CHAT</button>
            <button class="control-btn" id="btn-orbit" title="Orbit Controls">ORBT</button>
            
            <!-- Column 6: Additional Controls -->
            <button class="control-btn" id="btn-nav" title="Toggle Navigation Bar">NAV</button>
            <button class="control-btn" id="btn-rulers" title="Toggle Rulers">RUL</button>
            <button class="control-btn" id="btn-keys" title="mniKeyboard (N)">KEYS</button>
            <button class="control-btn" id="btn-sense" title="OmniSense Mode (L)">SENSE</button>
            <button class="control-btn" id="btn-menu" title="Toggle Menu"></button>
        </div>
    </div>

    <!-- Right Hand Movement Control -->
    <div id="rh-movement-control" style="display: none;">
        <div class="joystick-base">
            <div class="joystick-stick" id="rh-joystick-stick"></div>
        </div>
    </div>

    <!-- Conscious Hand Movement Control -->
    <div id="ch-movement-control" style="display: none;">
        <div class="joystick-base">
            <div class="joystick-stick" id="ch-joystick-stick"></div>
        </div>
    </div>

    <!-- RH Tool Settings Panel (replaces movement pad) -->
    <div id="rh-tool-settings" style="display: none; position: fixed; bottom: 20px; right: 20px; width: 200px; background: rgba(25, 25, 30, 0.95); backdrop-filter: blur(30px); border: 2px solid rgba(128, 128, 128, 0.4); border-radius: 12px; padding: 15px; z-index: 1000;">
        <div style="font-size: 12px; font-weight: 700; color: #fff; text-align: center; margin-bottom: 10px; letter-spacing: 1px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);">TOOL SETTINGS</div>
        <div id="rh-tool-settings-content" style="font-size: 11px; color: rgba(255, 255, 255, 0.8);">
            No tool selected
        </div>
    </div>

    <!-- Position Rulers -->
    <div id="x-axis-ruler" style="display: none; position: fixed; bottom: 20px; right: 20px; width: 300px; height: 30px; background: rgba(255, 255, 255, 0.15); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 8px; align-items: center; justify-content: space-between; padding: 0 10px; font-family: 'Courier New', monospace; font-size: 10px; color: #fff; z-index: 900;">
        <span style="color: rgba(255, 255, 255, 0.8);">-50</span>
        <div style="flex: 1; height: 2px; background: linear-gradient(90deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.3)); margin: 0 10px; position: relative; box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);">
            <div id="x-marker" style="position: absolute; width: 3px; height: 10px; background: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 25px rgba(255, 255, 255, 0.5); left: 50%; transform: translateX(-50%); top: -4px; border-radius: 2px;"></div>
        </div>
        <span style="color: rgba(255, 255, 255, 0.8);">+50</span>
        <span style="margin-left: 10px; color: #fff; font-weight: 700; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">X</span>
    </div>
    
    <div id="z-axis-ruler" style="display: none; position: fixed; right: 20px; top: 160px; width: 30px; height: 300px; background: rgba(255, 255, 255, 0.15); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 8px; flex-direction: column; align-items: center; justify-content: space-between; padding: 10px 0; font-family: 'Courier New', monospace; font-size: 10px; color: #fff; z-index: 900;">
        <span style="color: rgba(255, 255, 255, 0.8);">+50</span>
        <div style="flex: 1; width: 2px; background: linear-gradient(180deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.3)); margin: 10px 0; position: relative; box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);">
            <div id="z-marker" style="position: absolute; height: 3px; width: 10px; background: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 25px rgba(255, 255, 255, 0.5); top: 50%; left: 50%; transform: translate(-50%, -50%); border-radius: 2px;"></div>
        </div>
        <span style="color: rgba(255, 255, 255, 0.8);">-50</span>
        <div style="margin-top: 10px; color: #fff; font-weight: 700; writing-mode: vertical-rl; transform: rotate(180deg); text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">Z</div>
    </div>
    
    <div id="y-axis-ruler" style="display: none; position: fixed; left: 20px; top: 160px; width: 30px; height: 300px; background: rgba(255, 255, 255, 0.15); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 8px; flex-direction: column; align-items: center; justify-content: space-between; padding: 10px 0; font-family: 'Courier New', monospace; font-size: 10px; color: #fff; z-index: 900;">
        <span style="color: rgba(255, 255, 255, 0.8);">+50</span>
        <div style="flex: 1; width: 2px; background: linear-gradient(180deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.3)); margin: 10px 0; position: relative; box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);">
            <div id="y-marker" style="position: absolute; height: 3px; width: 10px; background: #fff; box-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 25px rgba(255, 255, 255, 0.5); top: 50%; left: 50%; transform: translate(-50%, -50%); border-radius: 2px;"></div>
        </div>
        <span style="color: rgba(255, 255, 255, 0.8);">-50</span>
        <div style="margin-top: 10px; color: #fff; font-weight: 700; writing-mode: vertical-rl; transform: rotate(180deg); text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.5);">Y</div>
    </div>

    <!-- JSON Viewer Panel -->
    <div id="json-viewer-panel" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80vw; max-width: 800px; height: 70vh; background: rgba(25, 25, 30, 0.98); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 12px; z-index: 5000; backdrop-filter: blur(20px); box-shadow: 0 0 40px rgba(0, 0, 0, 0.8), 0 0 80px rgba(255, 255, 255, 0.2); resize: both; overflow: hidden; min-width: 400px; min-height: 300px;">
        <!-- Header -->
        <div id="json-viewer-header" style="padding: 16px; border-bottom: 1px solid rgba(128, 128, 128, 0.3); display: flex; justify-content: space-between; align-items: center; gap: 12px; cursor: move; user-select: none;">
            <div style="font-family: 'Orbitron', sans-serif; font-size: 14px; font-weight: 700; color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);"> DATA VIEWER</div>
            
            <!-- Transparency Control -->
            <div style="display: flex; align-items: center; gap: 8px; flex: 1; max-width: 300px;">
                <span style="font-size: 10px; color: rgba(255, 255, 255, 0.6); white-space: nowrap;">Opacity:</span>
                <input type="range" id="json-viewer-opacity" min="0.3" max="1" step="0.1" value="0.98" style="flex: 1; height: 4px; background: rgba(128, 128, 128, 0.3); border-radius: 2px; outline: none;">
                <span id="json-viewer-opacity-value" style="font-size: 10px; color: rgba(255, 255, 255, 0.6); min-width: 30px;">98%</span>
            </div>
            
            <div style="display: flex; gap: 8px;">
                <button id="toggle-3d-viewer" style="padding: 6px 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 10px; font-weight: 600;">3D VIEW</button>
                <button id="minimize-json-viewer" style="width: 32px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;"></button>
                <button id="close-json-viewer" style="width: 32px; height: 32px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center;"></button>
            </div>
        </div>
        
        <!-- Scroll Controls -->
        <div style="position: absolute; right: 16px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 8px; z-index: 1;">
            <button id="json-scroll-up" style="width: 40px; height: 40px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center;"></button>
            <button id="json-scroll-down" style="width: 40px; height: 40px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center;"></button>
        </div>
        
        <!-- Content Area -->
        <div id="json-viewer-content" style="padding: 20px; height: calc(100% - 64px); overflow-y: auto; font-family: 'Courier New', monospace; font-size: 12px; color: #fff; line-height: 1.6;">
            <pre id="json-viewer-pre" style="margin: 0; white-space: pre-wrap; word-wrap: break-word;"></pre>
        </div>
    </div>
    
    <!-- Minimized JSON Viewer Tab -->
    <div id="json-viewer-minimized" style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: rgba(25, 25, 30, 0.95); border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px; cursor: pointer; backdrop-filter: blur(20px); z-index: 5000;">
        <span style="font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600; color: #fff;"> DATA VIEWER (minimized)</span>
    </div>

    <!-- 3D Panel Control Panel -->
    <div id="panel-3d-controls" style="display: none; position: fixed; right: 20px; top: 50%; transform: translateY(-50%); width: 280px; background: rgba(25, 25, 30, 0.95); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 12px; backdrop-filter: blur(20px); z-index: 4500; box-shadow: 0 0 40px rgba(0, 0, 0, 0.8), 0 0 80px rgba(255, 255, 255, 0.2);">
        <!-- Header -->
        <div id="panel-3d-header" style="padding: 12px; border-bottom: 1px solid rgba(128, 128, 128, 0.3); display: flex; justify-content: space-between; align-items: center; cursor: move; user-select: none;">
            <span style="font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 700; color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);"> 3D PANEL CONTROLS</span>
            <button id="close-3d-controls" style="width: 28px; height: 28px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"></button>
        </div>
        
        <!-- Content -->
        <div style="padding: 16px; max-height: 70vh; overflow-y: auto;">
            <!-- Position Controls -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);">POSITION</div>
                <div style="display: grid; grid-template-columns: 20px 1fr; gap: 8px; align-items: center;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">X</span>
                    <input type="range" id="panel-3d-pos-x" min="-15" max="15" step="0.5" value="0" style="width: 100%;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">Y</span>
                    <input type="range" id="panel-3d-pos-y" min="-15" max="15" step="0.5" value="0" style="width: 100%;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">Z</span>
                    <input type="range" id="panel-3d-pos-z" min="-15" max="15" step="0.5" value="0" style="width: 100%;">
                </div>
            </div>
            
            <!-- Rotation Controls -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);">ROTATION</div>
                <div style="display: grid; grid-template-columns: 20px 1fr; gap: 8px; align-items: center;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">X</span>
                    <input type="range" id="panel-3d-rot-x" min="0" max="360" step="1" value="0" style="width: 100%;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">Y</span>
                    <input type="range" id="panel-3d-rot-y" min="0" max="360" step="1" value="0" style="width: 100%;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">Z</span>
                    <input type="range" id="panel-3d-rot-z" min="0" max="360" step="1" value="0" style="width: 100%;">
                </div>
            </div>
            
            <!-- Scale Controls -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);">SCALE</div>
                <div style="display: grid; grid-template-columns: 20px 1fr; gap: 8px; align-items: center;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">X</span>
                    <input type="range" id="panel-3d-sca-x" min="0.5" max="3" step="0.1" value="1" style="width: 100%;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">Y</span>
                    <input type="range" id="panel-3d-sca-y" min="0.5" max="3" step="0.1" value="2" style="width: 100%;">
                    <span style="font-size: 9px; color: rgba(255, 255, 255, 0.7);">Z</span>
                    <input type="range" id="panel-3d-sca-z" min="0.5" max="3" step="0.1" value="1" style="width: 100%;">
                </div>
            </div>
            
            <!-- Color Control -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);">PANEL COLOR</div>
                <input type="color" id="panel-3d-color" value="#191920" style="width: 100%; height: 40px; border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; background: rgba(0, 0, 0, 0.3); cursor: pointer;">
            </div>
            
            <!-- Opacity Control -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);">OPACITY</div>
                <input type="range" id="panel-3d-opacity" min="0.1" max="1" step="0.1" value="0.95" style="width: 100%;">
                <span id="panel-3d-opacity-value" style="font-size: 9px; color: rgba(255, 255, 255, 0.6);">95%</span>
            </div>
            
            <!-- Put in Pocket Button -->
            <button id="put-panel-in-pocket" style="width: 100%; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600;">
                 PUT IN POCKET
            </button>
        </div>
    </div>

    <!-- 3D Panel Control Panel -->
    <div id="panel-3d-controls" style="display: none; position: fixed; right: 20px; top: 50%; transform: translateY(-50%); width: 280px; background: rgba(25, 25, 30, 0.95); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 12px; z-index: 5000; backdrop-filter: blur(20px); box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);">
        <!-- Header (draggable) -->
        <div id="panel-3d-header" style="padding: 12px 16px; border-bottom: 1px solid rgba(128, 128, 128, 0.3); display: flex; justify-content: space-between; align-items: center; cursor: move; user-select: none; background: rgba(128, 128, 128, 0.2);">
            <div style="font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 700; color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);"> 3D PANEL CONTROLS</div>
            <button id="close-3d-controls" style="width: 24px; height: 24px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 4px; color: #fff; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"></button>
        </div>
        
        <!-- Content -->
        <div style="padding: 16px; max-height: 600px; overflow-y: auto;">
            <!-- Position Controls -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);">POSITION</div>
                <div style="display: grid; grid-template-columns: 30px 1fr; gap: 8px; align-items: center;">
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">X:</span>
                    <input type="range" id="panel-3d-pos-x" min="-20" max="20" step="0.5" value="0" style="width: 100%;">
                    
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">Y:</span>
                    <input type="range" id="panel-3d-pos-y" min="-20" max="20" step="0.5" value="0" style="width: 100%;">
                    
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">Z:</span>
                    <input type="range" id="panel-3d-pos-z" min="-20" max="20" step="0.5" value="0" style="width: 100%;">
                </div>
            </div>
            
            <!-- Rotation Controls -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);">ROTATION</div>
                <div style="display: grid; grid-template-columns: 30px 1fr; gap: 8px; align-items: center;">
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">X:</span>
                    <input type="range" id="panel-3d-rot-x" min="-3.14" max="3.14" step="0.1" value="0" style="width: 100%;">
                    
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">Y:</span>
                    <input type="range" id="panel-3d-rot-y" min="-3.14" max="3.14" step="0.1" value="0" style="width: 100%;">
                    
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">Z:</span>
                    <input type="range" id="panel-3d-rot-z" min="-3.14" max="3.14" step="0.1" value="0" style="width: 100%;">
                </div>
            </div>
            
            <!-- Scale Controls -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);">SCALE</div>
                <div style="display: grid; grid-template-columns: 30px 1fr; gap: 8px; align-items: center;">
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">X:</span>
                    <input type="range" id="panel-3d-sca-x" min="0.1" max="3" step="0.1" value="1" style="width: 100%;">
                    
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">Y:</span>
                    <input type="range" id="panel-3d-sca-y" min="0.1" max="3" step="0.1" value="1" style="width: 100%;">
                    
                    <span style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">Z:</span>
                    <input type="range" id="panel-3d-sca-z" min="0.1" max="3" step="0.1" value="1" style="width: 100%;">
                </div>
            </div>
            
            <!-- Color Control -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);">PANEL COLOR</div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="color" id="panel-3d-color" value="#191919" style="width: 60px; height: 32px; border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 4px; cursor: pointer;">
                    <span id="panel-3d-color-value" style="font-size: 10px; color: rgba(255, 255, 255, 0.8); font-family: 'Courier New', monospace;">#191919</span>
                </div>
            </div>
            
            <!-- Opacity Control -->
            <div style="margin-bottom: 16px;">
                <div style="font-size: 10px; font-weight: 700; color: #fff; margin-bottom: 8px; text-shadow: 0 0 8px rgba(255, 255, 255, 0.6);">OPACITY</div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="range" id="panel-3d-opacity" min="0.3" max="1" step="0.05" value="0.95" style="flex: 1;">
                    <span id="panel-3d-opacity-value" style="font-size: 10px; color: rgba(255, 255, 255, 0.8); min-width: 35px;">95%</span>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div style="display: flex; flex-direction: column; gap: 8px;">
                <button id="reset-3d-panel" style="width: 100%; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600;"> RESET POSITION</button>
                
                <button id="save-to-pocket-3d" style="width: 100%; padding: 10px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600;"> SAVE TO POCKET</button>
                
                <button id="remove-3d-panel" style="width: 100%; padding: 10px; background: rgba(180, 80, 80, 0.3); border: 1px solid rgba(180, 80, 80, 0.5); border-radius: 6px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 11px; font-weight: 600;"> REMOVE PANEL</button>
            </div>
        </div>
    </div>

    <!-- Virtual Keyboard -->
    <div id="virtual-keyboard"></div>

    <!-- Transform Panel -->
    <div id="transform-panel">
        <div class="transform-header">
            <span class="panel-title" id="transform-title">POSITION</span>
            <button class="panel-btn close-btn" id="transform-close"></button>
        </div>
        <div class="transform-content">
            <div class="transform-row">
                <div class="transform-label">X</div>
                <div class="transform-inputs">
                    <input type="number" class="transform-input" id="transform-x" value="0" step="0.1">
                </div>
            </div>
            <div class="transform-row">
                <div class="transform-label">Y</div>
                <div class="transform-inputs">
                    <input type="number" class="transform-input" id="transform-y" value="0" step="0.1">
                </div>
            </div>
            <div class="transform-row">
                <div class="transform-label">Z</div>
                <div class="transform-inputs">
                    <input type="number" class="transform-input" id="transform-z" value="0" step="0.1">
                </div>
            </div>
            <div class="transform-row">
                <div class="transform-label">Step Size</div>
                <div class="step-control">
                    <span class="step-label">Range:</span>
                    <input type="number" class="step-input" id="step-size" value="1" min="-1000" max="1000">
                </div>
            </div>
            <div class="transform-submit-container">
                <button class="transform-submit-btn" id="transform-submit">Apply Changes</button>
            </div>
        </div>
    </div>

    <!-- Action Button Grid (30 buttons) -->
    <div id="action-grid" class="hidden">
        <button class="action-btn" data-action="1">A1</button>
        <button class="action-btn" data-action="2">A2</button>
        <button class="action-btn" data-action="3">A3</button>
        <button class="action-btn" data-action="4">A4</button>
        <button class="action-btn" data-action="5">A5</button>
        <button class="action-btn" data-action="6">A6</button>
        <button class="action-btn" data-action="7">A7</button>
        <button class="action-btn" data-action="8">A8</button>
        <button class="action-btn" data-action="9">A9</button>
        <button class="action-btn" data-action="10">A10</button>
        <button class="action-btn" data-action="11">A11</button>
        <button class="action-btn" data-action="12">A12</button>
        <button class="action-btn" data-action="13">A13</button>
        <button class="action-btn" data-action="14">A14</button>
        <button class="action-btn" data-action="15">A15</button>
        <button class="action-btn" data-action="16">A16</button>
        <button class="action-btn" data-action="17">A17</button>
        <button class="action-btn" data-action="18">A18</button>
        <button class="action-btn" data-action="19">A19</button>
        <button class="action-btn" data-action="20">A20</button>
        <button class="action-btn" data-action="21">A21</button>
        <button class="action-btn" data-action="22">A22</button>
        <button class="action-btn" data-action="23">A23</button>
        <button class="action-btn" data-action="24">A24</button>
        <button class="action-btn" data-action="25">A25</button>
        <button class="action-btn" data-action="26">A26</button>
        <button class="action-btn" data-action="27">A27</button>
        <button class="action-btn" data-action="28">A28</button>
        <button class="action-btn" data-action="29">A29</button>
        <button class="action-btn" data-action="30">A30</button>
    </div>

    <!-- THREE.js and GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>


    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <!-- Particles.js Library -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <!-- Main Script -->
    <script src="script.js"></script>

</body>
</html>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <!-- Particles.js Library -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer;
        let interactiveObjects = [];
        let journalPages = [];
        let gridObjects = [];
        let mySpaceGroup;  // Group to hold all MySpace grid panels
        let sphereRotateX = false;
        let sphereRotateY = false;
        let sphereRotateZ = false;
        let selectedObject = null;
        let hoveredObject = null;
        let isRotating = false;
        let previousMousePosition = { x: 0, y: 0 };
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const cameraTarget = new THREE.Vector3(0, 0, 0);

        // Keyboard controls
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            r: false,
            f: false,
            c: false,
            b: false,
            shift: false
        };

        // Mouse look controls - only active when holding C
        let lastMouseX = window.innerWidth / 2;
        let lastMouseY = window.innerHeight / 2;

        // Camera breathing effect (Metroid Prime style)
        let breathTime = 0;
        const breathSpeed = 0.8;
        const breathIntensity = 0.08; // Increased from 0.02 for more pronounced effect

        // Hand menus
        let leftHandVisible = false;
        let rightHandVisible = false;
        let consciousHandVisible = false;

        // MySpace (grid sphere) state
        let mySpaceExpanded = true;
        
        // OmniConduit Reality Node Network System
        let realityNodes = {};
        let omniConduits = [];
        let currentNode = null;
        let isTraversing = false;
        const NODE_SPACING = 150; // Distance between node centers
        const CONDUIT_RADIUS = 8; // Cylinder radius for all conduits
        
        // Particle Energy State variables
        let particleSystem = null;
        let particleCount = 3000;
        let particleVelocities = null;
        let gridHelper = null;
        let skyboxMesh = null;
        
        // Particle Control Settings
        let particleSize = 1.0;
        let particleColor = 0xffffff;
        let particleXRange = 100;
        let particleYRange = 100;
        let particleZRange = 100;
        let particleSpeed = 1.0;
        let particleOpacity = 0.8;
        
        // User Control Settings
        let moveSpeed = 0.2;
        let jumpSpeed = 1.0;
        let sprintMultiplier = 2.0;
        let userGravity = 0.5;
        let lookSensitivity = 0.002;
        let invertY = false;
        let godMode = false;
        
        // Particle Behavior State
        let particleBehaviorMode = 'calm'; // 'calm', 'forward', 'backward', 'connected', 'glitch', 'constellation'
        let forwardFlowSpeed = 0.2; // 0-1 range (default 20)
        let backwardFlowSpeed = 0.2; // 0-1 range (default 20)
        let upwardFlowSpeed = 0.2; // 0-1 range (default 20)
        let downwardFlowSpeed = 0.2; // 0-1 range (default 20)
        let connectionFrequency = 0.5; // 0-1 range for connected mode
        let glitchIntensity = 0.5; // 0-1 range for glitch mode
        let constellationDistance = 3.0; // Distance for constellation connections (scaled from slider)
        
        // FPS tracking
        let lastFrameTime = performance.now();
        let fps = 60;
        let fpsFrames = 0;
        let fpsTime = 0;
        let mySpaceAnimating = false;
        const expandedRadius = 25;
        const collapsedRadius = 5;

        // OmniSense Mode & Cube System
        let omniSenseMode = false;
        let omniSenseCube = null;
        let cubeEdges = null;
        let cubeFaces = [];
        let cubeRotating = false;
        let cubeRotationSpeed = 0.001;
        let cubePulseSpeed = 1.0;
        let cubeClickedFace = null;
        let normalCameraPosition = null;
        let normalCameraTarget = null;
        let omniSenseCameraHeight = 200;
        const cubeSize = 65;
        
        // Pocket system with pagination
        let pocketVisible = false;
        let pocketItems = {}; // Object to store pocket items with metadata
        const slotsPerPage = 20;
        const totalPages = 10;
        const maxPocketSlots = slotsPerPage * totalPages; // 200 total slots
        let currentPocketPage = 1;
        
        // Initialize pocket slots
        for (let i = 0; i < maxPocketSlots; i++) {
            pocketItems[i] = {
                occupied: false,
                deployed: false, // true if item is out in the scene
                itemData: null,
                password: null
            };
        }

        // Docks visibility
        let docksVisible = false; // Start hidden by default

        // Session timer
        let sessionStartTime = Date.now();
        let timerInterval = null;

        // mniKeyboard System
        let omniKeyboardVisible = false;
        let omniKeyboardGroup = null; // Group to hold all keyboard cubes
        let omniKeyboardCubes = []; // Array of cube meshes
        let omniKeyboardScale = 1.0; // Scale multiplier for accessibility
        let omniKeyboardCurrentRow = 0; // Current focused row (0-4 now with ESC/F-keys)
        let omniKeyboardCurrentCol = 0; // Current focused column
        let omniKeyboardDragging = false;
        let omniKeyboardDragStart = new THREE.Vector3();
        let omniKeyboardDragOffset = new THREE.Vector3();
        let omniKeyboardStillMode = false; // Still Mode: keyboard becomes typable
        const omniKeyboardRows = [
            { name: 'ESC/FN', keys: ['ESC', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12'] },
            { name: 'NUMBERS', keys: ['`', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '='] },
            { name: 'QWERTY', keys: ['TAB', 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '[', ']'] },
            { name: 'ASDFGH', keys: ['', 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', "'", ''] },
            { name: 'ZXCVBN', keys: ['LSH', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/', 'RSH'] },
            { name: 'ARROWS', keys: ['SPC', '', '', '', '', ''] }
        ];
        
        // OmniKeyboard transform state (relative to camera)
        let omniKeyboardOffsetX = 0;
        let omniKeyboardOffsetY = -1.50;
        let omniKeyboardOffsetZ = -8.60;
        let omniKeyboardRotationX = 0.90;
        let omniKeyboardRotationY = 0;
        let omniKeyboardRotationZ = 0;
        let omniKeyboardScaleUniform = 0.20;
        let omniKeyboardSpacing = 2.60; // Distance between keys
        let omniKeyboardRowSpacing = 3.20; // Distance between rows

        // Theme system
        const themes = {
            'silver': {
                name: 'Silver',
                primary: 'rgba(60, 60, 70, 0.8)',
                accent: '#C0C0C0',
                text: '#E8E8E8',
                dockBg: '#ffffff',
                dockText: '#333333',
                dockGlow: 'rgba(255, 255, 255, 0.6)',
                preview: 'linear-gradient(135deg, #3c3c46, #808080)'
            },
            'darkblue': {
                name: 'Dark Blue',
                primary: 'rgba(25, 25, 30, 0.7)',
                accent: '#808080',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#1a1a2e',
                dockGlow: 'rgba(128, 128, 128, 0.6)',
                preview: 'linear-gradient(135deg, #0f0f23, #808080)'
            },
            'orange': {
                name: 'Orange',
                primary: 'rgba(30, 20, 10, 0.7)',
                accent: '#FF8C00',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#1e140a',
                dockGlow: 'rgba(255, 140, 0, 0.6)',
                preview: 'linear-gradient(135deg, #FF6B00, #FFA500)'
            },
            'yellow': {
                name: 'Yellow',
                primary: 'rgba(40, 40, 20, 0.7)',
                accent: '#FFD700',
                text: '#333',
                dockBg: '#ffffff',
                dockText: '#282814',
                dockGlow: 'rgba(255, 215, 0, 0.6)',
                preview: 'linear-gradient(135deg, #FFC107, #FFD700)'
            },
            'red': {
                name: 'Red',
                primary: 'rgba(30, 10, 10, 0.7)',
                accent: '#DC143C',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#1e0a0a',
                dockGlow: 'rgba(220, 20, 60, 0.6)',
                preview: 'linear-gradient(135deg, #DC143C, #FF6B6B)'
            },
            'purple': {
                name: 'Purple',
                primary: 'rgba(20, 10, 30, 0.7)',
                accent: '#9370DB',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#140a1e',
                dockGlow: 'rgba(147, 112, 219, 0.6)',
                preview: 'linear-gradient(135deg, #6A0DAD, #9370DB)'
            },
            'teal': {
                name: 'Teal',
                primary: 'rgba(10, 25, 25, 0.7)',
                accent: '#20B2AA',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#0a1919',
                dockGlow: 'rgba(32, 178, 170, 0.6)',
                preview: 'linear-gradient(135deg, #008B8B, #20B2AA)'
            },
            'neonblue': {
                name: 'Neon Blue',
                primary: 'rgba(10, 10, 25, 0.7)',
                accent: '#00FFFF',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#0a0a19',
                dockGlow: 'rgba(0, 255, 255, 0.6)',
                preview: 'linear-gradient(135deg, #00CED1, #00FFFF)'
            },
            'magenta': {
                name: 'Magenta',
                primary: 'rgba(30, 10, 30, 0.7)',
                accent: '#FF00FF',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#1e0a1e',
                dockGlow: 'rgba(255, 0, 255, 0.6)',
                preview: 'linear-gradient(135deg, #C71585, #FF00FF)'
            },
            'rainbow': {
                name: 'Rainbow Static',
                primary: 'rgba(20, 20, 35, 0.75)',
                accent: '#FF00FF',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#141423',
                dockGlow: 'rgba(255, 0, 255, 0.6)',
                preview: 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)',
                isRainbow: true,
                animated: false
            },
            'rainbowFlow': {
                name: 'Rainbow Flow',
                primary: 'rgba(20, 20, 35, 0.75)',
                accent: '#FF00FF',
                text: '#fff',
                dockBg: '#ffffff',
                dockText: '#141423',
                dockGlow: 'rgba(255, 0, 255, 0.6)',
                preview: 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)',
                isRainbow: true,
                animated: true
            },
            'whiteBright': {
                name: 'White Bright',
                primary: 'rgba(255, 255, 255, 0.85)',
                accent: '#ffffff',
                text: '#333',
                dockBg: '#ffffff',
                dockText: '#333',
                dockGlow: 'rgba(255, 255, 255, 0.9)',
                preview: 'linear-gradient(135deg, #ffffff, #f0f0f0)'
            }
        };

        let currentTheme = 'silver';

        // Wisdom, jokes, and FYIs
        const wiseSayings = [
            "The journey of a thousand miles begins with a single step.",
            "It does not matter how slowly you go as long as you do not stop.",
            "The only way to do great work is to love what you do.",
            "Innovation distinguishes between a leader and a follower.",
            "Your time is limited, don't waste it living someone else's life.",
            "The best time to plant a tree was 20 years ago. The second best time is now.",
            "What lies behind us and what lies before us are tiny matters compared to what lies within us.",
            "Believe you can and you're halfway there.",
            "Do not wait for leaders; do it alone, person to person.",
            "The future belongs to those who believe in the beauty of their dreams."
        ];

        const funnyJokes = [
            "Why don't scientists trust atoms? Because they make up everything!",
            "Why did the scarecrow win an award? He was outstanding in his field!",
            "What do you call a bear with no teeth? A gummy bear!",
            "Why don't eggs tell jokes? They'd crack each other up!",
            "What do you call a fake noodle? An impasta!",
            "Why did the bicycle fall over? It was two tired!",
            "What did one wall say to the other? I'll meet you at the corner!",
            "Why don't skeletons fight each other? They don't have the guts!",
            "What's the best thing about Switzerland? I don't know, but the flag is a big plus!",
            "How does a penguin build its house? Igloos it together!"
        ];

        const randomFYIs = [
            "FYI: Honey never spoils. Archaeologists have found 3000-year-old honey that's still edible!",
            "FYI: Octopuses have three hearts and blue blood!",
            "FYI: A group of flamingos is called a 'flamboyance'!",
            "FYI: The shortest war in history lasted 38 minutes!",
            "FYI: Bananas are berries, but strawberries aren't!",
            "FYI: There are more stars in the universe than grains of sand on Earth!",
            "FYI: A single bolt of lightning contains enough energy to toast 100,000 slices of bread!",
            "FYI: The human brain uses 20% of the body's energy despite being only 2% of body weight!",
            "FYI: Venus is the only planet that rotates clockwise!",
            "FYI: A jiffy is an actual unit of time - 1/100th of a second!"
        ];

        function showWisdomPrompt() {
            document.getElementById('restart-prompt').classList.remove('visible');
            
            const allContent = [...wiseSayings, ...funnyJokes, ...randomFYIs];
            const randomContent = allContent[Math.floor(Math.random() * allContent.length)];
            
            document.getElementById('wisdom-text').textContent = randomContent;
            document.getElementById('wisdom-prompt').classList.add('visible');
            playSound('passive');
        }

        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) return;

            currentTheme = themeName;
            
            // Remove any existing rainbow animations
            document.querySelectorAll('.rainbow-animated, .rainbow-border, .rainbow-glow').forEach(el => {
                el.classList.remove('rainbow-animated', 'rainbow-border', 'rainbow-glow');
            });
            
            // Kill any existing rainbow GSAP animations
            if (window.rainbowTimeline) {
                window.rainbowTimeline.kill();
                window.rainbowTimeline = null;
            }
            
            // Kill all GSAP tweens on UI elements
            gsap.killTweensOf('.side-menu, #inspector-panel, #info-panel, #search-panel, .dock, .hamburger-btn, #faq-panel, .prompt-modal, .menu-item, .submenu-item, #transform-panel, .control-btn, .action-btn, #virtual-keyboard, .key-btn, .menu-title, .info-space-title, .breadcrumb-current, .controls-title, .prompt-title, .joystick-stick');
            
            // Reset CSS properties that GSAP may have modified
            document.querySelectorAll('.side-menu, #inspector-panel, #info-panel, #search-panel, .dock, .hamburger-btn, #faq-panel, .prompt-modal, .menu-item, .submenu-item, #transform-panel, .control-btn, .action-btn, #virtual-keyboard, .key-btn').forEach(el => {
                el.style.borderColor = '';
                el.style.backgroundPosition = '';
                el.style.backgroundSize = '';
            });
            
            document.querySelectorAll('.menu-title, .info-space-title, .breadcrumb-current, .controls-title, .prompt-title, .joystick-stick').forEach(el => {
                el.style.backgroundPosition = '';
                el.style.backgroundSize = '';
            });

            // Handle rainbow themes
            const isRainbow = theme.isRainbow;
            const isAnimated = theme.animated;
            
            // Update CSS variables or directly update elements
            const root = document.documentElement;
            root.style.setProperty('--theme-primary', theme.primary);
            root.style.setProperty('--theme-accent', theme.accent);
            root.style.setProperty('--theme-text', theme.text);

            // Update all panels (including header-bar and particle-behavior-panel)
            document.querySelectorAll('.side-menu, #inspector-panel, #header-bar, #search-panel, .dock, .hamburger-btn, #faq-panel, .prompt-modal, #transform-panel, #particle-behavior-panel').forEach(el => {
                el.style.background = theme.primary;
                el.style.backdropFilter = 'blur(20px)';
                el.style.color = theme.text;
                if (isRainbow && isAnimated) {
                    el.classList.add('rainbow-border');
                }
            });

            // Update accent colors with rainbow
            document.querySelectorAll('.menu-title, .info-space-title, .breadcrumb-current, .controls-title, .prompt-title').forEach(el => {
                if (isRainbow) {
                    el.style.background = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)';
                    el.style.backgroundClip = 'text';
                    el.style.webkitBackgroundClip = 'text';
                    el.style.webkitTextFillColor = 'transparent';
                    if (isAnimated) {
                        el.classList.add('rainbow-animated');
                    }
                } else {
                    el.style.color = theme.accent;
                    el.style.background = 'none';
                    el.style.backgroundClip = 'unset';
                    el.style.webkitBackgroundClip = 'unset';
                    el.style.webkitTextFillColor = 'unset';
                }
            });

            // Update borders
            document.querySelectorAll('.side-menu, #inspector-panel, #header-bar, #search-panel, .dock, .hamburger-btn, #faq-panel, .prompt-modal, .menu-item, .submenu-item, #transform-panel, #particle-behavior-panel').forEach(el => {
                if (isRainbow && !isAnimated) {
                    el.style.borderImage = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3) 1';
                } else if (!isRainbow) {
                    el.style.borderImage = 'none';
                    el.style.borderColor = theme.accent + '80';
                }
            });

            // Update hamburger spans
            document.querySelectorAll('.hamburger-btn span').forEach(el => {
                el.style.background = theme.accent;
            });

            // Update text elements
            document.querySelectorAll('.menu-item, .submenu-item, .breadcrumb, .info-username, .faq-answer, .faq-question, .prompt-message').forEach(el => {
                el.style.color = theme.text;
            });
            
            // Update navbar text elements
            document.querySelectorAll('#header-username, #header-description, #session-timer, #fps-counter').forEach(el => {
                el.style.color = theme.text;
            });
            
            // Update navbar buttons
            document.querySelectorAll('.quick-action-btn').forEach(el => {
                el.style.background = theme.primary;
                el.style.borderColor = theme.accent + '80';
                el.style.color = theme.text;
            });
            
            // Update inspector input fields
            document.querySelectorAll('#object-data-header, #object-data-body, #object-data-footer').forEach(el => {
                el.style.background = 'rgba(0, 0, 0, 0.3)';
                el.style.borderColor = theme.accent + '50';
                el.style.color = theme.text;
            });
            
            // Update inspector submit button
            const submitBtn = document.getElementById('object-data-submit');
            if (submitBtn) {
                submitBtn.style.background = theme.primary;
                submitBtn.style.borderColor = theme.accent + '80';
                submitBtn.style.color = theme.text;
            }
            
            // Update inspector labels and values
            document.querySelectorAll('.info-label').forEach(el => {
                el.style.color = 'rgba(255, 255, 255, 0.6)';
            });
            
            document.querySelectorAll('#object-position, #object-rotation, #object-scale').forEach(el => {
                el.style.background = 'rgba(0, 0, 0, 0.3)';
                el.style.borderColor = theme.accent + '50';
                el.style.color = theme.text;
            });

            // Keep timer always visible (bold white or dark depending on theme)
            const timer = document.querySelector('.info-timer');
            if (timer) {
                timer.style.color = theme.text === '#333' ? '#000' : '#fff';
            }

            // Update breadcrumb separators
            document.querySelectorAll('.breadcrumb-separator').forEach(el => {
                el.style.color = theme.text === '#333' ? 'rgba(0, 0, 0, 0.3)' : 'rgba(255, 255, 255, 0.3)';
            });

            // Update dock items with white glow and theme-specific text
            document.querySelectorAll('.dock-item').forEach(el => {
                el.style.background = '#ffffff';
                el.style.color = theme.dockText;
                el.style.border = `1px solid ${theme.accent}`;
                el.style.boxShadow = `0 0 10px ${theme.dockGlow}, 0 0 20px ${theme.dockGlow}, inset 0 0 5px rgba(255, 255, 255, 0.3)`;
                el.style.textShadow = `0 0 8px ${theme.accent}, 0 0 12px ${theme.accent}`;
            });

            // Update docks background
            document.querySelectorAll('.dock').forEach(el => {
                el.style.background = theme.primary;
                el.style.borderColor = theme.accent + '50';
            });

            // Update mobile controls (joystick and buttons)
            const joystickBase = document.querySelector('.joystick-base');
            if (joystickBase) {
                joystickBase.style.background = theme.primary;
                joystickBase.style.borderColor = theme.accent + '50';
            }

            const joystickStick = document.querySelector('.joystick-stick');
            if (joystickStick) {
                if (isRainbow) {
                    joystickStick.style.background = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)';
                    joystickStick.style.borderColor = '#ff00ff';
                    if (isAnimated) {
                        joystickStick.classList.add('rainbow-animated', 'rainbow-border');
                    }
                } else {
                    joystickStick.style.background = theme.accent + '99';
                    joystickStick.style.borderColor = theme.accent;
                }
            }

            // Update control buttons
            document.querySelectorAll('.control-btn').forEach(el => {
                el.style.background = theme.primary;
                el.style.color = theme.text;
                if (isRainbow && isAnimated) {
                    el.classList.add('rainbow-border');
                } else if (!isRainbow) {
                    el.style.borderColor = theme.accent + '50';
                } else {
                    el.style.borderImage = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3) 1';
                }
            });

            // Update action buttons
            document.querySelectorAll('.action-btn').forEach(el => {
                el.style.background = theme.primary;
                el.style.color = theme.text;
                if (isRainbow && isAnimated) {
                    el.classList.add('rainbow-border');
                } else if (!isRainbow) {
                    el.style.borderColor = theme.accent + '50';
                } else {
                    el.style.borderImage = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3) 1';
                }
            });

            // Update transform panel inputs
            document.querySelectorAll('.transform-input, .step-input').forEach(el => {
                el.style.background = 'rgba(255, 255, 255, 0.05)';
                el.style.borderColor = theme.accent + '50';
                el.style.color = theme.text;
            });

            // Update camera circle
            const cameraCircle = document.getElementById('camera-circle');
            if (cameraCircle) {
                cameraCircle.style.borderColor = theme.accent + '33';
            }

            // Update hand menu radial items
            document.querySelectorAll('.radial-item').forEach(el => {
                el.style.borderColor = theme.accent + '99';
                el.style.boxShadow = `0 0 10px ${theme.accent}66`;
            });

            // Update pause overlay
            const pauseTitle = document.querySelector('.pause-title');
            if (pauseTitle) {
                pauseTitle.style.color = theme.accent;
            }

            const pauseBtn = document.querySelector('.pause-btn');
            if (pauseBtn) {
                pauseBtn.style.background = theme.accent + '66';
                pauseBtn.style.borderColor = theme.accent + 'B3';
            }

            // Update pocket panel
            const pocketPanel = document.getElementById('pocket-panel');
            if (pocketPanel) {
                pocketPanel.style.background = theme.primary;
                pocketPanel.style.borderColor = theme.accent + '66';
            }

            const pocketHeader = document.querySelector('.pocket-header');
            if (pocketHeader) {
                pocketHeader.style.color = theme.accent;
            }

            document.querySelectorAll('.pocket-slot').forEach(el => {
                el.style.borderColor = theme.accent + '80';
            });

            // Update virtual keyboard
            const virtualKeyboard = document.getElementById('virtual-keyboard');
            if (virtualKeyboard) {
                virtualKeyboard.style.background = theme.primary;
                if (isRainbow && isAnimated) {
                    virtualKeyboard.classList.add('rainbow-border');
                } else if (isRainbow && !isAnimated) {
                    virtualKeyboard.style.borderImage = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3) 1';
                } else {
                    virtualKeyboard.style.borderImage = 'none';
                    virtualKeyboard.style.borderColor = theme.accent + '66';
                }
            }

            document.querySelectorAll('.key-btn').forEach(el => {
                el.style.color = theme.text;
                if (isRainbow) {
                    el.style.background = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)';
                    if (isAnimated) {
                        el.classList.add('rainbow-animated', 'rainbow-border');
                    } else {
                        el.style.borderImage = 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3) 1';
                    }
                } else {
                    el.style.background = theme.accent + '50';
                    el.style.borderColor = theme.accent + '80';
                    el.style.borderImage = 'none';
                }
            });

            // Update menu item hovers
            const styleSheet = document.createElement('style');
            styleSheet.textContent = `
                .menu-item:hover, .submenu-item:hover {
                    background: ${theme.accent}33 !important;
                    border-color: ${theme.accent}80 !important;
                }
                .prompt-btn {
                    background: ${theme.accent}50 !important;
                    border-color: ${theme.accent}80 !important;
                }
                .prompt-btn:hover {
                    background: ${theme.accent}80 !important;
                }
                .search-input {
                    color: ${theme.text} !important;
                    border-color: ${theme.accent}50 !important;
                }
                .search-input:focus {
                    border-color: ${theme.accent}99 !important;
                    background: ${theme.accent}1A !important;
                }
                .dock-item:hover {
                    background: #ffffff !important;
                    border-color: ${theme.accent} !important;
                    box-shadow: 0 0 15px ${theme.dockGlow}, 0 0 30px ${theme.dockGlow}, inset 0 0 8px rgba(255, 255, 255, 0.4) !important;
                    text-shadow: 0 0 10px ${theme.accent}, 0 0 15px ${theme.accent} !important;
                    transform: scale(1.1);
                }
                .dock-item.dragging {
                    opacity: 0.5;
                }
                .control-btn:hover, .action-btn:hover {
                    background: ${theme.accent}50 !important;
                    border-color: ${theme.accent}99 !important;
                }
                .control-btn.active, .action-btn.active {
                    background: ${theme.accent}99 !important;
                    border-color: ${theme.accent} !important;
                    color: ${theme.dockText} !important;
                }
                .joystick-stick:active {
                    background: ${theme.accent} !important;
                }
                .transform-input:focus, .step-input:focus {
                    border-color: ${theme.accent}99 !important;
                    background: ${theme.accent}1A !important;
                }
                .transform-input, .step-input {
                    color: ${theme.text} !important;
                    background: rgba(255, 255, 255, 0.05) !important;
                    border-color: ${theme.accent}50 !important;
                }
                .fps-mode #camera-circle {
                    border-color: ${theme.accent}99 !important;
                    border-width: 3px;
                }
                .fps-mode #camera-circle::before {
                    background: ${theme.accent}E6 !important;
                }
                .summon-btn, .transform-submit-btn {
                    background: ${theme.accent}50 !important;
                    border-color: ${theme.accent}80 !important;
                    color: ${theme.text} !important;
                }
                .summon-btn:hover, .transform-submit-btn:hover {
                    background: ${theme.accent}80 !important;
                    border-color: ${theme.accent} !important;
                }
                .radial-item:hover {
                    background: ${theme.accent}E6 !important;
                    border-color: ${theme.accent} !important;
                }
                .pause-title {
                    color: ${theme.accent} !important;
                }
                .pause-btn {
                    background: ${theme.accent}66 !important;
                    border-color: ${theme.accent}B3 !important;
                }
                .pause-btn:hover {
                    background: ${theme.accent}B3 !important;
                    box-shadow: 0 0 20px ${theme.accent}99 !important;
                }
                .pocket-panel {
                    background: ${theme.primary} !important;
                    border-color: ${theme.accent}66 !important;
                }
                .pocket-header {
                    color: ${theme.accent} !important;
                }
                .pocket-slot {
                    border-color: ${theme.accent}80 !important;
                }
                .pocket-slot:hover {
                    background: ${theme.accent}80 !important;
                    border-color: ${theme.accent}E6 !important;
                }
                #virtual-keyboard {
                    background: ${theme.primary} !important;
                    border-color: ${theme.accent}66 !important;
                }
                .key-btn {
                    background: ${theme.accent}50 !important;
                    border-color: ${theme.accent}80 !important;
                    color: ${theme.text} !important;
                }
                .key-btn:hover {
                    background: ${theme.accent}99 !important;
                    border-color: ${theme.accent} !important;
                }
                .key-btn:active {
                    background: ${theme.accent}CC !important;
                }
            `;
            
            // Remove old theme styles
            const oldStyle = document.getElementById('theme-dynamic-styles');
            if (oldStyle) oldStyle.remove();
            styleSheet.id = 'theme-dynamic-styles';
            document.head.appendChild(styleSheet);

            // Update active theme in grid
            document.querySelectorAll('.theme-option').forEach(el => {
                el.classList.remove('active');
            });
            const activeTheme = document.querySelector(`[data-theme="${themeName}"]`);
            if (activeTheme) {
                activeTheme.classList.add('active');
            }
            
            // Create GSAP rainbow flow animation if needed
            if (isRainbow && isAnimated) {
                const rainbowColors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3', '#ff0000'];
                const duration = 9.2;
                const colorDuration = duration / rainbowColors.length;
                
                // Create master timeline that we can kill later
                window.rainbowTimeline = gsap.timeline({ repeat: -1, paused: false });
                
                // Animate borders through rainbow - add to master timeline
                document.querySelectorAll('.side-menu, #inspector-panel, #info-panel, #search-panel, .dock, .hamburger-btn, #faq-panel, .prompt-modal, .menu-item, .submenu-item, #transform-panel, .control-btn, .action-btn, #virtual-keyboard').forEach(el => {
                    rainbowColors.forEach((color, i) => {
                        gsap.to(el, {
                            borderColor: color,
                            duration: colorDuration,
                            ease: 'linear',
                            repeat: -1,
                            repeatDelay: duration - colorDuration,
                            delay: i * colorDuration
                        });
                    });
                });
                
                // Animate text gradients
                document.querySelectorAll('.menu-title, .info-space-title, .breadcrumb-current, .controls-title, .prompt-title').forEach(el => {
                    gsap.to(el, {
                        backgroundPosition: '200% center',
                        duration: duration,
                        ease: 'linear',
                        repeat: -1,
                        backgroundSize: '200% 100%'
                    });
                });
                
                // Animate joystick stick
                const joystickStick = document.querySelector('.joystick-stick');
                if (joystickStick) {
                    gsap.to(joystickStick, {
                        backgroundPosition: '200% center',
                        duration: duration,
                        ease: 'linear',
                        repeat: -1,
                        backgroundSize: '200% 100%'
                    });
                }
                
                // Animate key buttons
                document.querySelectorAll('.key-btn').forEach(el => {
                    rainbowColors.forEach((color, i) => {
                        gsap.to(el, {
                            borderColor: color,
                            duration: colorDuration,
                            ease: 'linear',
                            repeat: -1,
                            repeatDelay: duration - colorDuration,
                            delay: i * colorDuration
                        });
                    });
                });
            }

            playSound('active');
        }

        function initThemeSelector() {
            const grid = document.getElementById('theme-grid');
            grid.innerHTML = '';

            Object.keys(themes).forEach(themeKey => {
                const theme = themes[themeKey];
                const option = document.createElement('div');
                option.className = 'theme-option';
                option.setAttribute('data-theme', themeKey);
                if (themeKey === currentTheme) {
                    option.classList.add('active');
                }
                
                option.innerHTML = `
                    <div class="theme-color-preview" style="background: ${theme.preview}"></div>
                    <div>${theme.name}</div>
                `;
                
                option.addEventListener('click', () => {
                    applyTheme(themeKey);
                });
                
                grid.appendChild(option);
            });
        }

        function setupHandMenus() {
            const leftHand = document.getElementById('left-hand');
            const rightHand = document.getElementById('right-hand');
            const consciousHand = document.getElementById('conscious-hand');
            const pauseOverlay = document.getElementById('pause-overlay');
            const resumeBtn = document.getElementById('resume-btn');

            // Create radial menu items for Left Hand
            const lhRadial = document.getElementById('lh-radial');
            const lhOptions = ['Move', 'Shift', 'Focus', 'Look', 'Feel', 
                              'Change', 'Zoom', 'Choose', 'Pace', 'Stretch'];
            createRadialMenu(lhRadial, lhOptions, 'lh');

            // Create radial menu items for Right Hand
            const rhRadial = document.getElementById('rh-radial');
            const rhOptions = ['Body', 'Mind', 'Voice', 'Power', 'Build', 
                              'Heal', 'Info', 'Assist', 'Protect', 'Story'];
            createRadialMenu(rhRadial, rhOptions, 'rh');

            // Create radial menu items for Conscious Hand
            const chRadial = document.getElementById('ch-radial');
            const chOptions = ['Form', 'Flow', 'Charge', 'Tone', 'Self', 
                              'Bond', 'Mood', 'Code', 'Web', 'Beyond'];
            createRadialMenu(chRadial, chOptions, 'ch');

            // Resume button
            resumeBtn.addEventListener('click', () => {
                pauseOverlay.classList.remove('visible');
                playSound('active');
            });

            // Mobile buttons
            const btnLH = document.getElementById('btn-lh');
            const btnRH = document.getElementById('btn-rh');
            const btnCH = document.getElementById('btn-ch');

            if (btnLH) {
                btnLH.addEventListener('click', () => {
                    toggleLeftHand();
                });
            }

            if (btnRH) {
                btnRH.addEventListener('click', () => {
                    toggleRightHand();
                });
            }

            if (btnCH) {
                btnCH.addEventListener('click', () => {
                    toggleConsciousHand();
                });
            }

            const btnDocks = document.getElementById('btn-docks');
            if (btnDocks) {
                btnDocks.addEventListener('click', () => {
                    docksVisible = !docksVisible;
                    const docks = document.querySelectorAll('.dock');
                    docks.forEach(dock => {
                        if (docksVisible) {
                            dock.classList.remove('hidden');
                        } else {
                            dock.classList.add('hidden');
                        }
                    });
                    playSound('passive');
                });
            }

            const btnKeyboard = document.getElementById('btn-keyboard');
            if (btnKeyboard) {
                btnKeyboard.addEventListener('click', () => {
                    toggleVirtualKeyboard();
                });
            }

            const btnActionGrid = document.getElementById('btn-action-grid');
            if (btnActionGrid) {
                btnActionGrid.addEventListener('click', () => {
                    toggleActionGrid();
                });
            }

            const btnTray = document.getElementById('btn-tray');
            if (btnTray) {
                btnTray.addEventListener('click', () => {
                    const sideTray = document.getElementById('side-tray');
                    const topTray = document.getElementById('top-tray');
                    
                    const isHidden = sideTray.style.display === 'none';
                    
                    if (sideTray) {
                        sideTray.style.display = isHidden ? 'block' : 'none';
                    }
                    if (topTray) {
                        topTray.style.display = isHidden ? 'flex' : 'none';
                    }
                    
                    btnTray.classList.toggle('active');
                    playSound('passive');
                });
            }

            const btnChat = document.getElementById('btn-chat');
            if (btnChat) {
                btnChat.addEventListener('click', () => {
                    const chatPanel = document.getElementById('chat-panel');
                    
                    if (chatPanel) {
                        const isHidden = chatPanel.style.display === 'none';
                        chatPanel.style.display = isHidden ? 'block' : 'none';
                        
                        btnChat.classList.toggle('active');
                        playSound('passive');
                    }
                });
            }

            const btnOrbit = document.getElementById('btn-orbit');
            if (btnOrbit) {
                btnOrbit.addEventListener('click', () => {
                    const orbitPanel = document.getElementById('orbit-controls-panel');
                    
                    if (orbitPanel) {
                        orbitPanel.style.display = 'block';
                        orbitPanel.classList.remove('minimized');
                        const content = document.getElementById('orbit-panel-content');
                        if (content) {
                            content.classList.remove('hidden');
                        }
                        document.getElementById('orbit-minimize-btn').textContent = '_';
                        
                        btnOrbit.classList.toggle('active');
                        playSound('passive');
                    }
                });
            }

            const btnNav = document.getElementById('btn-nav');
            if (btnNav) {
                btnNav.addEventListener('click', () => {
                    const headerBar = document.getElementById('header-bar');
                    if (headerBar.style.display === 'none') {
                        headerBar.style.display = 'flex';
                    } else {
                        headerBar.style.display = 'none';
                    }
                    playSound('active');
                });
            }

            const btnRulers = document.getElementById('btn-rulers');
            if (btnRulers) {
                btnRulers.addEventListener('click', () => {
                    const xRuler = document.getElementById('x-axis-ruler');
                    const yRuler = document.getElementById('y-axis-ruler');
                    const zRuler = document.getElementById('z-axis-ruler');
                    
                    if (xRuler && yRuler && zRuler) {
                        const isVisible = xRuler.style.display === 'flex';
                        xRuler.style.display = isVisible ? 'none' : 'flex';
                        yRuler.style.display = isVisible ? 'none' : 'flex';
                        zRuler.style.display = isVisible ? 'none' : 'flex';
                        playSound('active');
                    }
                });
            }

            const btnMax = document.getElementById('btn-max');
            if (btnMax) {
                btnMax.addEventListener('click', () => {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen().catch(err => {
                            console.log('Fullscreen error:', err);
                        });
                    } else {
                        document.exitFullscreen();
                    }
                    playSound('active');
                });
            }

            const btnSense = document.getElementById('btn-sense');
            if (btnSense) {
                btnSense.addEventListener('click', () => {
                    toggleOmniSenseMode();
                    playSound('active');
                });
            }

            const btnKeys = document.getElementById('btn-keys');
            if (btnKeys) {
                btnKeys.addEventListener('click', () => {
                    toggleOmniKeyboard();
                    playSound('active');
                });
            }

            // Up and Down movement buttons (R and F keys)
            const btnUp = document.getElementById('btn-up');
            if (btnUp) {
                btnUp.addEventListener('mousedown', () => {
                    keys['r'] = true;
                });
                btnUp.addEventListener('mouseup', () => {
                    keys['r'] = false;
                });
                btnUp.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys['r'] = true;
                });
                btnUp.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys['r'] = false;
                });
            }

            const btnDown = document.getElementById('btn-down');
            if (btnDown) {
                btnDown.addEventListener('mousedown', () => {
                    keys['f'] = true;
                });
                btnDown.addEventListener('mouseup', () => {
                    keys['f'] = false;
                });
                btnDown.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys['f'] = true;
                });
                btnDown.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys['f'] = false;
                });
            }

            // Center button (O key - reset camera)
            const btnCenter = document.getElementById('btn-center');
            if (btnCenter) {
                btnCenter.addEventListener('click', () => {
                    gsap.to(camera.position, {
                        duration: 1.5,
                        x: 0,
                        y: 0,
                        z: 10,
                        ease: 'power2.inOut'
                    });
                    camera.quaternion.set(0, 0, 0, 1); // Reset rotation
                    playSound('active');
                });
            }
        }

        function createRadialMenu(container, options, handType) {
            const radius = 100; // Distance from center
            const angleStep = (Math.PI * 2) / options.length;

            options.forEach((option, index) => {
                const angle = angleStep * index - Math.PI / 2; // Start from top
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                const item = document.createElement('div');
                item.className = 'radial-item';
                item.textContent = option;
                item.style.left = `calc(50% + ${x}px)`;
                item.style.top = `calc(50% + ${y}px)`;
                item.style.transform = 'translate(-50%, -50%)';

                item.addEventListener('click', () => {
                    handleRadialItemClick(handType, option, index);
                });

                container.appendChild(item);
            });
        }

        function handleRadialItemClick(handType, option, index) {
            console.log(`${handType} - ${option} clicked (index: ${index})`);
            playSound('active');

            // Handle RH options - all open the tool menu
            if (handType === 'rh') {
                if (!rhToolMenuVisible) {
                    toggleRHToolMenu();
                }
                return;
            }

            // Handle LH options - all open the tool menu
            if (handType === 'lh') {
                // Special handling for Move tool - open User Controls panel
                if (option === 'Move') {
                    const userPanel = document.getElementById('user-controls-panel');
                    if (userPanel) {
                        userPanel.style.display = 'block';
                        userPanel.classList.remove('minimized');
                        const content = document.getElementById('user-panel-content');
                        if (content) {
                            content.classList.remove('hidden');
                        }
                        document.getElementById('user-minimize-btn').textContent = '_';
                    }
                    playSound('active');
                    return;
                }
                
                if (!lhToolMenuVisible) {
                    toggleLHToolMenu();
                }
                return;
            }

            // Handle special CH options
            if (handType === 'ch') {
                if (option === 'Pause Menu') {
                    document.getElementById('pause-overlay').classList.add('visible');
                    return;
                }
                
                if (option === 'MySpace') {
                    toggleMySpace();
                    return;
                }
                
                if (option === 'User Pocket') {
                    togglePocket();
                    return;
                }
                
                // All other CH options open the tool menu
                if (!chToolMenuVisible) {
                    toggleCHToolMenu();
                }
            }

            // Add more functionality here for each option
        }

        function toggleLeftHand() {
            leftHandVisible = !leftHandVisible;
            const leftHand = document.getElementById('left-hand');
            
            if (leftHandVisible) {
                leftHand.classList.add('visible');
            } else {
                leftHand.classList.remove('visible');
                // Hide LH tool menu when hand is hidden
                if (lhToolMenuVisible) {
                    toggleLHToolMenu();
                }
            }
            playSound('passive');
        }

        function toggleRightHand() {
            rightHandVisible = !rightHandVisible;
            const rightHand = document.getElementById('right-hand');
            const rhMovementControl = document.getElementById('rh-movement-control');
            
            if (rightHandVisible) {
                rightHand.classList.add('visible');
                rhMovementControl.style.display = 'block';
            } else {
                rightHand.classList.remove('visible');
                rhMovementControl.style.display = 'none';
                // Hide tool menu when RH is hidden
                if (rhToolMenuVisible) {
                    toggleRHToolMenu();
                }
            }
            playSound('passive');
        }

        function toggleConsciousHand() {
            consciousHandVisible = !consciousHandVisible;
            const consciousHand = document.getElementById('conscious-hand');
            const chMovementControl = document.getElementById('ch-movement-control');
            
            if (consciousHandVisible) {
                consciousHand.classList.add('visible');
                chMovementControl.style.display = 'block';
            } else {
                consciousHand.classList.remove('visible');
                chMovementControl.style.display = 'none';
                // Hide CH tool menu when hand is hidden
                if (chToolMenuVisible) {
                    toggleCHToolMenu();
                }
            }
            playSound('passive');
        }

        // Tool Menu System for all hands
        let rhToolMenuVisible = false;
        let lhToolMenuVisible = false;
        let chToolMenuVisible = false;

        const rhToolData = [];
        const lhToolData = [];
        const chToolData = [];

        // Create 11 tools for each hand
        for (let i = 0; i < 11; i++) {
            rhToolData.push({
                name: `TOOL${String(i).padStart(2, '0')}`,
                description: `RH Tool ${i}. Different settings and interface will appear in the RH movement pad when selected.`,
                id: `rh-tool${i}`
            });
            lhToolData.push({
                name: `TOOL${String(i).padStart(2, '0')}`,
                description: `LH Tool ${i}. Additional details and functionality will be added later.`,
                id: `lh-tool${i}`
            });
            chToolData.push({
                name: `TOOL${String(i).padStart(2, '0')}`,
                description: `CH Tool ${i}. Additional details and functionality will be added later.`,
                id: `ch-tool${i}`
            });
        }

        function initializeToolMenu() {
            // Initialize RH tool menu
            populateToolMenu('rh', rhToolData);
            // Initialize LH tool menu
            populateToolMenu('lh', lhToolData);
            // Initialize CH tool menu
            populateToolMenu('ch', chToolData);
            
            // Make all tool menus draggable
            makeDraggable('rh-tool-menu');
            makeDraggable('lh-tool-menu');
            makeDraggable('ch-tool-menu');
        }

        function populateToolMenu(handType, toolData) {
            const toolMenuItems = document.getElementById(`${handType}-tool-menu-items`);
            const toolDescription = document.getElementById(`${handType}-tool-description`);
            
            toolData.forEach((tool, index) => {
                const toolItem = document.createElement('div');
                toolItem.className = 'tool-item';
                toolItem.textContent = tool.name;
                toolItem.dataset.toolId = tool.id;
                toolItem.dataset.handType = handType;
                
                toolItem.addEventListener('click', () => {
                    // Remove previous selection from this hand's menu
                    toolMenuItems.querySelectorAll('.tool-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    // Select current
                    toolItem.classList.add('selected');
                    // Update description
                    toolDescription.textContent = tool.description;
                    
                    // If RH tool selected, update the RH movement pad to show tool interface
                    if (handType === 'rh') {
                        updateRHToolInterface(tool.id);
                    }
                    
                    playSound('passive');
                });
                
                toolMenuItems.appendChild(toolItem);
            });
        }

        function makeDraggable(elementId) {
            const element = document.getElementById(elementId);
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            const header = element.querySelector('.tool-menu-header');
            if (header) {
                header.style.cursor = 'move';
                header.onmousedown = dragMouseDown;
            }
            
            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + 'px';
                element.style.left = (element.offsetLeft - pos1) + 'px';
                element.style.right = 'auto';
                element.style.transform = 'none';
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        function updateRHToolInterface(toolId) {
            // This function will update the RH movement pad to show
            // the appropriate interface for the selected tool
            // For now, just console log - we'll implement specific tool UIs later
            console.log('RH Tool selected:', toolId);
            // TODO: Show different interface in RH movement pad based on toolId
        }

        function toggleRHToolMenu() {
            rhToolMenuVisible = !rhToolMenuVisible;
            const toolMenu = document.getElementById('rh-tool-menu');
            
            if (rhToolMenuVisible) {
                toolMenu.style.display = 'block';
                playSound('active');
            } else {
                toolMenu.style.display = 'none';
                // Clear selection
                document.querySelectorAll('#rh-tool-menu-items .tool-item').forEach(item => {
                    item.classList.remove('selected');
                });
                document.getElementById('rh-tool-description').textContent = 'Select a tool to view details';
                playSound('passive');
            }
        }

        function toggleLHToolMenu() {
            lhToolMenuVisible = !lhToolMenuVisible;
            const toolMenu = document.getElementById('lh-tool-menu');
            
            if (lhToolMenuVisible) {
                toolMenu.style.display = 'block';
                playSound('active');
            } else {
                toolMenu.style.display = 'none';
                // Clear selection
                document.querySelectorAll('#lh-tool-menu-items .tool-item').forEach(item => {
                    item.classList.remove('selected');
                });
                document.getElementById('lh-tool-description').textContent = 'Select a tool to view details';
                playSound('passive');
            }
        }

        function toggleCHToolMenu() {
            chToolMenuVisible = !chToolMenuVisible;
            const toolMenu = document.getElementById('ch-tool-menu');
            
            if (chToolMenuVisible) {
                toolMenu.style.display = 'block';
                playSound('active');
            } else {
                toolMenu.style.display = 'none';
                // Clear selection
                document.querySelectorAll('#ch-tool-menu-items .tool-item').forEach(item => {
                    item.classList.remove('selected');
                });
                document.getElementById('ch-tool-description').textContent = 'Select a tool to view details';
                playSound('passive');
            }
        }

        function toggleMySpace() {
            if (mySpaceAnimating) return; // Prevent multiple animations
            
            mySpaceAnimating = true;
            mySpaceExpanded = !mySpaceExpanded;
            
            const targetRadius = mySpaceExpanded ? expandedRadius : collapsedRadius;
            
            // Animate each grid panel one by one
            gridObjects.forEach((panel, index) => {
                // Stagger the animation for each panel
                setTimeout(() => {
                    // Calculate new position on sphere
                    const currentPos = panel.position.clone().normalize();
                    const targetPos = currentPos.multiplyScalar(targetRadius);
                    
                    gsap.to(panel.position, {
                        duration: 0.6,
                        x: targetPos.x,
                        y: targetPos.y,
                        z: targetPos.z,
                        ease: 'power2.inOut',
                        onComplete: () => {
                            // Make panel look at center
                            panel.lookAt(0, 0, 0);
                            
                            // Mark animation complete on last panel
                            if (index === gridObjects.length - 1) {
                                mySpaceAnimating = false;
                            }
                        }
                    });
                    
                    // Also animate opacity for collapse effect
                    gsap.to(panel.material, {
                        duration: 0.6,
                        opacity: mySpaceExpanded ? 0.2 : 0.1,
                        ease: 'power2.inOut'
                    });
                    
                }, index * 20); // 20ms delay between each panel
            });
            
            playSound('active');
        }

        function togglePocket() {
            pocketVisible = !pocketVisible;
            const pocketPanel = document.getElementById('pocket-panel');
            
            if (pocketVisible) {
                pocketPanel.classList.add('visible');
            } else {
                pocketPanel.classList.remove('visible');
            }
            
            playSound('passive');
        }

        function toggleOmniSenseMode() {
            omniSenseMode = !omniSenseMode;
            
            if (omniSenseMode) {
                // Entering OmniSense Mode
                console.log('Entering OmniSense Mode');
                
                // Save current camera position
                normalCameraPosition = camera.position.clone();
                normalCameraTarget = new THREE.Vector3(0, 0, 0);
                
                // Show cube
                if (omniSenseCube) {
                    omniSenseCube.visible = true;
                }
                
                // Brighten floor grid
                if (gridHelper) {
                    gridHelper.material.opacity = 0.6;
                }
                
                // Move camera to top-down view
                gsap.to(camera.position, {
                    duration: 1.5,
                    x: 0,
                    y: omniSenseCameraHeight,
                    z: 0,
                    ease: 'power2.inOut',
                    onUpdate: () => {
                        camera.lookAt(0, 0, 0);
                    }
                });
                
                // Highlight SENSE button
                const btnSense = document.getElementById('btn-sense');
                if (btnSense) {
                    btnSense.classList.add('active');
                }
                
                // Show OmniSense Controls Panel (minimized)
                const omniSensePanel = document.getElementById('omnisense-panel');
                if (omniSensePanel) {
                    omniSensePanel.style.display = 'block';
                    omniSensePanel.classList.add('minimized');
                }
                
            } else {
                // Exiting OmniSense Mode
                console.log('Exiting OmniSense Mode');
                
                // Hide cube
                if (omniSenseCube) {
                    omniSenseCube.visible = false;
                }
                
                // Reset floor grid opacity
                if (gridHelper) {
                    gridHelper.material.opacity = 0.3;
                }
                
                // Return camera to normal position
                if (normalCameraPosition) {
                    gsap.to(camera.position, {
                        duration: 1.5,
                        x: normalCameraPosition.x,
                        y: normalCameraPosition.y,
                        z: normalCameraPosition.z,
                        ease: 'power2.inOut'
                    });
                }
                
                // Remove highlight from SENSE button
                const btnSense = document.getElementById('btn-sense');
                if (btnSense) {
                    btnSense.classList.remove('active');
                }
                
                // Hide OmniSense Controls Panel
                const omniSensePanel = document.getElementById('omnisense-panel');
                if (omniSensePanel) {
                    omniSensePanel.style.display = 'none';
                }
            }
        }

        function toggleOmniKeyboard() {
            omniKeyboardVisible = !omniKeyboardVisible;
            
            if (omniKeyboardVisible) {
                console.log('mniKeyboard: Opening');
                
                // Create keyboard if it doesn't exist
                if (!omniKeyboardGroup) {
                    createOmniKeyboard();
                }
                
                // Show keyboard (no position animation since it's attached to camera)
                if (omniKeyboardGroup) {
                    omniKeyboardGroup.visible = true;
                }
                
                // Highlight KEYS button
                const btnKeys = document.getElementById('btn-keys');
                if (btnKeys) {
                    btnKeys.classList.add('active');
                }
                
                // Show OmniKeys Control Panel
                const omnikeysPanel = document.getElementById('omnikeys-panel');
                if (omnikeysPanel) {
                    omnikeysPanel.style.display = 'block';
                }
                
                // Setup control panel listeners if not already done
                setupOmniKeysControlPanel();
                
            } else {
                console.log('mniKeyboard: Closing');
                
                // Hide keyboard
                if (omniKeyboardGroup) {
                    omniKeyboardGroup.visible = false;
                }
                
                // Remove highlight from KEYS button
                const btnKeys = document.getElementById('btn-keys');
                if (btnKeys) {
                    btnKeys.classList.remove('active');
                }
                
                // Hide OmniKeys Control Panel
                const omnikeysPanel = document.getElementById('omnikeys-panel');
                if (omnikeysPanel) {
                    omnikeysPanel.style.display = 'none';
                }
            }
        }

        function createOmniKeyboard() {
            console.log('mniKeyboard: Creating keyboard structure');
            
            // Create group to hold all keyboard elements
            omniKeyboardGroup = new THREE.Group();
            omniKeyboardGroup.position.set(omniKeyboardOffsetX, omniKeyboardOffsetY, omniKeyboardOffsetZ);
            omniKeyboardGroup.rotation.set(omniKeyboardRotationX, omniKeyboardRotationY, omniKeyboardRotationZ);
            omniKeyboardGroup.scale.set(omniKeyboardScaleUniform, omniKeyboardScaleUniform, omniKeyboardScaleUniform);
            omniKeyboardGroup.visible = false;
            
            // Attach to camera instead of scene
            camera.add(omniKeyboardGroup);
            
            const cubeSize = 2.5 * omniKeyboardScale;
            const spacing = omniKeyboardSpacing * omniKeyboardScale;
            const rowSpacing = omniKeyboardRowSpacing * omniKeyboardScale;
            
            // Mac Dock incline: additional rotation on top of base rotation
            // (Base rotation is controlled by omniKeyboardRotationX)
            
            // Create each row of keys
            omniKeyboardRows.forEach((row, rowIndex) => {
                const rowGroup = new THREE.Group();
                const numKeys = row.keys.length;
                const rowWidth = (numKeys - 1) * spacing;
                const startX = -rowWidth / 2;
                
                // Create row label (left side)
                const labelCanvas = document.createElement('canvas');
                labelCanvas.width = 256;
                labelCanvas.height = 64;
                const labelCtx = labelCanvas.getContext('2d');
                labelCtx.fillStyle = 'rgba(128, 128, 128, 0.8)';
                labelCtx.fillRect(0, 0, 256, 64);
                labelCtx.fillStyle = '#ffffff';
                labelCtx.font = 'bold 20px Orbitron';
                labelCtx.textAlign = 'center';
                labelCtx.textBaseline = 'middle';
                labelCtx.fillText(row.name, 128, 32);
                
                const labelTexture = new THREE.CanvasTexture(labelCanvas);
                const labelGeometry = new THREE.PlaneGeometry(4, 1);
                const labelMaterial = new THREE.MeshBasicMaterial({ 
                    map: labelTexture, 
                    transparent: true,
                    opacity: 0.7
                });
                const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
                labelMesh.position.set(startX - 5, 0, 0);
                rowGroup.add(labelMesh);
                
                // Create keys in this row
                row.keys.forEach((keyLabel, keyIndex) => {
                    const keyCube = createKeyCube(keyLabel, rowIndex, keyIndex);
                    keyCube.position.x = startX + (keyIndex * spacing);
                    rowGroup.add(keyCube);
                    omniKeyboardCubes.push(keyCube);
                });
                
                // Position row
                rowGroup.position.z = rowIndex * rowSpacing;
                omniKeyboardGroup.add(rowGroup);
            });
            
            console.log(`mniKeyboard: Created ${omniKeyboardCubes.length} keys`);
        }

        function createKeyCube(label, rowIndex, colIndex) {
            const cubeSize = 2.0 * omniKeyboardScale;
            
            // Create cube geometry
            const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            
            // Create canvas texture for top face (with label)
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Background
            ctx.fillStyle = 'rgba(60, 60, 70, 0.9)';
            ctx.fillRect(0, 0, 128, 128);
            
            // Border
            ctx.strokeStyle = 'rgba(128, 128, 128, 0.6)';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, 0, 128, 128);
            
            // Label text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Orbitron';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            
            // Create materials for each face (top gets label, others get placeholders)
            const materials = [];
            for (let i = 0; i < 6; i++) {
                if (i === 2) { // Top face (+Y)
                    materials.push(new THREE.MeshStandardMaterial({ 
                        map: texture,
                        transparent: true,
                        opacity: 0.3,
                        emissive: new THREE.Color(0x808080),
                        emissiveIntensity: 0.15
                    }));
                } else {
                    // Placeholder faces - lighter grey and transparent
                    const placeholderMaterial = new THREE.MeshStandardMaterial({
                        color: 0xb0b0b0, // Lighter grey
                        transparent: true,
                        opacity: 0.3,
                        emissive: new THREE.Color(0x707070),
                        emissiveIntensity: 0.1
                    });
                    materials.push(placeholderMaterial);
                }
            }
            
            const cube = new THREE.Mesh(geometry, materials);
            
            // Add levitation glow plane underneath
            const glowGeometry = new THREE.PlaneGeometry(cubeSize * 1.5, cubeSize * 1.5);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff, // White glow
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const glowPlane = new THREE.Mesh(glowGeometry, glowMaterial);
            glowPlane.rotation.x = -Math.PI / 2;
            glowPlane.position.y = -cubeSize * 0.6;
            cube.add(glowPlane);
            
            cube.userData = {
                type: 'omniKey',
                label: label,
                rowIndex: rowIndex,
                colIndex: colIndex,
                faces: {
                    front: label,
                    back: `${label}`,
                    left: `${label}`,
                    right: `${label}`,
                    top: `${label}`,
                    bottom: `${label}`
                }
            };
            
            // Create billboard sprite label that always faces camera
            const spriteCanvas = document.createElement('canvas');
            spriteCanvas.width = 256;
            spriteCanvas.height = 256;
            const spriteCtx = spriteCanvas.getContext('2d');
            
            // Clear background (transparent)
            spriteCtx.clearRect(0, 0, 256, 256);
            
            // Add glow effect for bright characters
            spriteCtx.shadowColor = 'rgba(255, 255, 255, 0.9)';
            spriteCtx.shadowBlur = 20;
            spriteCtx.fillStyle = '#ffffff';
            spriteCtx.font = 'bold 96px Orbitron';
            spriteCtx.textAlign = 'center';
            spriteCtx.textBaseline = 'middle';
            spriteCtx.fillText(label, 128, 128);
            
            // Draw text again for extra brightness
            spriteCtx.shadowBlur = 10;
            spriteCtx.fillText(label, 128, 128);
            
            const spriteTexture = new THREE.CanvasTexture(spriteCanvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: spriteTexture,
                transparent: true,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(cubeSize * 1.2, cubeSize * 1.2, 1);
            sprite.position.y = cubeSize * 0.55; // Position above cube
            cube.add(sprite);
            
            // Store sprite reference for updates
            cube.userData.labelSprite = sprite;
            
            // Add to interactive objects for raycasting
            interactiveObjects.push(cube);
            
            return cube;
        }

        function updateInspectorForKeyboard() {
            const inspectorPanel = document.getElementById('inspector-panel');
            if (!inspectorPanel) return;
            
            // Show inspector if hidden
            if (!inspectorPanel.classList.contains('visible')) {
                inspectorPanel.classList.add('visible');
            }
            
            // Update inspector content
            const titleElement = inspectorPanel.querySelector('.panel-title');
            if (titleElement) {
                titleElement.textContent = 'MNIKEYS';
            }
        }

        function navigateOmniKeyboard(direction) {
            if (!omniKeyboardVisible) return;
            
            // Handle arrow key navigation
            const maxRows = omniKeyboardRows.length - 1;
            const currentRowKeys = omniKeyboardRows[omniKeyboardCurrentRow].keys;
            const maxCol = currentRowKeys.length - 1;
            
            switch(direction) {
                case 'up':
                    if (omniKeyboardCurrentRow > 0) {
                        omniKeyboardCurrentRow--;
                        // Adjust column if new row has fewer keys
                        const newRowMaxCol = omniKeyboardRows[omniKeyboardCurrentRow].keys.length - 1;
                        omniKeyboardCurrentCol = Math.min(omniKeyboardCurrentCol, newRowMaxCol);
                    }
                    break;
                case 'down':
                    if (omniKeyboardCurrentRow < maxRows) {
                        omniKeyboardCurrentRow++;
                        // Adjust column if new row has fewer keys
                        const newRowMaxCol = omniKeyboardRows[omniKeyboardCurrentRow].keys.length - 1;
                        omniKeyboardCurrentCol = Math.min(omniKeyboardCurrentCol, newRowMaxCol);
                    }
                    break;
                case 'left':
                    omniKeyboardCurrentCol = Math.max(0, omniKeyboardCurrentCol - 1);
                    break;
                case 'right':
                    omniKeyboardCurrentCol = Math.min(maxCol, omniKeyboardCurrentCol + 1);
                    break;
            }
            
            // Highlight current key
            highlightCurrentKey();
        }

        function highlightCurrentKey() {
            // Remove highlight from all keys
            omniKeyboardCubes.forEach(cube => {
                if (cube.material && Array.isArray(cube.material)) {
                    cube.material.forEach(mat => {
                        if (mat.emissiveIntensity !== undefined) {
                            mat.emissiveIntensity = 0.2;
                        }
                    });
                }
            });
            
            // Find and highlight current key
            const currentKey = omniKeyboardCubes.find(cube => 
                cube.userData.rowIndex === omniKeyboardCurrentRow &&
                cube.userData.colIndex === omniKeyboardCurrentCol
            );
            
            if (currentKey && currentKey.material && Array.isArray(currentKey.material)) {
                currentKey.material.forEach(mat => {
                    if (mat.emissiveIntensity !== undefined) {
                        mat.emissiveIntensity = 0.8;
                    }
                });
                
                // Update inspector with key info
                updateInspectorWithKeyInfo(currentKey);
            }
        }

        function setupParticleControlPanel() {
            const panel = document.getElementById('particle-panel');
            const minimizeBtn = document.getElementById('particle-minimize-btn');
            const closeBtn = document.getElementById('particle-close-btn');
            const panelHeader = document.getElementById('particle-panel-header');
            const panelContent = document.getElementById('particle-panel-content');
            
            // Panel controls
            if (minimizeBtn && panelContent && panel) {
                minimizeBtn.addEventListener('click', () => {
                    panel.classList.toggle('minimized');
                    panelContent.classList.toggle('hidden');
                    playSound('passive');
                });
            }
            
            if (closeBtn && panel) {
                closeBtn.addEventListener('click', () => {
                    panel.style.display = 'none';
                    playSound('passive');
                });
            }
            
            // Make panel draggable
            if (panelHeader && panel) {
                let isDragging = false;
                let currentX, currentY, initialX, initialY;
                
                panelHeader.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('panel-btn')) return;
                    isDragging = true;
                    initialX = e.clientX - panel.offsetLeft;
                    initialY = e.clientY - panel.offsetTop;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        panel.style.left = currentX + 'px';
                        panel.style.top = currentY + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            // Get all controls
            const numberSlider = document.getElementById('p-number');
            const numberValue = document.getElementById('p-number-value');
            const colorPicker = document.getElementById('p-color');
            const shapePicker = document.getElementById('p-shape');
            const sizeSlider = document.getElementById('p-size');
            const sizeValue = document.getElementById('p-size-value');
            const sizeRandomCheck = document.getElementById('p-size-random');
            const sizeAnimCheck = document.getElementById('p-size-anim');
            const sizeAnimSpeedSlider = document.getElementById('p-size-anim-speed');
            const sizeAnimSpeedValue = document.getElementById('p-size-anim-speed-value');
            const opacitySlider = document.getElementById('p-opacity');
            const opacityValue = document.getElementById('p-opacity-value');
            const opacityRandomCheck = document.getElementById('p-opacity-random');
            const opacityAnimCheck = document.getElementById('p-opacity-anim');
            
            const lineEnableCheck = document.getElementById('p-line-enable');
            const lineColorPicker = document.getElementById('p-line-color');
            const lineDistanceSlider = document.getElementById('p-line-distance');
            const lineDistanceValue = document.getElementById('p-line-distance-value');
            const lineOpacitySlider = document.getElementById('p-line-opacity');
            const lineOpacityValue = document.getElementById('p-line-opacity-value');
            const lineWidthSlider = document.getElementById('p-line-width');
            const lineWidthValue = document.getElementById('p-line-width-value');
            
            const moveEnableCheck = document.getElementById('p-move-enable');
            const moveSpeedSlider = document.getElementById('p-move-speed');
            const moveSpeedValue = document.getElementById('p-move-speed-value');
            const moveDirectionSelect = document.getElementById('p-move-direction');
            const moveRandomCheck = document.getElementById('p-move-random');
            const moveStraightCheck = document.getElementById('p-move-straight');
            const moveOutModeSelect = document.getElementById('p-move-out-mode');
            const moveBounceCheck = document.getElementById('p-move-bounce');
            
            const hoverEnableCheck = document.getElementById('p-hover-enable');
            const hoverModeSelect = document.getElementById('p-hover-mode');
            const clickEnableCheck = document.getElementById('p-click-enable');
            const clickModeSelect = document.getElementById('p-click-mode');
            const repulseDistanceSlider = document.getElementById('p-repulse-distance');
            const repulseDistanceValue = document.getElementById('p-repulse-distance-value');
            
            const resetBtn = document.getElementById('particle-reset-btn');
            
            // Particle Number
            if (numberSlider && numberValue) {
                numberSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    numberValue.textContent = value;
                    updateParticles({ count: value });
                });
            }
            
            // Particle Color
            if (colorPicker) {
                colorPicker.addEventListener('input', (e) => {
                    updateParticles({ particleColor: e.target.value });
                });
            }
            
            // Shape
            if (shapePicker) {
                shapePicker.addEventListener('change', (e) => {
                    updateParticles({ shape: e.target.value });
                });
            }
            
            // Size
            if (sizeSlider && sizeValue) {
                sizeSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    sizeValue.textContent = value;
                    updateParticles({ size: value });
                });
            }
            
            // Size Random
            if (sizeRandomCheck) {
                sizeRandomCheck.addEventListener('change', (e) => {
                    updateParticles({ sizeRandom: e.target.checked });
                });
            }
            
            // Size Animation
            if (sizeAnimCheck) {
                sizeAnimCheck.addEventListener('change', (e) => {
                    updateParticles({ sizeAnim: e.target.checked });
                });
            }
            
            // Size Animation Speed
            if (sizeAnimSpeedSlider && sizeAnimSpeedValue) {
                sizeAnimSpeedSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    sizeAnimSpeedValue.textContent = value;
                    updateParticles({ sizeAnimSpeed: value });
                });
            }
            
            // Opacity
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    opacityValue.textContent = value;
                    updateParticles({ opacity: value });
                });
            }
            
            // Opacity Random
            if (opacityRandomCheck) {
                opacityRandomCheck.addEventListener('change', (e) => {
                    updateParticles({ opacityRandom: e.target.checked });
                });
            }
            
            // Opacity Animation
            if (opacityAnimCheck) {
                opacityAnimCheck.addEventListener('change', (e) => {
                    updateParticles({ opacityAnim: e.target.checked });
                });
            }
            
            // Line Enable
            if (lineEnableCheck) {
                lineEnableCheck.addEventListener('change', (e) => {
                    updateParticles({ lineEnable: e.target.checked });
                });
            }
            
            // Line Color
            if (lineColorPicker) {
                lineColorPicker.addEventListener('input', (e) => {
                    updateParticles({ lineColor: e.target.value });
                });
            }
            
            // Line Distance
            if (lineDistanceSlider && lineDistanceValue) {
                lineDistanceSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    lineDistanceValue.textContent = value;
                    updateParticles({ lineDistance: value });
                });
            }
            
            // Line Opacity
            if (lineOpacitySlider && lineOpacityValue) {
                lineOpacitySlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    lineOpacityValue.textContent = value;
                    updateParticles({ lineOpacity: value });
                });
            }
            
            // Line Width
            if (lineWidthSlider && lineWidthValue) {
                lineWidthSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    lineWidthValue.textContent = value;
                    updateParticles({ lineWidth: value });
                });
            }
            
            // Move Enable
            if (moveEnableCheck) {
                moveEnableCheck.addEventListener('change', (e) => {
                    updateParticles({ moveEnable: e.target.checked });
                });
            }
            
            // Move Speed
            if (moveSpeedSlider && moveSpeedValue) {
                moveSpeedSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    moveSpeedValue.textContent = value;
                    updateParticles({ speed: value });
                });
            }
            
            // Move Direction
            if (moveDirectionSelect) {
                moveDirectionSelect.addEventListener('change', (e) => {
                    updateParticles({ moveDirection: e.target.value });
                });
            }
            
            // Move Random
            if (moveRandomCheck) {
                moveRandomCheck.addEventListener('change', (e) => {
                    updateParticles({ moveRandom: e.target.checked });
                });
            }
            
            // Move Straight
            if (moveStraightCheck) {
                moveStraightCheck.addEventListener('change', (e) => {
                    updateParticles({ moveStraight: e.target.checked });
                });
            }
            
            // Move Out Mode
            if (moveOutModeSelect) {
                moveOutModeSelect.addEventListener('change', (e) => {
                    updateParticles({ moveOutMode: e.target.value });
                });
            }
            
            // Move Bounce
            if (moveBounceCheck) {
                moveBounceCheck.addEventListener('change', (e) => {
                    updateParticles({ moveBounce: e.target.checked });
                });
            }
            
            // Hover Enable
            if (hoverEnableCheck) {
                hoverEnableCheck.addEventListener('change', (e) => {
                    updateParticles({ hoverEnable: e.target.checked });
                });
            }
            
            // Hover Mode
            if (hoverModeSelect) {
                hoverModeSelect.addEventListener('change', (e) => {
                    updateParticles({ hoverMode: e.target.value });
                });
            }
            
            // Click Enable
            if (clickEnableCheck) {
                clickEnableCheck.addEventListener('change', (e) => {
                    updateParticles({ clickEnable: e.target.checked });
                });
            }
            
            // Click Mode
            if (clickModeSelect) {
                clickModeSelect.addEventListener('change', (e) => {
                    updateParticles({ clickMode: e.target.value });
                });
            }
            
            // Repulse Distance
            if (repulseDistanceSlider && repulseDistanceValue) {
                repulseDistanceSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    repulseDistanceValue.textContent = value;
                    updateParticles({ repulseDistance: value });
                });
            }
            
            // Reset button
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    // Reset all controls to defaults
                    if (numberSlider) { numberSlider.value = 80; numberValue.textContent = '80'; }
                    if (colorPicker) { colorPicker.value = '#ffffff'; }
                    if (shapePicker) { shapePicker.value = 'circle'; }
                    if (sizeSlider) { sizeSlider.value = 3; sizeValue.textContent = '3'; }
                    if (sizeRandomCheck) { sizeRandomCheck.checked = true; }
                    if (sizeAnimCheck) { sizeAnimCheck.checked = true; }
                    if (sizeAnimSpeedSlider) { sizeAnimSpeedSlider.value = 3; sizeAnimSpeedValue.textContent = '3'; }
                    if (opacitySlider) { opacitySlider.value = 0.7; opacityValue.textContent = '0.7'; }
                    if (opacityRandomCheck) { opacityRandomCheck.checked = true; }
                    if (opacityAnimCheck) { opacityAnimCheck.checked = true; }
                    
                    if (lineEnableCheck) { lineEnableCheck.checked = true; }
                    if (lineColorPicker) { lineColorPicker.value = '#ffffff'; }
                    if (lineDistanceSlider) { lineDistanceSlider.value = 150; lineDistanceValue.textContent = '150'; }
                    if (lineOpacitySlider) { lineOpacitySlider.value = 0.4; lineOpacityValue.textContent = '0.4'; }
                    if (lineWidthSlider) { lineWidthSlider.value = 1; lineWidthValue.textContent = '1'; }
                    
                    if (moveEnableCheck) { moveEnableCheck.checked = true; }
                    if (moveSpeedSlider) { moveSpeedSlider.value = 6; moveSpeedValue.textContent = '6'; }
                    if (moveDirectionSelect) { moveDirectionSelect.value = 'none'; }
                    if (moveRandomCheck) { moveRandomCheck.checked = false; }
                    if (moveStraightCheck) { moveStraightCheck.checked = false; }
                    if (moveOutModeSelect) { moveOutModeSelect.value = 'out'; }
                    if (moveBounceCheck) { moveBounceCheck.checked = false; }
                    
                    if (hoverEnableCheck) { hoverEnableCheck.checked = true; }
                    if (hoverModeSelect) { hoverModeSelect.value = 'repulse'; }
                    if (clickEnableCheck) { clickEnableCheck.checked = true; }
                    if (clickModeSelect) { clickModeSelect.value = 'push'; }
                    if (repulseDistanceSlider) { repulseDistanceSlider.value = 200; repulseDistanceValue.textContent = '200'; }
                    
                    // Reinitialize particles with defaults
                    updateParticles({
                        count: 80,
                        particleColor: '#ffffff',
                        shape: 'circle',
                        size: 3,
                        sizeRandom: true,
                        sizeAnim: true,
                        sizeAnimSpeed: 3,
                        opacity: 0.7,
                        opacityRandom: true,
                        opacityAnim: true,
                        lineEnable: true,
                        lineColor: '#ffffff',
                        lineDistance: 150,
                        lineOpacity: 0.4,
                        lineWidth: 1,
                        moveEnable: true,
                        speed: 6,
                        moveDirection: 'none',
                        moveRandom: false,
                        moveStraight: false,
                        moveOutMode: 'out',
                        moveBounce: false,
                        hoverEnable: true,
                        hoverMode: 'repulse',
                        clickEnable: true,
                        clickMode: 'push',
                        repulseDistance: 200
                    });
                    
                    playSound('active');
                });
            }
        }

        function updateParticles(config) {
            if (!window.pJSDom || !window.pJSDom[0]) return;
            
            const pJS = window.pJSDom[0].pJS;
            
            // Update particle count
            if (config.count !== undefined) {
                pJS.particles.number.value = config.count;
                pJS.fn.particlesRefresh();
            }
            
            // Update particle color
            if (config.particleColor !== undefined) {
                pJS.particles.color.value = config.particleColor;
                pJS.particles.array.forEach(p => {
                    p.color.value = config.particleColor;
                });
            }
            
            // Update shape
            if (config.shape !== undefined) {
                pJS.particles.shape.type = config.shape;
                pJS.fn.particlesRefresh();
            }
            
            // Update particle size
            if (config.size !== undefined) {
                pJS.particles.size.value = config.size;
                pJS.particles.array.forEach(p => {
                    p.radius = config.size;
                });
            }
            
            // Update size random
            if (config.sizeRandom !== undefined) {
                pJS.particles.size.random = config.sizeRandom;
            }
            
            // Update size animation
            if (config.sizeAnim !== undefined) {
                pJS.particles.size.anim.enable = config.sizeAnim;
            }
            
            // Update size animation speed
            if (config.sizeAnimSpeed !== undefined) {
                pJS.particles.size.anim.speed = config.sizeAnimSpeed;
            }
            
            // Update opacity
            if (config.opacity !== undefined) {
                pJS.particles.opacity.value = config.opacity;
            }
            
            // Update opacity random
            if (config.opacityRandom !== undefined) {
                pJS.particles.opacity.random = config.opacityRandom;
            }
            
            // Update opacity animation
            if (config.opacityAnim !== undefined) {
                pJS.particles.opacity.anim.enable = config.opacityAnim;
            }
            
            // Update line enable
            if (config.lineEnable !== undefined) {
                pJS.particles.line_linked.enable = config.lineEnable;
            }
            
            // Update line color
            if (config.lineColor !== undefined) {
                pJS.particles.line_linked.color = config.lineColor;
            }
            
            // Update line distance
            if (config.lineDistance !== undefined) {
                pJS.particles.line_linked.distance = config.lineDistance;
            }
            
            // Update line opacity
            if (config.lineOpacity !== undefined) {
                pJS.particles.line_linked.opacity = config.lineOpacity;
            }
            
            // Update line width
            if (config.lineWidth !== undefined) {
                pJS.particles.line_linked.width = config.lineWidth;
            }
            
            // Update move enable
            if (config.moveEnable !== undefined) {
                pJS.particles.move.enable = config.moveEnable;
            }
            
            // Update move speed
            if (config.speed !== undefined) {
                pJS.particles.move.speed = config.speed;
                pJS.particles.array.forEach(p => {
                    const angle = p.vs || 0;
                    p.vx = Math.cos(angle) * config.speed;
                    p.vy = Math.sin(angle) * config.speed;
                });
            }
            
            // Update move direction
            if (config.moveDirection !== undefined) {
                pJS.particles.move.direction = config.moveDirection;
            }
            
            // Update move random
            if (config.moveRandom !== undefined) {
                pJS.particles.move.random = config.moveRandom;
            }
            
            // Update move straight
            if (config.moveStraight !== undefined) {
                pJS.particles.move.straight = config.moveStraight;
            }
            
            // Update move out mode
            if (config.moveOutMode !== undefined) {
                pJS.particles.move.out_mode = config.moveOutMode;
            }
            
            // Update move bounce
            if (config.moveBounce !== undefined) {
                pJS.particles.move.bounce = config.moveBounce;
            }
            
            // Update hover enable
            if (config.hoverEnable !== undefined) {
                pJS.interactivity.events.onhover.enable = config.hoverEnable;
            }
            
            // Update hover mode
            if (config.hoverMode !== undefined) {
                pJS.interactivity.events.onhover.mode = config.hoverMode;
            }
            
            // Update click enable
            if (config.clickEnable !== undefined) {
                pJS.interactivity.events.onclick.enable = config.clickEnable;
            }
            
            // Update click mode
            if (config.clickMode !== undefined) {
                pJS.interactivity.events.onclick.mode = config.clickMode;
            }
            
            // Update repulse distance
            if (config.repulseDistance !== undefined) {
                pJS.interactivity.modes.repulse.distance = config.repulseDistance;
            }
        }

        function setupMobilePanelDrag() {
            // Add tap-and-hold drag for ALL panels on mobile/touch devices (minimized OR maximized)
            const panels = document.querySelectorAll('.panel, #omnikeys-panel, #help-panel, #particle-panel, #inspector-panel, #view-panel, #myspace-grid-panel, #cube-face-panel');
            
            panels.forEach(panel => {
                let holdTimeout;
                let isDragging = false;
                let startX, startY, initialX, initialY;
                
                const panelHeader = panel.querySelector('.panel-header');
                if (!panelHeader) return;
                
                // Touch start
                panelHeader.addEventListener('touchstart', (e) => {
                    // Don't interfere with panel buttons
                    if (e.target.classList.contains('panel-btn')) return;
                    
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                    
                    const rect = panel.getBoundingClientRect();
                    initialX = rect.left;
                    initialY = rect.top;
                    
                    // Wait 500ms for tap-and-hold
                    holdTimeout = setTimeout(() => {
                        isDragging = true;
                        panel.style.transition = 'none';
                        panelHeader.style.cursor = 'grabbing';
                        // Visual feedback - slight opacity change
                        panel.style.opacity = '0.9';
                    }, 500);
                });
                
                // Touch move
                panelHeader.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    
                    e.preventDefault();
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - startX;
                    const deltaY = touch.clientY - startY;
                    
                    panel.style.left = (initialX + deltaX) + 'px';
                    panel.style.top = (initialY + deltaY) + 'px';
                });
                
                // Touch end
                panelHeader.addEventListener('touchend', () => {
                    clearTimeout(holdTimeout);
                    if (isDragging) {
                        isDragging = false;
                        panel.style.transition = '';
                        panelHeader.style.cursor = '';
                        panel.style.opacity = '';
                    }
                });
                
                // Touch cancel
                panelHeader.addEventListener('touchcancel', () => {
                    clearTimeout(holdTimeout);
                    isDragging = false;
                    panel.style.transition = '';
                    panelHeader.style.cursor = '';
                    panel.style.opacity = '';
                });
            });
        }

        function getCurrentKey() {
            return omniKeyboardCubes.find(cube => 
                cube.userData.rowIndex === omniKeyboardCurrentRow &&
                cube.userData.colIndex === omniKeyboardCurrentCol
            );
        }

        function makeKeyJump(pressedKey) {
            // Find the cube that matches the pressed key
            const keyCube = omniKeyboardCubes.find(cube => {
                const label = cube.userData.label;
                // Match key (handle special cases)
                if (pressedKey.toUpperCase() === label || 
                    pressedKey === label ||
                    (pressedKey === ' ' && label === 'SPC') ||
                    (pressedKey === 'Enter' && label === '') ||
                    (pressedKey === 'Tab' && label === 'TAB') ||
                    (pressedKey === 'CapsLock' && label === '') ||
                    (pressedKey === 'Shift' && (label === 'LSH' || label === 'RSH')) ||
                    (pressedKey === 'Escape' && label === 'ESC')) {
                    return true;
                }
                return false;
            });
            
            if (keyCube) {
                // Animate jump using GSAP
                const originalY = keyCube.position.y;
                gsap.to(keyCube.position, {
                    y: originalY + 0.3,
                    duration: 0.1,
                    yoyo: true,
                    repeat: 1,
                    ease: 'power1.out'
                });
                
                // Flash emissive
                if (keyCube.material && Array.isArray(keyCube.material)) {
                    keyCube.material.forEach(mat => {
                        if (mat.emissiveIntensity !== undefined) {
                            const originalIntensity = mat.emissiveIntensity;
                            gsap.to(mat, {
                                emissiveIntensity: 1.0,
                                duration: 0.1,
                                yoyo: true,
                                repeat: 1,
                                onComplete: () => {
                                    mat.emissiveIntensity = originalIntensity;
                                }
                            });
                        }
                    });
                }
            }
        }

        function rotateKeyCube(keyCube, axis, angle) {
            if (!keyCube) return;
            
            // Smooth rotation animation with GSAP
            const duration = 0.3;
            if (axis === 'x') {
                gsap.to(keyCube.rotation, {
                    x: keyCube.rotation.x + angle,
                    duration: duration,
                    ease: 'power2.out'
                });
            } else if (axis === 'y') {
                gsap.to(keyCube.rotation, {
                    y: keyCube.rotation.y + angle,
                    duration: duration,
                    ease: 'power2.out'
                });
            } else if (axis === 'z') {
                gsap.to(keyCube.rotation, {
                    z: keyCube.rotation.z + angle,
                    duration: duration,
                    ease: 'power2.out'
                });
            }
        }

        function updateInspectorWithKeyInfo(keyCube) {
            const inspectorPanel = document.getElementById('inspector-panel');
            if (!inspectorPanel) return;
            
            const titleElement = inspectorPanel.querySelector('.panel-title');
            if (titleElement) {
                const label = keyCube.userData.label;
                titleElement.textContent = `MNIKEY: ${label}`;
            }
        }

        function rebuildOmniKeyboard() {
            if (!omniKeyboardGroup) return;
            
            console.log('mniKeyboard: Rebuilding with new spacing');
            
            // Remove old keyboard from camera
            camera.remove(omniKeyboardGroup);
            
            // Clear cubes array
            omniKeyboardCubes.forEach(cube => {
                // Remove from interactive objects
                const index = interactiveObjects.indexOf(cube);
                if (index > -1) {
                    interactiveObjects.splice(index, 1);
                }
            });
            omniKeyboardCubes = [];
            
            // Dispose of old group
            omniKeyboardGroup.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
            omniKeyboardGroup = null;
            
            // Create new keyboard with current settings
            createOmniKeyboard();
            
            // Make it visible if it was visible before
            if (omniKeyboardVisible && omniKeyboardGroup) {
                omniKeyboardGroup.visible = true;
            }
        }

        let omniKeysControlsInitialized = false;
        function setupOmniKeysControlPanel() {
            if (omniKeysControlsInitialized) return;
            omniKeysControlsInitialized = true;
            
            console.log('mniKeyboard: Setting up control panel');
            
            // Position controls
            const posX = document.getElementById('kb-pos-x');
            const posY = document.getElementById('kb-pos-y');
            const posZ = document.getElementById('kb-pos-z');
            const posXValue = document.getElementById('kb-pos-x-value');
            const posYValue = document.getElementById('kb-pos-y-value');
            const posZValue = document.getElementById('kb-pos-z-value');
            
            if (posX) {
                posX.addEventListener('input', (e) => {
                    omniKeyboardOffsetX = parseFloat(e.target.value);
                    posXValue.textContent = omniKeyboardOffsetX.toFixed(2);
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.position.x = omniKeyboardOffsetX;
                    }
                });
            }
            
            if (posY) {
                posY.addEventListener('input', (e) => {
                    omniKeyboardOffsetY = parseFloat(e.target.value);
                    posYValue.textContent = omniKeyboardOffsetY.toFixed(2);
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.position.y = omniKeyboardOffsetY;
                    }
                });
            }
            
            if (posZ) {
                posZ.addEventListener('input', (e) => {
                    omniKeyboardOffsetZ = parseFloat(e.target.value);
                    posZValue.textContent = omniKeyboardOffsetZ.toFixed(2);
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.position.z = omniKeyboardOffsetZ;
                    }
                });
            }
            
            // Rotation controls
            const rotX = document.getElementById('kb-rot-x');
            const rotY = document.getElementById('kb-rot-y');
            const rotZ = document.getElementById('kb-rot-z');
            const rotXValue = document.getElementById('kb-rot-x-value');
            const rotYValue = document.getElementById('kb-rot-y-value');
            const rotZValue = document.getElementById('kb-rot-z-value');
            
            if (rotX) {
                rotX.addEventListener('input', (e) => {
                    omniKeyboardRotationX = parseFloat(e.target.value);
                    rotXValue.textContent = omniKeyboardRotationX.toFixed(2);
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.rotation.x = omniKeyboardRotationX;
                    }
                });
            }
            
            if (rotY) {
                rotY.addEventListener('input', (e) => {
                    omniKeyboardRotationY = parseFloat(e.target.value);
                    rotYValue.textContent = omniKeyboardRotationY.toFixed(2);
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.rotation.y = omniKeyboardRotationY;
                    }
                });
            }
            
            if (rotZ) {
                rotZ.addEventListener('input', (e) => {
                    omniKeyboardRotationZ = parseFloat(e.target.value);
                    rotZValue.textContent = omniKeyboardRotationZ.toFixed(2);
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.rotation.z = omniKeyboardRotationZ;
                    }
                });
            }
            
            // Scale control
            const scale = document.getElementById('kb-scale');
            const scaleValue = document.getElementById('kb-scale-value');
            
            if (scale) {
                scale.addEventListener('input', (e) => {
                    omniKeyboardScaleUniform = parseFloat(e.target.value);
                    scaleValue.textContent = omniKeyboardScaleUniform.toFixed(2);
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.scale.set(omniKeyboardScaleUniform, omniKeyboardScaleUniform, omniKeyboardScaleUniform);
                    }
                });
            }
            
            // Spacing controls
            const spacing = document.getElementById('kb-spacing');
            const spacingValue = document.getElementById('kb-spacing-value');
            const rowSpacing = document.getElementById('kb-row-spacing');
            const rowSpacingValue = document.getElementById('kb-row-spacing-value');
            
            if (spacing) {
                spacing.addEventListener('input', (e) => {
                    omniKeyboardSpacing = parseFloat(e.target.value);
                    spacingValue.textContent = omniKeyboardSpacing.toFixed(2);
                    // Rebuild keyboard with new spacing
                    rebuildOmniKeyboard();
                });
            }
            
            if (rowSpacing) {
                rowSpacing.addEventListener('input', (e) => {
                    omniKeyboardRowSpacing = parseFloat(e.target.value);
                    rowSpacingValue.textContent = omniKeyboardRowSpacing.toFixed(2);
                    // Rebuild keyboard with new spacing
                    rebuildOmniKeyboard();
                });
            }
            
            // Reset buttons
            const resetPosition = document.getElementById('kb-reset-position');
            const resetRotation = document.getElementById('kb-reset-rotation');
            const resetAll = document.getElementById('kb-reset-all');
            
            if (resetPosition) {
                resetPosition.addEventListener('click', () => {
                    omniKeyboardOffsetX = 0;
                    omniKeyboardOffsetY = -1.50;
                    omniKeyboardOffsetZ = -8.60;
                    
                    posX.value = 0;
                    posY.value = -1.5;
                    posZ.value = -8.6;
                    posXValue.textContent = '0.00';
                    posYValue.textContent = '-1.50';
                    posZValue.textContent = '-8.60';
                    
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.position.set(0, -1.50, -8.60);
                    }
                    playSound('active');
                });
            }
            
            if (resetRotation) {
                resetRotation.addEventListener('click', () => {
                    omniKeyboardRotationX = 0.90;
                    omniKeyboardRotationY = 0;
                    omniKeyboardRotationZ = 0;
                    
                    rotX.value = 0.9;
                    rotY.value = 0;
                    rotZ.value = 0;
                    rotXValue.textContent = '0.90';
                    rotYValue.textContent = '0.00';
                    rotZValue.textContent = '0.00';
                    
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.rotation.set(0.90, 0, 0);
                    }
                    playSound('active');
                });
            }
            
            if (resetAll) {
                resetAll.addEventListener('click', () => {
                    // Reset position
                    omniKeyboardOffsetX = 0;
                    omniKeyboardOffsetY = -1.50;
                    omniKeyboardOffsetZ = -8.60;
                    posX.value = 0;
                    posY.value = -1.5;
                    posZ.value = -8.6;
                    posXValue.textContent = '0.00';
                    posYValue.textContent = '-1.50';
                    posZValue.textContent = '-8.60';
                    
                    // Reset rotation
                    omniKeyboardRotationX = 0.90;
                    omniKeyboardRotationY = 0;
                    omniKeyboardRotationZ = 0;
                    rotX.value = 0.9;
                    rotY.value = 0;
                    rotZ.value = 0;
                    rotXValue.textContent = '0.90';
                    rotYValue.textContent = '0.00';
                    rotZValue.textContent = '0.00';
                    
                    // Reset scale
                    omniKeyboardScaleUniform = 0.20;
                    scale.value = 0.2;
                    scaleValue.textContent = '0.20';
                    
                    // Reset spacing
                    omniKeyboardSpacing = 2.60;
                    omniKeyboardRowSpacing = 3.20;
                    spacing.value = 2.6;
                    rowSpacing.value = 3.2;
                    spacingValue.textContent = '2.60';
                    rowSpacingValue.textContent = '3.20';
                    
                    if (omniKeyboardGroup) {
                        omniKeyboardGroup.position.set(0, -1.50, -8.60);
                        omniKeyboardGroup.rotation.set(0.90, 0, 0);
                        omniKeyboardGroup.scale.set(0.20, 0.20, 0.20);
                    }
                    
                    // Rebuild keyboard with default spacing
                    rebuildOmniKeyboard();
                    
                    playSound('active');
                });
            }
            
            // Still Mode checkbox
            const stillModeCheckbox = document.getElementById('kb-still-mode');
            if (stillModeCheckbox) {
                stillModeCheckbox.addEventListener('change', (e) => {
                    omniKeyboardStillMode = e.target.checked;
                    console.log('Still Mode:', omniKeyboardStillMode ? 'ON' : 'OFF');
                    playSound('passive');
                });
            }
            
            // Submit button for Entity and Function
            const submitBtn = document.getElementById('key-submit-btn');
            if (submitBtn) {
                submitBtn.addEventListener('click', () => {
                    const currentKey = getCurrentKey();
                    if (!currentKey) {
                        console.log('No key selected');
                        playSound('passive');
                        return;
                    }
                    
                    const entityField = document.getElementById('key-entity');
                    const functionField = document.getElementById('key-function');
                    
                    if (entityField && functionField) {
                        // Save to cube userData
                        currentKey.userData.entity = entityField.value;
                        currentKey.userData.function = functionField.value;
                        
                        console.log(`Updated key ${currentKey.userData.label}:`);
                        console.log('  Entity:', currentKey.userData.entity);
                        console.log('  Function:', currentKey.userData.function);
                        
                        // Visual feedback - flash the cube
                        if (currentKey.material && Array.isArray(currentKey.material)) {
                            currentKey.material.forEach(mat => {
                                if (mat.emissiveIntensity !== undefined) {
                                    const originalIntensity = mat.emissiveIntensity;
                                    gsap.to(mat, {
                                        emissiveIntensity: 1.5,
                                        duration: 0.15,
                                        yoyo: true,
                                        repeat: 1,
                                        onComplete: () => {
                                            mat.emissiveIntensity = originalIntensity;
                                        }
                                    });
                                }
                            });
                        }
                        
                        playSound('active');
                    }
                });
            }
            
            // Panel controls
            const minimizeBtn = document.getElementById('omnikeys-minimize-btn');
            const closeBtn = document.getElementById('omnikeys-close-btn');
            const panelHeader = document.getElementById('omnikeys-panel-header');
            const panelContent = document.getElementById('omnikeys-panel-content');
            const panel = document.getElementById('omnikeys-panel');
            
            if (minimizeBtn && panelContent && panel) {
                minimizeBtn.addEventListener('click', () => {
                    panel.classList.toggle('minimized');
                    panelContent.classList.toggle('hidden');
                    playSound('passive');
                });
            }
            
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    toggleOmniKeyboard();
                    playSound('passive');
                });
            }
            
            // Make panel header draggable
            if (panelHeader && panel) {
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                
                panelHeader.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('panel-btn')) return;
                    isDragging = true;
                    initialX = e.clientX - panel.offsetLeft;
                    initialY = e.clientY - panel.offsetTop;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        panel.style.left = currentX + 'px';
                        panel.style.top = currentY + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            // Resize handle
            const resizeHandle = document.getElementById('omnikeys-resize-handle');
            if (resizeHandle && panel) {
                let isResizing = false;
                let startWidth, startHeight, startX, startY;
                
                resizeHandle.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = parseInt(window.getComputedStyle(panel).width, 10);
                    startHeight = parseInt(window.getComputedStyle(panel).height, 10);
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isResizing) {
                        const width = startWidth + (e.clientX - startX);
                        const height = startHeight + (e.clientY - startY);
                        panel.style.width = Math.max(250, width) + 'px';
                        panel.style.height = Math.max(200, height) + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isResizing = false;
                });
            }
        }

        function handleCubeFaceClick(face) {
            const faceName = face.userData.faceName;
            cubeClickedFace = faceName;
            
            console.log('Clicked cube face:', faceName);
            
            // Make edges pulse faster and brighter
            cubePulseSpeed = 3.0; // Faster pulsing
            
            // Brighten clicked face edges
            if (cubeEdges) {
                cubeEdges.children.forEach((edge) => {
                    edge.material.opacity = 1.0;
                });
            }
            
            // Show panel with face content
            const panel = document.getElementById('cube-face-panel');
            const title = document.getElementById('cube-face-title');
            const content = document.getElementById('cube-face-content');
            
            // Set title based on face
            const faceTitles = {
                'top': 'MYSPACE GRID CONTROLS',
                'front': 'MYSPACE BEHAVIOR CONTROLS',
                'right': 'MYSPACE ROTATION CONTROLS',
                'left': 'MANUAL TRANSFORM CONTROLS',
                'bottom': 'CUBE FACE (BLANK)',
                'back': 'CUBE FACE (BLANK)'
            };
            
            title.textContent = faceTitles[faceName] || 'CUBE FACE';
            
            // Load face-specific content
            content.innerHTML = getCubeFaceContent(faceName);
            
            // Show panel
            panel.style.display = 'block';
            panel.classList.remove('minimized');
            
            // Attach event listeners for new content
            attachCubeFaceHandlers(faceName);
        }
        
        function getCubeFaceContent(faceName) {
            switch(faceName) {
                case 'top':
                    return `
                        <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7); margin-bottom: 16px;">
                            Control MySpace grid configuration and layout
                        </div>
                        
                        <!-- Grid Type -->
                        <div style="margin-bottom: 16px;">
                            <div style="font-weight: 600; margin-bottom: 8px; font-size: 12px;">Grid Type</div>
                            <select id="cube-grid-type" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 6px; color: #fff; font-family: 'Orbitron', sans-serif;">
                                <option value="spherical">Spherical</option>
                                <option value="cube">Cube</option>
                                <option value="cylinder">Cylinder</option>
                                <option value="grid">Flat Grid</option>
                            </select>
                        </div>
                        
                        <!-- Segments -->
                        <div style="margin-bottom: 16px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="font-weight: 600; font-size: 12px;">Segments</span>
                                <span id="cube-segments-value" style="font-family: 'Courier New', monospace; color: rgba(255, 255, 255, 0.7);">8</span>
                            </div>
                            <input type="range" id="cube-segments" min="4" max="16" value="8" step="1" style="width: 100%;">
                        </div>
                        
                        <!-- Radius -->
                        <div style="margin-bottom: 16px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="font-weight: 600; font-size: 12px;">Radius</span>
                                <span id="cube-radius-value" style="font-family: 'Courier New', monospace; color: rgba(255, 255, 255, 0.7);">25</span>
                            </div>
                            <input type="range" id="cube-radius" min="10" max="50" value="25" step="1" style="width: 100%;">
                        </div>
                        
                        <button id="cube-apply-grid" class="update-btn" style="width: 100%; padding: 12px; margin-top: 12px;"> APPLY GRID</button>
                    `;
                    
                case 'front':
                    return `
                        <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7); margin-bottom: 16px;">
                            Control MySpace sphere behavior and visibility
                        </div>
                        
                        <!-- Expand/Collapse -->
                        <div style="margin-bottom: 16px;">
                            <button id="cube-toggle-myspace" class="active" style="width: 100%; padding: 12px; background: rgba(0, 255, 0, 0.3); border: 1px solid rgba(0, 255, 0, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600;">
                                 EXPANDED
                            </button>
                        </div>
                        
                        <!-- Visibility Toggle -->
                        <div style="margin-bottom: 16px;">
                            <button id="cube-toggle-visibility" class="active" style="width: 100%; padding: 12px; background: rgba(0, 255, 0, 0.3); border: 1px solid rgba(0, 255, 0, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600;">
                                 VISIBLE
                            </button>
                        </div>
                        
                        <!-- Grid Visibility -->
                        <div style="margin-bottom: 16px;">
                            <button id="cube-toggle-grid-visibility" class="active" style="width: 100%; padding: 12px; background: rgba(0, 255, 0, 0.3); border: 1px solid rgba(0, 255, 0, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600;">
                                 GRID VISIBLE
                            </button>
                        </div>
                    `;
                    
                case 'right':
                    return `
                        <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7); margin-bottom: 16px;">
                            Control MySpace sphere rotation on each axis
                        </div>
                        
                        <!-- X Axis Rotation -->
                        <div style="margin-bottom: 16px;">
                            <button id="cube-rotate-x" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600;">
                                ROTATE X-AXIS
                            </button>
                        </div>
                        
                        <!-- Y Axis Rotation -->
                        <div style="margin-bottom: 16px;">
                            <button id="cube-rotate-y" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600;">
                                ROTATE Y-AXIS
                            </button>
                        </div>
                        
                        <!-- Z Axis Rotation -->
                        <div style="margin-bottom: 16px;">
                            <button id="cube-rotate-z" style="width: 100%; padding: 12px; background: rgba(128, 128, 128, 0.3); border: 1px solid rgba(128, 128, 128, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600;">
                                ROTATE Z-AXIS
                            </button>
                        </div>
                        
                        <!-- Stop All Rotation -->
                        <div style="margin-bottom: 16px;">
                            <button id="cube-stop-rotation" style="width: 100%; padding: 12px; background: rgba(255, 0, 0, 0.3); border: 1px solid rgba(255, 0, 0, 0.5); border-radius: 8px; color: #fff; cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 600;">
                                STOP ALL ROTATION
                            </button>
                        </div>
                    `;
                    
                case 'left':
                    return `
                        <div style="font-size: 11px; color: rgba(255, 255, 255, 0.7); margin-bottom: 16px;">
                            Manually adjust MySpace position, rotation, and scale
                        </div>
                        
                        <!-- Position Controls -->
                        <div style="margin-bottom: 20px;">
                            <div style="font-weight: 600; margin-bottom: 12px; font-size: 12px; color: rgba(255, 255, 255, 0.9);">Position</div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 11px;">X</span>
                                    <span id="cube-pos-x-value" style="font-family: 'Courier New', monospace; font-size: 11px;">0</span>
                                </div>
                                <input type="range" id="cube-pos-x" min="-100" max="100" value="0" step="1" style="width: 100%;">
                            </div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 11px;">Y</span>
                                    <span id="cube-pos-y-value" style="font-family: 'Courier New', monospace; font-size: 11px;">30</span>
                                </div>
                                <input type="range" id="cube-pos-y" min="0" max="200" value="30" step="1" style="width: 100%;">
                            </div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 11px;">Z</span>
                                    <span id="cube-pos-z-value" style="font-family: 'Courier New', monospace; font-size: 11px;">0</span>
                                </div>
                                <input type="range" id="cube-pos-z" min="-100" max="100" value="0" step="1" style="width: 100%;">
                            </div>
                        </div>
                        
                        <!-- Rotation Controls -->
                        <div style="margin-bottom: 20px;">
                            <div style="font-weight: 600; margin-bottom: 12px; font-size: 12px; color: rgba(255, 255, 255, 0.9);">Rotation (degrees)</div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 11px;">X</span>
                                    <span id="cube-rot-x-value" style="font-family: 'Courier New', monospace; font-size: 11px;">0</span>
                                </div>
                                <input type="range" id="cube-rot-x" min="0" max="360" value="0" step="1" style="width: 100%;">
                            </div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 11px;">Y</span>
                                    <span id="cube-rot-y-value" style="font-family: 'Courier New', monospace; font-size: 11px;">0</span>
                                </div>
                                <input type="range" id="cube-rot-y" min="0" max="360" value="0" step="1" style="width: 100%;">
                            </div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 11px;">Z</span>
                                    <span id="cube-rot-z-value" style="font-family: 'Courier New', monospace; font-size: 11px;">0</span>
                                </div>
                                <input type="range" id="cube-rot-z" min="0" max="360" value="0" step="1" style="width: 100%;">
                            </div>
                        </div>
                        
                        <!-- Scale Controls -->
                        <div style="margin-bottom: 20px;">
                            <div style="font-weight: 600; margin-bottom: 12px; font-size: 12px; color: rgba(255, 255, 255, 0.9);">Scale</div>
                            
                            <div style="margin-bottom: 10px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 6px;">
                                    <span style="font-size: 11px;">Uniform</span>
                                    <span id="cube-scale-value" style="font-family: 'Courier New', monospace; font-size: 11px;">1.0</span>
                                </div>
                                <input type="range" id="cube-scale" min="0.1" max="3" value="1" step="0.1" style="width: 100%;">
                            </div>
                        </div>
                        
                        <button id="cube-apply-transform" class="update-btn" style="width: 100%; padding: 12px;"> APPLY TRANSFORM</button>
                    `;
                    
                default:
                    return `
                        <div style="font-size: 11px; color: rgba(255, 255, 255, 0.5); text-align: center; padding: 40px 20px;">
                            This face is currently blank.<br>
                            Reserved for future features.
                        </div>
                    `;
            }
        }
        
        function attachCubeFaceHandlers(faceName) {
            // Rotation toggle button (always present)
            const rotationToggle = document.getElementById('cube-rotation-toggle');
            if (rotationToggle) {
                rotationToggle.addEventListener('click', () => {
                    cubeRotating = !cubeRotating;
                    rotationToggle.classList.toggle('active');
                    rotationToggle.textContent = cubeRotating ? ' ROTATING' : 'PAUSED';
                    rotationToggle.style.background = cubeRotating ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
                    rotationToggle.style.borderColor = cubeRotating ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
                    playSound('active');
                });
            }
            
            // Face-specific handlers
            switch(faceName) {
                case 'top':
                    // Grid controls handlers
                    const gridTypeSelect = document.getElementById('cube-grid-type');
                    const segmentsSlider = document.getElementById('cube-segments');
                    const radiusSlider = document.getElementById('cube-radius');
                    const applyGridBtn = document.getElementById('cube-apply-grid');
                    
                    if (segmentsSlider) {
                        segmentsSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-segments-value').textContent = e.target.value;
                        });
                    }
                    
                    if (radiusSlider) {
                        radiusSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-radius-value').textContent = e.target.value;
                        });
                    }
                    
                    if (applyGridBtn) {
                        applyGridBtn.addEventListener('click', () => {
                            const gridType = gridTypeSelect?.value || 'spherical';
                            const segments = parseInt(segmentsSlider?.value || 8);
                            const radius = parseInt(radiusSlider?.value || 25);
                            
                            // Call existing createMySpaceGrid function
                            if (typeof createMySpaceGrid === 'function') {
                                createMySpaceGrid(gridType, segments, radius);
                            }
                            
                            playSound('active');
                            console.log('Grid applied:', { gridType, segments, radius });
                        });
                    }
                    break;
                    
                case 'front':
                    // Behavior controls handlers (already handled by existing functions)
                    const toggleMySpaceBtn = document.getElementById('cube-toggle-myspace');
                    const toggleVisibilityBtn = document.getElementById('cube-toggle-visibility');
                    const toggleGridVisBtn = document.getElementById('cube-toggle-grid-visibility');
                    
                    if (toggleMySpaceBtn) {
                        toggleMySpaceBtn.addEventListener('click', () => {
                            if (typeof toggleMySpace === 'function') {
                                toggleMySpace();
                            }
                            playSound('active');
                        });
                    }
                    break;
                    
                case 'right':
                    // Rotation axis controls
                    const rotateXBtn = document.getElementById('cube-rotate-x');
                    const rotateYBtn = document.getElementById('cube-rotate-y');
                    const rotateZBtn = document.getElementById('cube-rotate-z');
                    const stopRotationBtn = document.getElementById('cube-stop-rotation');
                    
                    if (rotateXBtn) {
                        rotateXBtn.addEventListener('click', () => {
                            window.sphereRotateX = !window.sphereRotateX;
                            rotateXBtn.classList.toggle('active');
                            rotateXBtn.textContent = window.sphereRotateX ? ' ROTATE X-AXIS' : 'ROTATE X-AXIS';
                            playSound('active');
                        });
                    }
                    
                    if (rotateYBtn) {
                        rotateYBtn.addEventListener('click', () => {
                            window.sphereRotateY = !window.sphereRotateY;
                            rotateYBtn.classList.toggle('active');
                            rotateYBtn.textContent = window.sphereRotateY ? ' ROTATE Y-AXIS' : 'ROTATE Y-AXIS';
                            playSound('active');
                        });
                    }
                    
                    if (rotateZBtn) {
                        rotateZBtn.addEventListener('click', () => {
                            window.sphereRotateZ = !window.sphereRotateZ;
                            rotateZBtn.classList.toggle('active');
                            rotateZBtn.textContent = window.sphereRotateZ ? ' ROTATE Z-AXIS' : 'ROTATE Z-AXIS';
                            playSound('active');
                        });
                    }
                    
                    if (stopRotationBtn) {
                        stopRotationBtn.addEventListener('click', () => {
                            window.sphereRotateX = false;
                            window.sphereRotateY = false;
                            window.sphereRotateZ = false;
                            if (rotateXBtn) rotateXBtn.classList.remove('active');
                            if (rotateYBtn) rotateYBtn.classList.remove('active');
                            if (rotateZBtn) rotateZBtn.classList.remove('active');
                            playSound('active');
                        });
                    }
                    break;
                    
                case 'left':
                    // Manual transform controls
                    const posXSlider = document.getElementById('cube-pos-x');
                    const posYSlider = document.getElementById('cube-pos-y');
                    const posZSlider = document.getElementById('cube-pos-z');
                    const rotXSlider = document.getElementById('cube-rot-x');
                    const rotYSlider = document.getElementById('cube-rot-y');
                    const rotZSlider = document.getElementById('cube-rot-z');
                    const scaleSlider = document.getElementById('cube-scale');
                    const applyTransformBtn = document.getElementById('cube-apply-transform');
                    
                    // Position sliders
                    if (posXSlider) {
                        posXSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-pos-x-value').textContent = e.target.value;
                        });
                    }
                    if (posYSlider) {
                        posYSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-pos-y-value').textContent = e.target.value;
                        });
                    }
                    if (posZSlider) {
                        posZSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-pos-z-value').textContent = e.target.value;
                        });
                    }
                    
                    // Rotation sliders
                    if (rotXSlider) {
                        rotXSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-rot-x-value').textContent = e.target.value + '';
                        });
                    }
                    if (rotYSlider) {
                        rotYSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-rot-y-value').textContent = e.target.value + '';
                        });
                    }
                    if (rotZSlider) {
                        rotZSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-rot-z-value').textContent = e.target.value + '';
                        });
                    }
                    
                    // Scale slider
                    if (scaleSlider) {
                        scaleSlider.addEventListener('input', (e) => {
                            document.getElementById('cube-scale-value').textContent = parseFloat(e.target.value).toFixed(1);
                        });
                    }
                    
                    // Apply transform button
                    if (applyTransformBtn) {
                        applyTransformBtn.addEventListener('click', () => {
                            const posX = parseFloat(posXSlider?.value || 0);
                            const posY = parseFloat(posYSlider?.value || 30);
                            const posZ = parseFloat(posZSlider?.value || 0);
                            const rotX = parseFloat(rotXSlider?.value || 0) * Math.PI / 180;
                            const rotY = parseFloat(rotYSlider?.value || 0) * Math.PI / 180;
                            const rotZ = parseFloat(rotZSlider?.value || 0) * Math.PI / 180;
                            const scale = parseFloat(scaleSlider?.value || 1);
                            
                            if (mySpaceGroup) {
                                mySpaceGroup.position.set(posX, posY, posZ);
                                mySpaceGroup.rotation.set(rotX, rotY, rotZ);
                                mySpaceGroup.scale.set(scale, scale, scale);
                            }
                            
                            playSound('active');
                            console.log('Transform applied:', { position: [posX, posY, posZ], rotation: [rotX, rotY, rotZ], scale });
                        });
                    }
                    break;
            }
        }

        let keyboardVisible = false;

        function toggleVirtualKeyboard() {
            keyboardVisible = !keyboardVisible;
            const keyboard = document.getElementById('virtual-keyboard');
            
            if (keyboardVisible) {
                keyboard.classList.add('visible');
            } else {
                keyboard.classList.remove('visible');
            }
            
            playSound('passive');
        }

        let actionGridVisible = false;

        function toggleActionGrid() {
            actionGridVisible = !actionGridVisible;
            const actionGrid = document.getElementById('action-grid');
            
            if (actionGridVisible) {
                actionGrid.classList.remove('hidden');
            } else {
                actionGrid.classList.add('hidden');
            }
            
            playSound('passive');
        }

        function initVirtualKeyboard() {
            const keyboard = document.getElementById('virtual-keyboard');
            
            const keys = [
                ['Q', 'W', 'E', 'R', 'F', 'A', 'S', 'D'],
                ['0', '9', 'X', 'Z', 'O', 'C', 'ENTER']
            ];
            
            keys.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                
                row.forEach(key => {
                    const keyBtn = document.createElement('button');
                    keyBtn.className = 'key-btn';
                    if (key === 'ENTER') {
                        keyBtn.classList.add('wide');
                    }
                    keyBtn.textContent = key;
                    
                    keyBtn.addEventListener('click', () => {
                        simulateKeyPress(key);
                        playSound('passive');
                    });
                    
                    rowDiv.appendChild(keyBtn);
                });
                
                keyboard.appendChild(rowDiv);
            });
        }

        function simulateKeyPress(key) {
            const keyMap = {
                'ENTER': 'Enter',
                '0': '0',
                '9': '9'
            };
            
            const eventKey = keyMap[key] || key.toLowerCase();
            
            // Simulate keydown
            const keydownEvent = new KeyboardEvent('keydown', {
                key: eventKey,
                code: 'Key' + key,
                keyCode: key.charCodeAt(0),
                which: key.charCodeAt(0),
                bubbles: true
            });
            window.dispatchEvent(keydownEvent);
            
            // Simulate keyup after short delay
            setTimeout(() => {
                const keyupEvent = new KeyboardEvent('keyup', {
                    key: eventKey,
                    code: 'Key' + key,
                    keyCode: key.charCodeAt(0),
                    which: key.charCodeAt(0),
                    bubbles: true
                });
                window.dispatchEvent(keyupEvent);
            }, 100);
        }

        function setupUITransparency() {
            const slider = document.getElementById('ui-transparency-slider');
            const valueDisplay = document.getElementById('transparency-value');
            
            if (!slider) return;
            
            slider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                valueDisplay.textContent = value + '%';
                
                // Calculate opacity (0 = 5% visible, 100 = 100% visible)
                const minOpacity = 0.05;
                const maxOpacity = 1.0;
                const opacity = minOpacity + (value / 100) * (maxOpacity - minOpacity);
                
                // Apply to all UI elements
                const uiElements = document.querySelectorAll(
                    '.side-menu, #inspector-panel, #info-panel, #search-panel, ' +
                    '.dock, .hamburger-btn, #faq-panel, .prompt-modal, #transform-panel, ' +
                    '.joystick-base, .control-buttons, #action-grid, #virtual-keyboard, ' +
                    '#pocket-panel, .radial-menu'
                );
                
                uiElements.forEach(el => {
                    el.style.opacity = opacity;
                });
                
                playSound('passive');
            });
        }

        function setupParticleBehavior() {
            const panel = document.getElementById('particle-behavior-panel');
            const closeBtn = document.getElementById('particle-behavior-close');
            const modeButtons = document.querySelectorAll('.behavior-mode-btn');
            const forwardControls = document.getElementById('forward-controls');
            const backwardControls = document.getElementById('backward-controls');
            const upwardControls = document.getElementById('upward-controls');
            const downwardControls = document.getElementById('downward-controls');
            const connectedControls = document.getElementById('connected-controls');
            const glitchControls = document.getElementById('glitch-controls');
            const constellationControls = document.getElementById('constellation-controls');
            const forwardSpeedSlider = document.getElementById('forward-speed-slider');
            const backwardSpeedSlider = document.getElementById('backward-speed-slider');
            const upwardSpeedSlider = document.getElementById('upward-speed-slider');
            const downwardSpeedSlider = document.getElementById('downward-speed-slider');
            const connectedFrequencySlider = document.getElementById('connected-frequency-slider');
            const glitchIntensitySlider = document.getElementById('glitch-intensity-slider');
            const constellationDistanceSlider = document.getElementById('constellation-distance-slider');
            const particleCountSlider = document.getElementById('particle-count-slider');
            const forwardSpeedValue = document.getElementById('forward-speed-value');
            const backwardSpeedValue = document.getElementById('backward-speed-value');
            const upwardSpeedValue = document.getElementById('upward-speed-value');
            const downwardSpeedValue = document.getElementById('downward-speed-value');
            const connectedFrequencyValue = document.getElementById('connected-frequency-value');
            const glitchIntensityValue = document.getElementById('glitch-intensity-value');
            const constellationDistanceValue = document.getElementById('constellation-distance-value');
            const particleCountValue = document.getElementById('particle-count-value');
            
            // Close button
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    panel.style.display = 'none';
                    playSound('passive');
                });
            }
            
            // Mode buttons
            modeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.getAttribute('data-mode');
                    
                    // Update active state
                    modeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Update behavior mode
                    particleBehaviorMode = mode;
                    
                    // Show/hide appropriate controls
                    forwardControls.style.display = mode === 'forward' ? 'block' : 'none';
                    backwardControls.style.display = mode === 'backward' ? 'block' : 'none';
                    upwardControls.style.display = mode === 'upward' ? 'block' : 'none';
                    downwardControls.style.display = mode === 'downward' ? 'block' : 'none';
                    connectedControls.style.display = mode === 'connected' ? 'block' : 'none';
                    glitchControls.style.display = mode === 'glitch' ? 'block' : 'none';
                    constellationControls.style.display = mode === 'constellation' ? 'block' : 'none';
                    
                    playSound('active');
                });
            });
            
            // Forward speed slider
            if (forwardSpeedSlider) {
                forwardSpeedSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    forwardSpeedValue.textContent = value;
                    forwardFlowSpeed = value / 100;
                    playSound('passive');
                });
            }
            
            // Backward speed slider
            if (backwardSpeedSlider) {
                backwardSpeedSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    backwardSpeedValue.textContent = value;
                    backwardFlowSpeed = value / 100;
                    playSound('passive');
                });
            }
            
            // Upward speed slider
            if (upwardSpeedSlider) {
                upwardSpeedSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    upwardSpeedValue.textContent = value;
                    upwardFlowSpeed = value / 100;
                    playSound('passive');
                });
            }
            
            // Downward speed slider
            if (downwardSpeedSlider) {
                downwardSpeedSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    downwardSpeedValue.textContent = value;
                    downwardFlowSpeed = value / 100;
                    playSound('passive');
                });
            }
            
            // Connected frequency slider
            if (connectedFrequencySlider) {
                connectedFrequencySlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    connectedFrequencyValue.textContent = value;
                    connectionFrequency = value / 100;
                    playSound('passive');
                });
            }
            
            // Glitch intensity slider
            if (glitchIntensitySlider) {
                glitchIntensitySlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    glitchIntensityValue.textContent = value;
                    glitchIntensity = value / 100;
                    playSound('passive');
                });
            }
            
            // Constellation distance slider
            if (constellationDistanceSlider) {
                constellationDistanceSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    constellationDistanceValue.textContent = value;
                    constellationDistance = value / 10; // Scale 1-100 to 0.1-10
                    playSound('passive');
                });
            }
            
            // Particle count slider
            if (particleCountSlider) {
                particleCountSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    particleCountValue.textContent = value.toLocaleString();
                    // Update particle count (will require reinitializing the particle system)
                    updateParticleCount(value);
                    playSound('passive');
                });
            }
            
            // Particle rotation sliders
            const particleRotXSlider = document.getElementById('particle-rot-x-slider');
            const particleRotYSlider = document.getElementById('particle-rot-y-slider');
            const particleRotZSlider = document.getElementById('particle-rot-z-slider');
            const particleRotXValue = document.getElementById('particle-rot-x-value');
            const particleRotYValue = document.getElementById('particle-rot-y-value');
            const particleRotZValue = document.getElementById('particle-rot-z-value');
            const particleRotReset = document.getElementById('particle-rot-reset');
            
            if (particleRotXSlider) {
                particleRotXSlider.addEventListener('input', (e) => {
                    const degrees = parseInt(e.target.value);
                    particleRotXValue.textContent = degrees + '';
                    if (particleSystem) {
                        particleSystem.rotation.x = degrees * Math.PI / 180;
                    }
                    playSound('passive');
                });
            }
            
            if (particleRotYSlider) {
                particleRotYSlider.addEventListener('input', (e) => {
                    const degrees = parseInt(e.target.value);
                    particleRotYValue.textContent = degrees + '';
                    if (particleSystem) {
                        particleSystem.rotation.y = degrees * Math.PI / 180;
                    }
                    playSound('passive');
                });
            }
            
            if (particleRotZSlider) {
                particleRotZSlider.addEventListener('input', (e) => {
                    const degrees = parseInt(e.target.value);
                    particleRotZValue.textContent = degrees + '';
                    if (particleSystem) {
                        particleSystem.rotation.z = degrees * Math.PI / 180;
                    }
                    playSound('passive');
                });
            }
            
            if (particleRotReset) {
                particleRotReset.addEventListener('click', () => {
                    // Reset to default (0, 0, 71)
                    particleRotXSlider.value = 0;
                    particleRotYSlider.value = 0;
                    particleRotZSlider.value = 71;
                    particleRotXValue.textContent = '0';
                    particleRotYValue.textContent = '0';
                    particleRotZValue.textContent = '71';
                    if (particleSystem) {
                        particleSystem.rotation.set(0, 0, 71 * Math.PI / 180);
                    }
                    playSound('active');
                });
            }
        }

        function updateParticleCount(newCount) {
            if (!particleSystem) return;
            
            // Store old count
            const oldCount = particleCount;
            particleCount = newCount;
            
            // Create new geometry with new particle count
            const newGeometry = new THREE.BufferGeometry();
            const newPositions = new Float32Array(particleCount * 3);
            const newVelocities = new Float32Array(particleCount * 3);
            
            // Initialize new particles
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.sqrt(Math.random()) * 10;
                const z = (Math.random() - 0.5) * 4;
                
                newPositions[i * 3] = Math.cos(angle) * radius;
                newPositions[i * 3 + 1] = Math.sin(angle) * radius;
                newPositions[i * 3 + 2] = z;
                
                newVelocities[i * 3] = (Math.random() - 0.5) * 0.02;
                newVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02;
                newVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
            }
            
            // Update geometry
            newGeometry.setAttribute('position', new THREE.BufferAttribute(newPositions, 3));
            
            // Dispose old geometry
            particleSystem.geometry.dispose();
            
            // Apply new geometry
            particleSystem.geometry = newGeometry;
            
            // Update velocity array
            particleVelocities = newVelocities;
        }

        function setupMySpaceGrid() {
            const panel = document.getElementById('myspace-grid-panel');
            const closeBtn = document.getElementById('myspace-grid-close');
            const gridButtons = document.querySelectorAll('.myspace-grid-btn');
            const gridSizeSlider = document.getElementById('grid-size-slider');
            const gridSpacingSlider = document.getElementById('grid-spacing-slider');
            const gridSizeValue = document.getElementById('grid-size-value');
            const gridSpacingValue = document.getElementById('grid-spacing-value');
            const applyBtn = document.getElementById('apply-grid-btn');
            
            let currentGridType = 'spherical';
            let currentGridSize = 15;
            let currentGridSpacing = 2;
            
            // Close button
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    panel.style.display = 'none';
                    playSound('passive');
                });
            }
            
            // Grid type buttons
            gridButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    currentGridType = btn.getAttribute('data-grid-type');
                    
                    // Update active state
                    gridButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    playSound('active');
                });
            });
            
            // Grid size slider
            if (gridSizeSlider) {
                gridSizeSlider.addEventListener('input', (e) => {
                    currentGridSize = parseInt(e.target.value);
                    gridSizeValue.textContent = currentGridSize;
                    playSound('passive');
                });
            }
            
            // Grid spacing slider
            if (gridSpacingSlider) {
                gridSpacingSlider.addEventListener('input', (e) => {
                    currentGridSpacing = parseFloat(e.target.value);
                    gridSpacingValue.textContent = currentGridSpacing;
                    playSound('passive');
                });
            }
            
            // Apply button
            if (applyBtn) {
                applyBtn.addEventListener('click', () => {
                    // Recreate grid panels with new configuration
                    if (window.createMySpaceGrid) {
                        const radius = currentGridSpacing * 10; // Scale spacing to radius
                        window.createMySpaceGrid(currentGridType, currentGridSize, radius);
                        playSound('active');
                    }
                });
            }
        }

        function setupProfile() {
            const profileImageContainer = document.getElementById('profile-image-container');
            const profileImageInput = document.getElementById('profile-image-input');
            const headerUsername = document.getElementById('header-username');
            const headerDescription = document.getElementById('header-description');
            
            // Load saved profile data
            const savedImage = localStorage.getItem('userProfileImage');
            const savedUsername = localStorage.getItem('userProfileUsername');
            const savedDescription = localStorage.getItem('userProfileDescription');
            
            if (savedImage) {
                profileImageContainer.style.backgroundImage = `url(${savedImage})`;
                profileImageContainer.style.backgroundSize = 'cover';
                profileImageContainer.style.backgroundPosition = 'center';
                profileImageContainer.textContent = '';
            }
            
            if (savedUsername) headerUsername.textContent = savedUsername;
            if (savedDescription) headerDescription.textContent = savedDescription;
            
            // Click to upload image
            profileImageContainer.addEventListener('click', () => {
                profileImageInput.click();
            });
            
            profileImageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const imageData = event.target.result;
                        profileImageContainer.style.backgroundImage = `url(${imageData})`;
                        profileImageContainer.style.backgroundSize = 'cover';
                        profileImageContainer.style.backgroundPosition = 'center';
                        profileImageContainer.textContent = '';
                        localStorage.setItem('userProfileImage', imageData);
                    };
                    reader.readAsDataURL(file);
                }
            });
            
            // Save username on blur
            headerUsername.addEventListener('blur', () => {
                localStorage.setItem('userProfileUsername', headerUsername.textContent);
            });
            
            // Save description on blur
            headerDescription.addEventListener('blur', () => {
                localStorage.setItem('userProfileDescription', headerDescription.textContent);
            });
            
            // Styling on focus
            headerUsername.addEventListener('focus', function() {
                this.style.borderColor = 'rgba(128, 128, 128, 0.5)';
            });
            
            headerUsername.addEventListener('blur', function() {
                this.style.borderColor = 'transparent';
            });
            
            headerDescription.addEventListener('focus', function() {
                this.style.borderColor = 'rgba(128, 128, 128, 0.5)';
            });
            
            headerDescription.addEventListener('blur', function() {
                this.style.borderColor = 'transparent';
            });
        }


        function initPocket() {
            renderPocketPage();
            setupPocketPagination();
        }

        function renderPocketPage() {
            const pocketGrid = document.getElementById('pocket-grid');
            pocketGrid.innerHTML = ''; // Clear existing slots
            
            const startSlot = (currentPocketPage - 1) * slotsPerPage;
            const endSlot = startSlot + slotsPerPage;
            
            // Create 20 pocket slots for current page
            for (let i = startSlot; i < endSlot; i++) {
                const slot = document.createElement('div');
                slot.className = 'pocket-slot empty';
                slot.setAttribute('data-slot', i);
                
                // Slot number
                const slotNumber = document.createElement('div');
                slotNumber.className = 'pocket-slot-number';
                slotNumber.textContent = i + 1;
                slot.appendChild(slotNumber);
                
                // Slot content (icon + text)
                const slotContent = document.createElement('div');
                slotContent.className = 'pocket-slot-content';
                
                const slotIcon = document.createElement('div');
                slotIcon.className = 'pocket-slot-icon';
                slotIcon.textContent = '';
                slotContent.appendChild(slotIcon);
                
                const slotText = document.createElement('div');
                slotText.textContent = 'Empty';
                slotContent.appendChild(slotText);
                
                slot.appendChild(slotContent);
                
                // Click handler
                slot.addEventListener('click', () => {
                    handlePocketSlotClick(i);
                });
                
                pocketGrid.appendChild(slot);
                
                // Update visual state based on existing data
                updatePocketSlot(i);
            }
            
            // Update page info
            document.getElementById('pocket-page-info').textContent = `Page ${currentPocketPage} / ${totalPages}`;
        }

        function setupPocketPagination() {
            const prevBtn = document.getElementById('pocket-prev-page');
            const nextBtn = document.getElementById('pocket-next-page');
            
            prevBtn.addEventListener('click', () => {
                if (currentPocketPage > 1) {
                    currentPocketPage--;
                    renderPocketPage();
                    playSound('passive');
                }
            });
            
            nextBtn.addEventListener('click', () => {
                if (currentPocketPage < totalPages) {
                    currentPocketPage++;
                    renderPocketPage();
                    playSound('passive');
                }
            });
        }

        function handlePocketSlotClick(slotIndex) {
            const slot = pocketItems[slotIndex];
            
            console.log(`Pocket slot ${slotIndex} clicked`);
            playSound('active');
            
            if (!slot.occupied) {
                // Empty slot - could add item here
                console.log('Empty slot - ready to add item');
            } else if (slot.deployed) {
                // Item is deployed in scene - recall it
                console.log('Recalling item from scene');
                slot.deployed = false;
                updatePocketSlot(slotIndex);
            } else {
                // Item is in pocket - deploy it
                console.log('Deploying item to scene');
                slot.deployed = true;
                updatePocketSlot(slotIndex);
            }
        }

        function updatePocketSlot(slotIndex) {
            const slot = pocketItems[slotIndex];
            const slotElement = document.querySelector(`[data-slot="${slotIndex}"]`);
            
            if (!slotElement) return;
            
            // Update visual state
            slotElement.classList.remove('empty', 'in-scene');
            
            if (!slot.occupied) {
                slotElement.classList.add('empty');
            } else if (slot.deployed) {
                slotElement.classList.add('in-scene');
            }
            
            // Update transparency based on state
            if (slot.deployed) {
                slotElement.style.opacity = '0.2'; // Item out in scene (20%)
            } else {
                slotElement.style.opacity = '0.35'; // Item in pocket (35%)
            }
        }

        // Mobile controls
        let joystickActive = false;
        let joystickStartPos = { x: 0, y: 0 };
        let currentTransformMode = null; // 'position', 'rotation', 'scale'

        // Panel drag functionality
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let panelStartX = 20;
        let panelStartY = 20;

        // Sound effects
        function playSound(type) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            if (type === 'hover') {
                oscillator.frequency.value = 600;
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } else if (type === 'active') {
                oscillator.frequency.value = 800;
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } else if (type === 'passive') {
                oscillator.frequency.value = 400;
                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            }
        }

        // Initialize scene
        // Entrance sequence variables
        let entranceTunnel = null;
        let entranceWireframe = null;
        let entranceRings = [];
        let descentCylinder = null; // Bright cylinder that descends 1.5x faster
        let isEntranceActive = false;
        let entranceProgress = 0;
        let landingCylinder = null;

        function setupJoystickDirectionalButtons() {
            const joyNorth = document.getElementById('joy-btn-north');
            const joySouth = document.getElementById('joy-btn-south');
            const joyWest = document.getElementById('joy-btn-west');
            const joyEast = document.getElementById('joy-btn-east');
            
            if (joyNorth) {
                // Move forward
                joyNorth.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.w = true;
                });
                joyNorth.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.w = false;
                });
                joyNorth.addEventListener('mousedown', () => { keys.w = true; });
                joyNorth.addEventListener('mouseup', () => { keys.w = false; });
            }
            
            if (joySouth) {
                // Move backward
                joySouth.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.s = true;
                });
                joySouth.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.s = false;
                });
                joySouth.addEventListener('mousedown', () => { keys.s = true; });
                joySouth.addEventListener('mouseup', () => { keys.s = false; });
            }
            
            if (joyWest) {
                // Move left
                joyWest.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.a = true;
                });
                joyWest.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.a = false;
                });
                joyWest.addEventListener('mousedown', () => { keys.a = true; });
                joyWest.addEventListener('mouseup', () => { keys.a = false; });
            }
            
            if (joyEast) {
                // Move right
                joyEast.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys.d = true;
                });
                joyEast.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys.d = false;
                });
                joyEast.addEventListener('mousedown', () => { keys.d = true; });
                joyEast.addEventListener('mouseup', () => { keys.d = false; });
            }
        }

        function setup3DObjectInteractions() {
            // Hover effect
            window.addEventListener('mousemove', (event) => {
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(interactiveObjects, false);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    
                    // Update inspector with hovered object
                    if (object !== hoveredObject) {
                        hoveredObject = object;
                        updateInspectorWithObject(object);
                        
                        // Change cursor to pointer
                        document.body.style.cursor = 'pointer';
                    }
                } else {
                    if (hoveredObject) {
                        hoveredObject = null;
                        document.body.style.cursor = 'default';
                    }
                }
            });
            
            // Click handler for cubes
            window.addEventListener('click', (event) => {
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(interactiveObjects, false);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    
                    // Handle keyboard cube clicks
                    if (object.userData && object.userData.type === 'omniKey') {
                        handleKeyboardCubeClick(object);
                        playSound('active');
                    }
                    // Handle other interactive objects
                    else if (object.userData && object.userData.type === 'mySpaceObject') {
                        // Existing MySpace object handling
                        selectedObject = object;
                        updateInspector();
                        playSound('passive');
                    }
                }
            });
        }

        function updateInspectorWithObject(object) {
            const inspectorPanel = document.getElementById('inspector-panel');
            if (!inspectorPanel) return;
            
            // Show inspector if hidden
            if (!inspectorPanel.classList.contains('visible')) {
                inspectorPanel.style.display = 'block';
            }
            
            const titleElement = inspectorPanel.querySelector('.panel-title');
            const selectedName = document.getElementById('selected-name');
            
            if (object.userData && object.userData.type === 'omniKey') {
                if (titleElement) titleElement.textContent = 'MNIKEY';
                if (selectedName) selectedName.textContent = object.userData.label || 'Key';
            } else if (object.userData && object.userData.type === 'mySpaceObject') {
                if (titleElement) titleElement.textContent = ' INSPECTOR';
                if (selectedName) selectedName.textContent = object.userData.dataHeader || 'Object';
            } else {
                if (titleElement) titleElement.textContent = ' INSPECTOR';
                if (selectedName) selectedName.textContent = object.name || 'Object';
            }
        }

        function handleKeyboardCubeClick(keyCube) {
            // Set as current key
            omniKeyboardCurrentRow = keyCube.userData.rowIndex;
            omniKeyboardCurrentCol = keyCube.userData.colIndex;
            highlightCurrentKey();
            
            // Update selected key display
            const selectedKeyName = document.getElementById('selected-key-name');
            if (selectedKeyName) {
                selectedKeyName.textContent = keyCube.userData.label || 'Unknown';
            }
            
            // Populate entity and function fields if data exists
            const entityField = document.getElementById('key-entity');
            const functionField = document.getElementById('key-function');
            
            if (entityField) {
                entityField.value = keyCube.userData.entity || '';
            }
            if (functionField) {
                functionField.value = keyCube.userData.function || '';
            }
            
            // Update inspector with full key info
            updateInspectorWithKeyInfo(keyCube);
            
            console.log('Clicked key:', keyCube.userData.label);
        }

        // ========================================
        // OMNICONDUIT REALITY NODE NETWORK SYSTEM
        // ========================================
        
        class OmniConduit {
            constructor(config) {
                this.id = config.id || `conduit_${Date.now()}`;
                this.originNode = config.originNode;
                this.destinationNode = config.destinationNode;
                this.directionality = config.directionality || 'two-way';
                this.traversalMode = config.traversalMode || 'instant';
                this.transformationRules = config.transformationRules || {
                    identity: 'preserve',
                    environment: 'inherit',
                    physics: 'inherit'
                };
                this.stability = config.stability || 'stable';
                this.triggerConditions = config.triggerConditions || 'none';
                this.geometry = 'cylinder';
                this.cylinderRadius = config.cylinderRadius || CONDUIT_RADIUS;
                
                // Auto-calculate cylinder length based on node distance
                const origin = realityNodes[this.originNode];
                const destination = realityNodes[this.destinationNode];
                if (origin && destination) {
                    const dx = destination.position.x - origin.position.x;
                    const dy = destination.position.y - origin.position.y;
                    const dz = destination.position.z - origin.position.z;
                    this.cylinderLength = Math.sqrt(dx*dx + dy*dy + dz*dz);
                } else {
                    this.cylinderLength = 0;
                }
                
                this.mesh = null; // Will hold Three.js cylinder mesh
            }
            
            createMesh() {
                const origin = realityNodes[this.originNode];
                const destination = realityNodes[this.destinationNode];
                
                if (!origin || !destination) {
                    console.error('Cannot create conduit mesh: nodes not found');
                    return null;
                }
                
                // Create cylinder geometry
                const geometry = new THREE.CylinderGeometry(
                    this.cylinderRadius,
                    this.cylinderRadius,
                    this.cylinderLength,
                    16,
                    1,
                    false
                );
                
                // Semi-transparent material with glow
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                
                // Position at midpoint between nodes
                const midpoint = new THREE.Vector3(
                    (origin.position.x + destination.position.x) / 2,
                    (origin.position.y + destination.position.y) / 2,
                    (origin.position.z + destination.position.z) / 2
                );
                this.mesh.position.copy(midpoint);
                
                // Orient cylinder to point from origin to destination
                const direction = new THREE.Vector3(
                    destination.position.x - origin.position.x,
                    destination.position.y - origin.position.y,
                    destination.position.z - origin.position.z
                );
                direction.normalize();
                
                // Default cylinder points along Y-axis, so we need to rotate it
                const up = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(up, direction);
                this.mesh.setRotationFromQuaternion(quaternion);
                
                // Add wireframe for visibility
                const wireframeGeometry = new THREE.CylinderGeometry(
                    this.cylinderRadius,
                    this.cylinderRadius,
                    this.cylinderLength,
                    8,
                    1,
                    false
                );
                const wireframeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.3
                });
                const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
                this.mesh.add(wireframe);
                
                // Tag for identification
                this.mesh.userData.type = 'omniConduit';
                this.mesh.userData.conduitId = this.id;
                this.mesh.userData.originNode = this.originNode;
                this.mesh.userData.destinationNode = this.destinationNode;
                
                return this.mesh;
            }
        }
        
        class RealityNode {
            constructor(config) {
                this.id = config.id;
                this.name = config.name || config.id;
                this.position = config.position || { x: 0, y: 0, z: 0 };
                this.size = config.size || 30; // Radius
                this.type = config.type || 'space';
                this.environment = config.environment || 'default';
                this.isActive = config.isActive || false;
                this.mesh = config.mesh || null; // Link to existing sphere if provided
            }
        }
        
        function initializeOmniConduitSystem() {
            console.log('Initializing OmniConduit Reality Node Network...');
            
            // Create mySpace node (existing landing zone at y=30)
            realityNodes['mySpace'] = new RealityNode({
                id: 'mySpace',
                name: 'MySpace Landing Zone',
                position: { x: 0, y: 30, z: 0 },
                size: 30,
                type: 'landing',
                environment: 'default',
                isActive: true,
                mesh: window.mySpaceSphere // Link to existing sphere
            });
            
            // Create 7 surrounding spaces
            realityNodes['frontSpace'] = new RealityNode({
                id: 'frontSpace',
                name: 'Front Space',
                position: { x: 0, y: 30, z: -NODE_SPACING },
                size: 30,
                type: 'space',
                environment: 'front'
            });
            
            realityNodes['backSpace'] = new RealityNode({
                id: 'backSpace',
                name: 'Back Space',
                position: { x: 0, y: 30, z: NODE_SPACING },
                size: 30,
                type: 'space',
                environment: 'back'
            });
            
            realityNodes['topDiagonalLeft'] = new RealityNode({
                id: 'topDiagonalLeft',
                name: 'Top Diagonal Left',
                position: { x: -NODE_SPACING, y: 30 + NODE_SPACING, z: 0 },
                size: 30,
                type: 'space',
                environment: 'upper'
            });
            
            realityNodes['topDiagonalRight'] = new RealityNode({
                id: 'topDiagonalRight',
                name: 'Top Diagonal Right',
                position: { x: NODE_SPACING, y: 30 + NODE_SPACING, z: 0 },
                size: 30,
                type: 'space',
                environment: 'upper'
            });
            
            realityNodes['bottomDiagonalLeft'] = new RealityNode({
                id: 'bottomDiagonalLeft',
                name: 'Bottom Diagonal Left',
                position: { x: -NODE_SPACING, y: 30 - NODE_SPACING, z: 0 },
                size: 30,
                type: 'space',
                environment: 'lower'
            });
            
            realityNodes['bottomDiagonalRight'] = new RealityNode({
                id: 'bottomDiagonalRight',
                name: 'Bottom Diagonal Right',
                position: { x: NODE_SPACING, y: 30 - NODE_SPACING, z: 0 },
                size: 30,
                type: 'space',
                environment: 'lower'
            });
            
            realityNodes['behindSpace'] = new RealityNode({
                id: 'behindSpace',
                name: 'Behind Space (Rear Layer)',
                position: { x: 0, y: 30, z: NODE_SPACING * 2 },
                size: 30,
                type: 'space',
                environment: 'rear'
            });
            
            // Additional horizontal nodes at same Y level (30)
            realityNodes['leftSpace'] = new RealityNode({
                id: 'leftSpace',
                name: 'Left Space',
                position: { x: -NODE_SPACING, y: 30, z: 0 },
                size: 30,
                type: 'space',
                environment: 'left'
            });
            
            realityNodes['rightSpace'] = new RealityNode({
                id: 'rightSpace',
                name: 'Right Space',
                position: { x: NODE_SPACING, y: 30, z: 0 },
                size: 30,
                type: 'space',
                environment: 'right'
            });
            
            realityNodes['frontLeftSpace'] = new RealityNode({
                id: 'frontLeftSpace',
                name: 'Front Left Space',
                position: { x: -NODE_SPACING, y: 30, z: -NODE_SPACING },
                size: 30,
                type: 'space',
                environment: 'front-left'
            });
            
            realityNodes['frontRightSpace'] = new RealityNode({
                id: 'frontRightSpace',
                name: 'Front Right Space',
                position: { x: NODE_SPACING, y: 30, z: -NODE_SPACING },
                size: 30,
                type: 'space',
                environment: 'front-right'
            });
            
            realityNodes['rearLeftSpace'] = new RealityNode({
                id: 'rearLeftSpace',
                name: 'Rear Left Space',
                position: { x: -NODE_SPACING, y: 30, z: NODE_SPACING },
                size: 30,
                type: 'space',
                environment: 'rear-left'
            });
            
            realityNodes['rearRightSpace'] = new RealityNode({
                id: 'rearRightSpace',
                name: 'Rear Right Space',
                position: { x: NODE_SPACING, y: 30, z: NODE_SPACING },
                size: 30,
                type: 'space',
                environment: 'rear-right'
            });
            
            // Set current node
            currentNode = 'mySpace';
            
            // Create conduits connecting mySpace to all surrounding spaces
            const connections = [
                ['mySpace', 'frontSpace'],
                ['mySpace', 'backSpace'],
                ['mySpace', 'leftSpace'],
                ['mySpace', 'rightSpace'],
                ['mySpace', 'topDiagonalLeft'],
                ['mySpace', 'topDiagonalRight'],
                ['mySpace', 'bottomDiagonalLeft'],
                ['mySpace', 'bottomDiagonalRight'],
                ['mySpace', 'frontLeftSpace'],
                ['mySpace', 'frontRightSpace'],
                ['mySpace', 'rearLeftSpace'],
                ['mySpace', 'rearRightSpace'],
                ['mySpace', 'behindSpace']
            ];
            
            connections.forEach(([origin, destination]) => {
                const conduit = new OmniConduit({
                    id: `${origin}_to_${destination}`,
                    originNode: origin,
                    destinationNode: destination,
                    directionality: 'two-way',
                    traversalMode: 'instant',
                    cylinderRadius: CONDUIT_RADIUS
                });
                
                omniConduits.push(conduit);
                
                // Create and add mesh to scene
                const mesh = conduit.createMesh();
                if (mesh) {
                    scene.add(mesh);
                }
            });
            
            // Create sphere meshes for new nodes (not mySpace which already exists)
            Object.keys(realityNodes).forEach(nodeId => {
                if (nodeId !== 'mySpace') {
                    createNodeSphere(nodeId);
                }
            });
            
            console.log('OmniConduit System initialized:');
            console.log('- Nodes:', Object.keys(realityNodes).length);
            console.log('- Conduits:', omniConduits.length);
            
            // Output system details to console
            outputSystemDetails();
        }
        
        function createNodeSphere(nodeId) {
            const node = realityNodes[nodeId];
            if (!node) return;
            
            // Create sphere geometry matching mySpace
            const sphereGeometry = new THREE.SphereGeometry(node.size, 32, 32);
            
            // Create shader material matching mySpace style
            const sphereMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color1: { value: new THREE.Color(0xb0b0b0) },
                    color2: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color1;
                    uniform vec3 color2;
                    varying vec3 vPosition;
                    void main() {
                        float mixValue = (vPosition.y + 30.0) / 60.0;
                        gl_FragColor = vec4(mix(color1, color2, mixValue), 0.3);
                    }
                `,
                transparent: true,
                opacity: 0.3
            });
            
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(node.position.x, node.position.y, node.position.z);
            sphere.userData.type = 'reality-node';
            sphere.userData.nodeId = nodeId;
            
            scene.add(sphere);
            node.mesh = sphere;
            
            // Add to interactive objects for clicking
            interactiveObjects.push(sphere);
        }
        
        function traverseConduit(fromNode, toNode) {
            if (isTraversing) return;
            
            const destNode = realityNodes[toNode];
            if (!destNode) {
                console.error('Destination node not found:', toNode);
                return;
            }
            
            isTraversing = true;
            console.log(`Traversing from ${fromNode} to ${toNode}`);
            
            // Animate camera to destination node
            gsap.to(camera.position, {
                duration: 2,
                x: destNode.position.x,
                y: destNode.position.y,
                z: destNode.position.z + 50, // Position in front of node
                ease: 'power2.inOut',
                onComplete: () => {
                    currentNode = toNode;
                    isTraversing = false;
                    console.log('Arrived at:', toNode);
                    playSound('active');
                }
            });
            
            // Look at destination during travel
            gsap.to(cameraTarget, {
                duration: 2,
                x: destNode.position.x,
                y: destNode.position.y,
                z: destNode.position.z,
                ease: 'power2.inOut'
            });
            
            playSound('passive');
        }
        
        function outputSystemDetails() {
            console.log('\n OMNICONDUIT SYSTEM DETAILS \n');
            
            console.log('REALITY NODES:');
            Object.keys(realityNodes).forEach(nodeId => {
                const node = realityNodes[nodeId];
                console.log(`  ${nodeId}:`);
                console.log(`    - Name: ${node.name}`);
                console.log(`    - Position: (${node.position.x}, ${node.position.y}, ${node.position.z})`);
                console.log(`    - Size: ${node.size}`);
                console.log(`    - Active: ${node.isActive}`);
            });
            
            console.log('\nOMNICONDUITS:');
            omniConduits.forEach(conduit => {
                console.log(`  ${conduit.id}:`);
                console.log(`    - Origin: ${conduit.originNode}`);
                console.log(`    - Destination: ${conduit.destinationNode}`);
                console.log(`    - Length: ${conduit.cylinderLength.toFixed(2)}`);
                console.log(`    - Radius: ${conduit.cylinderRadius}`);
                console.log(`    - Directionality: ${conduit.directionality}`);
            });
            
            console.log('\nNETWORK MAP (Top-Down View):');
            console.log('```');
            console.log('        [TDL]              [TDR]');
            console.log('           \\                /   ');
            console.log('            \\              /    ');
            console.log('    [FL]-----[FS]-----[FR]      ');
            console.log('      |       |        |        ');
            console.log('    [LS]--[mySpace]--[RS]       ');
            console.log('      |       |        |        ');
            console.log('    [RL]-----[BS]-----[RR]--[BHS]');
            console.log('            /              \\    ');
            console.log('           /                \\   ');
            console.log('        [BDL]              [BDR]');
            console.log('```');
            console.log('Legend:');
            console.log('  mySpace = MySpace Landing Zone (0, 30, 0)');
            console.log('  FS = frontSpace (0, 30, -150)');
            console.log('  BS = backSpace (0, 30, 150)');
            console.log('  LS = leftSpace (-150, 30, 0)');
            console.log('  RS = rightSpace (150, 30, 0)');
            console.log('  FL = frontLeftSpace (-150, 30, -150)');
            console.log('  FR = frontRightSpace (150, 30, -150)');
            console.log('  RL = rearLeftSpace (-150, 30, 150)');
            console.log('  RR = rearRightSpace (150, 30, 150)');
            console.log('  TDL = topDiagonalLeft (-150, 180, 0)');
            console.log('  TDR = topDiagonalRight (150, 180, 0)');
            console.log('  BDL = bottomDiagonalLeft (-150, -120, 0)');
            console.log('  BDR = bottomDiagonalRight (150, -120, 0)');
            console.log('  BHS = behindSpace (0, 30, 300)');
            console.log('\n\n');
        }
        
        function setupOmniMapPanel() {
            const panel = document.getElementById('omnimap-panel');
            const minimizeBtn = document.getElementById('omnimap-minimize-btn');
            const closeBtn = document.getElementById('omnimap-close-btn');
            const panelHeader = document.getElementById('omnimap-panel-header');
            const panelContent = document.getElementById('omnimap-panel-content');
            
            // Panel controls
            if (minimizeBtn && panelContent && panel) {
                minimizeBtn.addEventListener('click', () => {
                    panel.classList.toggle('minimized');
                    panelContent.classList.toggle('hidden');
                    playSound('passive');
                });
            }
            
            if (closeBtn && panel) {
                closeBtn.addEventListener('click', () => {
                    panel.style.display = 'none';
                    playSound('passive');
                });
            }
            
            // Make panel draggable
            if (panelHeader && panel) {
                let isDragging = false;
                let currentX, currentY, initialX, initialY;
                
                panelHeader.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('panel-btn')) return;
                    isDragging = true;
                    initialX = e.clientX - panel.offsetLeft;
                    initialY = e.clientY - panel.offsetTop;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        panel.style.left = currentX + 'px';
                        panel.style.top = currentY + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            // Node button click handlers
            const nodeButtons = document.querySelectorAll('.node-btn');
            nodeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetNode = btn.getAttribute('data-node');
                    if (targetNode && targetNode !== currentNode) {
                        // Traverse to the clicked node
                        traverseConduit(currentNode, targetNode);
                        
                        // Update UI
                        updateOmniMapUI(targetNode);
                    }
                });
            });
        }
        
        function updateOmniMapUI(newCurrentNode) {
            // Update current node display
            const display = document.getElementById('current-node-display');
            if (display && realityNodes[newCurrentNode]) {
                display.textContent = realityNodes[newCurrentNode].name;
            }
            
            // Update button styles
            const nodeButtons = document.querySelectorAll('.node-btn');
            nodeButtons.forEach(btn => {
                const nodeId = btn.getAttribute('data-node');
                if (nodeId === newCurrentNode) {
                    btn.classList.add('active-node');
                    btn.style.background = 'rgba(0, 255, 0, 0.3)';
                    btn.style.border = '2px solid rgba(0, 255, 0, 0.8)';
                    btn.style.color = '#00ff00';
                    btn.style.boxShadow = '0 0 15px rgba(0, 255, 0, 0.5)';
                } else {
                    btn.classList.remove('active-node');
                    btn.style.background = 'rgba(128, 128, 128, 0.3)';
                    btn.style.border = '1px solid rgba(255, 255, 255, 0.4)';
                    btn.style.color = '#fff';
                    btn.style.boxShadow = 'none';
                }
            });
        }

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa1a1a1); // Default grey background

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 15); // Start at height 30
            scene.add(camera); // Add camera to scene so children render

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.domElement.style.opacity = '0'; // Hide initially until entrance starts
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Outer sphere with gradient - Part of MySpace
            const sphereGeometry = new THREE.SphereGeometry(30, 64, 64);
            const sphereMaterial = new THREE.ShaderMaterial({
                side: THREE.BackSide,
                uniforms: {
                    color1: { value: new THREE.Color(0x333333) },
                    color2: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    void main() {
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color1;
                    uniform vec3 color2;
                    varying vec3 vPosition;
                    void main() {
                        float mixValue = (vPosition.y + 30.0) / 60.0;
                        gl_FragColor = vec4(mix(color1, color2, mixValue), 1.0);
                    }
                `
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(0, 0, 0); // Centered in group, group will be positioned at y=30
            sphere.userData.type = 'myspace-sphere'; // Tag for identification
            window.mySpaceSphere = sphere; // Store global reference
            scene.add(sphere); // Add to scene for now, will add to group later

            // User Energy State - Particle System
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            particleVelocities = new Float32Array(particleCount * 3);
            
            // Create particles in sphere shape - smaller radius for better centering
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Random spherical coordinates
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 8 + Math.random() * 4; // 8-12 range (closer to user)
                
                // Convert to Cartesian
                particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                particlePositions[i3 + 2] = radius * Math.cos(phi);
                
                // Gentle random velocities for calm animation
                particleVelocities[i3] = (Math.random() - 0.5) * 0.02;
                particleVelocities[i3 + 1] = (Math.random() - 0.5) * 0.02;
                particleVelocities[i3 + 2] = (Math.random() - 0.5) * 0.02;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            
            // Create circular texture for round particles
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            const particleTexture = new THREE.CanvasTexture(canvas);
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.05,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                map: particleTexture
            });
            
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            // Attach particle system to camera so it follows both position and rotation
            camera.add(particleSystem);
            // Reset to origin - no offset
            particleSystem.position.set(0, 0, 0);
            // Rotate to (0, 0, 71 degrees) for optimal forward flow
            particleSystem.rotation.set(0, 0, 71 * Math.PI / 180);

            // Grid plane at 0, -5, 0
            const gridSize = 2500; // Expanded 50x from 50 to 2500
            const gridDivisions = 100; // Increased divisions for better detail
            gridHelper = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0xffffff);
            gridHelper.position.set(0, -5, 0);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Create OmniSense Cube System
            function createOmniSenseCube() {
                omniSenseCube = new THREE.Group();
                omniSenseCube.position.set(0, 30, 0); // Same position as MySpace
                
                // Create 6 face planes with grid patterns
                const faceGeometry = new THREE.PlaneGeometry(cubeSize, cubeSize, 10, 10);
                
                const facePositions = [
                    { name: 'top', pos: [0, cubeSize/2, 0], rot: [-Math.PI/2, 0, 0], color: 0x4488ff, icon: '' },
                    { name: 'bottom', pos: [0, -cubeSize/2, 0], rot: [Math.PI/2, 0, 0], color: 0x4488ff, icon: '' },
                    { name: 'front', pos: [0, 0, cubeSize/2], rot: [0, 0, 0], color: 0x4488ff, icon: '' },
                    { name: 'back', pos: [0, 0, -cubeSize/2], rot: [0, Math.PI, 0], color: 0x4488ff, icon: '' },
                    { name: 'right', pos: [cubeSize/2, 0, 0], rot: [0, Math.PI/2, 0], color: 0x4488ff, icon: '' },
                    { name: 'left', pos: [-cubeSize/2, 0, 0], rot: [0, -Math.PI/2, 0], color: 0x4488ff, icon: '' }
                ];
                
                facePositions.forEach(face => {
                    const faceMaterial = new THREE.MeshBasicMaterial({
                        color: face.color,
                        transparent: true,
                        opacity: 0.05,
                        side: THREE.DoubleSide,
                        wireframe: false
                    });
                    
                    const faceMesh = new THREE.Mesh(faceGeometry, faceMaterial);
                    faceMesh.position.set(...face.pos);
                    faceMesh.rotation.set(...face.rot);
                    faceMesh.userData = {
                        type: 'cube-face',
                        faceName: face.name,
                        originalOpacity: 0.05,
                        isClickable: true
                    };
                    
                    omniSenseCube.add(faceMesh);
                    cubeFaces.push(faceMesh);
                    
                    // Add grid lines to face
                    const wireframe = new THREE.WireframeGeometry(faceGeometry);
                    const wireframeMaterial = new THREE.LineBasicMaterial({
                        color: 0x888888,
                        transparent: true,
                        opacity: 0.2
                    });
                    const wireframeMesh = new THREE.LineSegments(wireframe, wireframeMaterial);
                    faceMesh.add(wireframeMesh);
                    
                    // Add icon to face (larger and brighter)
                    const iconSize = cubeSize * 0.5; // 50% of cube size for visibility
                    const iconCanvas = document.createElement('canvas');
                    iconCanvas.width = 256;
                    iconCanvas.height = 256;
                    const iconCtx = iconCanvas.getContext('2d');
                    
                    // Draw bright icon
                    iconCtx.fillStyle = 'rgba(255, 255, 255, 1.0)'; // Bright white
                    iconCtx.font = 'bold 180px Arial';
                    iconCtx.textAlign = 'center';
                    iconCtx.textBaseline = 'middle';
                    iconCtx.fillText(face.icon, 128, 128);
                    
                    const iconTexture = new THREE.CanvasTexture(iconCanvas);
                    const iconMaterial = new THREE.MeshBasicMaterial({
                        map: iconTexture,
                        transparent: true,
                        opacity: 0.95, // Very bright
                        side: THREE.DoubleSide
                    });
                    
                    const iconGeometry = new THREE.PlaneGeometry(iconSize, iconSize);
                    const iconMesh = new THREE.Mesh(iconGeometry, iconMaterial);
                    iconMesh.position.set(0, 0, 0.1); // Slightly in front of face
                    faceMesh.add(iconMesh);
                });
                
                // Create 12 edges with pulsing animation
                const edgePoints = [
                    // Bottom square
                    [[-cubeSize/2, -cubeSize/2, -cubeSize/2], [cubeSize/2, -cubeSize/2, -cubeSize/2]],
                    [[cubeSize/2, -cubeSize/2, -cubeSize/2], [cubeSize/2, -cubeSize/2, cubeSize/2]],
                    [[cubeSize/2, -cubeSize/2, cubeSize/2], [-cubeSize/2, -cubeSize/2, cubeSize/2]],
                    [[-cubeSize/2, -cubeSize/2, cubeSize/2], [-cubeSize/2, -cubeSize/2, -cubeSize/2]],
                    // Top square
                    [[-cubeSize/2, cubeSize/2, -cubeSize/2], [cubeSize/2, cubeSize/2, -cubeSize/2]],
                    [[cubeSize/2, cubeSize/2, -cubeSize/2], [cubeSize/2, cubeSize/2, cubeSize/2]],
                    [[cubeSize/2, cubeSize/2, cubeSize/2], [-cubeSize/2, cubeSize/2, cubeSize/2]],
                    [[-cubeSize/2, cubeSize/2, cubeSize/2], [-cubeSize/2, cubeSize/2, -cubeSize/2]],
                    // Vertical edges
                    [[-cubeSize/2, -cubeSize/2, -cubeSize/2], [-cubeSize/2, cubeSize/2, -cubeSize/2]],
                    [[cubeSize/2, -cubeSize/2, -cubeSize/2], [cubeSize/2, cubeSize/2, -cubeSize/2]],
                    [[cubeSize/2, -cubeSize/2, cubeSize/2], [cubeSize/2, cubeSize/2, cubeSize/2]],
                    [[-cubeSize/2, -cubeSize/2, cubeSize/2], [-cubeSize/2, cubeSize/2, cubeSize/2]]
                ];
                
                const edgesGroup = new THREE.Group();
                edgePoints.forEach((edge, index) => {
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(...edge[0]),
                        new THREE.Vector3(...edge[1])
                    ]);
                    
                    const material = new THREE.LineBasicMaterial({
                        color: 0x0066ff,
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = {
                        type: 'cube-edge',
                        edgeIndex: index,
                        baseColor: new THREE.Color(0x0066ff),
                        pulsePhase: (index / 12) * Math.PI * 2
                    };
                    edgesGroup.add(line);
                });
                
                omniSenseCube.add(edgesGroup);
                cubeEdges = edgesGroup;
                omniSenseCube.visible = false; // Hidden by default
                scene.add(omniSenseCube);
                
                console.log('OmniSense Cube created');
            }
            
            createOmniSenseCube();

            // Initialize MySpace grid with default spherical configuration
            window.gridPanelObjects = [];
            createMySpaceGrid('spherical', 8, 25);
            
            function createMySpaceGrid(gridType, segments, radius) {
                // Initialize mySpaceGroup if it doesn't exist
                if (!mySpaceGroup) {
                    mySpaceGroup = new THREE.Group();
                    mySpaceGroup.position.set(0, 30, 0); // Position so sphere bottom is at y=0
                    scene.add(mySpaceGroup);
                    
                    // Add the gradient sphere to MySpace group if it exists
                    if (window.mySpaceSphere && window.mySpaceSphere.parent === scene) {
                        scene.remove(window.mySpaceSphere);
                        mySpaceGroup.add(window.mySpaceSphere);
                    }
                }
                
                // Clear existing grid panels
                if (window.gridPanelObjects && window.gridPanelObjects.length > 0) {
                    window.gridPanelObjects.forEach(panel => {
                        mySpaceGroup.remove(panel);
                        if (panel.geometry) panel.geometry.dispose();
                        if (panel.material) panel.material.dispose();
                        const index = gridObjects.indexOf(panel);
                        if (index > -1) gridObjects.splice(index, 1);
                        const interactiveIndex = interactiveObjects.indexOf(panel);
                        if (interactiveIndex > -1) interactiveObjects.splice(interactiveIndex, 1);
                    });
                    window.gridPanelObjects = [];
                }
                
                const gridGeometry = new THREE.PlaneGeometry(3, 3);
                const totalPanels = segments * segments * 2; // Approximate total
                
                if (gridType === 'spherical') {
                    // Original spherical grid
                    for (let lat = 0; lat < segments; lat++) {
                        for (let lon = 0; lon < segments * 2; lon++) {
                            const phi = (lat / segments) * Math.PI;
                            const theta = (lon / (segments * 2)) * Math.PI * 2;
                            
                            const x = radius * Math.sin(phi) * Math.cos(theta);
                            const y = radius * Math.cos(phi);
                            const z = radius * Math.sin(phi) * Math.sin(theta);
                            
                            createGridPanel(gridGeometry, x, y, z, lat, lon);
                        }
                    }
                } else if (gridType === 'planar') {
                    // Planar walls - 5x5 grid, multiple layers
                    const spacing = radius / 8;
                    for (let layer = 0; layer < 5; layer++) {
                        const zPos = layer * spacing * 2 - spacing * 4;
                        for (let x = 0; x < 5; x++) {
                            for (let y = 0; y < 5; y++) {
                                const xPos = (x - 2) * spacing;
                                const yPos = (y - 2) * spacing;
                                createGridPanel(gridGeometry, xPos, yPos, zPos, x, y + (layer * 5));
                            }
                        }
                    }
                } else if (gridType === 'helix') {
                    // Helix/spiral arrangement
                    const height = radius * 2;
                    const helixRadius = radius * 0.6;
                    const turns = 5;
                    const panelsPerTurn = Math.floor(segments / 2);
                    
                    for (let i = 0; i < turns * panelsPerTurn; i++) {
                        const t = i / panelsPerTurn;
                        const angle = t * Math.PI * 2;
                        const y = (t / turns) * height - height / 2;
                        const x = helixRadius * Math.cos(angle);
                        const z = helixRadius * Math.sin(angle);
                        createGridPanel(gridGeometry, x, y, z, i, 0);
                    }
                } else if (gridType === 'cube') {
                    // Cubic grid arrangement
                    const divisions = Math.floor(segments / 2);
                    const spacing = radius / divisions;
                    const halfSize = radius / 2;
                    
                    // Create panels on all 6 faces of the cube
                    for (let face = 0; face < 6; face++) {
                        for (let i = 0; i < divisions; i++) {
                            for (let j = 0; j < divisions; j++) {
                                const u = (i / divisions) * radius - halfSize;
                                const v = (j / divisions) * radius - halfSize;
                                
                                let x, y, z;
                                if (face === 0) { x = u; y = v; z = halfSize; }  // Front
                                else if (face === 1) { x = u; y = v; z = -halfSize; }  // Back
                                else if (face === 2) { x = halfSize; y = v; z = u; }  // Right
                                else if (face === 3) { x = -halfSize; y = v; z = u; }  // Left
                                else if (face === 4) { x = u; y = halfSize; z = v; }  // Top
                                else if (face === 5) { x = u; y = -halfSize; z = v; }  // Bottom
                                
                                createGridPanel(gridGeometry, x, y, z, i, j + (face * divisions));
                            }
                        }
                    }
                }
                
                function createGridPanel(geometry, x, y, z, lat, lon) {
                    const gridMaterial = new THREE.MeshBasicMaterial({
                        color: 0xeeeeee,
                        transparent: true,
                        opacity: 0.2,
                        side: THREE.DoubleSide
                    });
                    
                    const gridPanel = new THREE.Mesh(geometry, gridMaterial);
                    gridPanel.position.set(x, y, z);
                    gridPanel.lookAt(0, 0, 0);
                    gridPanel.userData = { 
                        type: 'grid',
                        label: `Grid ${lat}-${lon}`,
                        originalColor: 0xeeeeee,
                        originalPosition: { x, y, z }
                    };
                    
                    mySpaceGroup.add(gridPanel);  // Add to group instead of scene
                    gridObjects.push(gridPanel);
                    interactiveObjects.push(gridPanel);
                    window.gridPanelObjects.push(gridPanel);
                    
                    // Add grid lines
                    const edgesGeometry = new THREE.EdgesGeometry(geometry);
                    const edgesMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xeeeeee, 
                        opacity: 0.3, 
                        transparent: true 
                    });
                    const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                    gridPanel.add(edges);
                }
            }
            
            // Make function globally accessible
            window.createMySpaceGrid = createMySpaceGrid;

            // Grid radius for positioning journal pages
            const gridRadius = 25;

            // Journal pages - now square and positioned on grid
            const pageData = [
                { title: 'Morning\nRoutine', color: 0x808080, lat: 2, lon: 0 },
                { title: 'Job\nRoutine', color: 0xF5A623, lat: 4, lon: 4 },
                { title: 'Before Bed\nRoutine', color: 0x9013FE, lat: 6, lon: 8 }
            ];

            pageData.forEach((data, index) => {
                // Calculate position on grid sphere
                const phi = (data.lat / 8) * Math.PI;
                const theta = (data.lon / 16) * 2 * Math.PI;
                
                const x = gridRadius * Math.sin(phi) * Math.cos(theta);
                const y = gridRadius * Math.cos(phi);
                const z = gridRadius * Math.sin(phi) * Math.sin(theta);
                
                // Square geometry (2.5 x 2.5)
                const pageGeometry = new THREE.BoxGeometry(2.5, 2.5, 0.1);
                const pageMaterial = new THREE.MeshPhongMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 100
                });
                
                const page = new THREE.Mesh(pageGeometry, pageMaterial);
                page.position.set(x, y, z);
                page.lookAt(0, 0, 0); // Face center
                page.userData = {
                    type: 'page',
                    title: data.title.replace('\n', ' '),
                    index: index,
                    originalColor: data.color,
                    originalPosition: { x, y, z }
                };
                
                scene.add(page);
                journalPages.push(page);
                interactiveObjects.push(page);

                // Add text using canvas
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 40px Orbitron, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const lines = data.title.split('\n');
                lines.forEach((line, i) => {
                    ctx.fillText(line, 256, 256 + (i - 0.5) * 50);
                });
                
                const texture = new THREE.CanvasTexture(canvas);
                const textMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const textPlane = new THREE.PlaneGeometry(2.3, 2.3);
                const textMesh = new THREE.Mesh(textPlane, textMaterial);
                textMesh.position.z = 0.06;
                page.add(textMesh);
            });

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0x808080, 1, 100);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xF5A623, 1, 100);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            // Event listeners
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            
            // Mouse wheel zoom for 3D panel viewing
            renderer.domElement.addEventListener('wheel', (e) => {
                if (scene3DDataPanel) {
                    e.preventDefault();
                    const zoomSpeed = 0.5;
                    const minZ = 8;  // Closest zoom
                    const maxZ = 30; // Farthest zoom
                    
                    if (e.deltaY < 0) {
                        // Zoom in
                        camera.position.z = Math.max(minZ, camera.position.z - zoomSpeed);
                    } else {
                        // Zoom out
                        camera.position.z = Math.min(maxZ, camera.position.z + zoomSpeed);
                    }
                }
            }, { passive: false });
            window.addEventListener('resize', onResize);

            // Panel controls
            setupPanelControls();
            setupInspectorDataSave();
            setupJSONViewer();

            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                // Disable keyboard controls when typing in text fields
                const activeElement = document.activeElement;
                const isTextField = activeElement.tagName === 'INPUT' || 
                                   activeElement.tagName === 'TEXTAREA' || 
                                   activeElement.isContentEditable;
                
                // Auto-disconnect keyboard in Still Mode when text field is focused
                if (isTextField && omniKeyboardStillMode && omniKeyboardVisible) {
                    console.log('Auto-disconnecting keyboard: text field focused');
                    toggleOmniKeyboard();
                    playSound('passive');
                    return;
                }
                
                if (isTextField) {
                    return; // Don't process keyboard shortcuts
                }
                
                const key = e.key.toLowerCase();
                
                // Track shift key
                if (e.shiftKey) {
                    keys.shift = true;
                }
                
                // If Still Mode is ON, disable movement keys but allow keyboard typing
                if (!omniKeyboardStillMode || !omniKeyboardVisible) {
                    if (key in keys) {
                        keys[key] = true;
                        // Add visual feedback for C key (FPS mode)
                        if (key === 'c') {
                            document.body.classList.add('fps-mode');
                        }
                    }
                } else {
                    // Still Mode is ON - make keyboard typable
                    // Find and animate the key that was pressed
                    makeKeyJump(e.key);
                }
                // FAQ panel toggle
                if (key === 'q') {
                    const faqPanel = document.getElementById('faq-panel');
                    faqPanel.classList.toggle('visible');
                    playSound('passive');
                }
                // Inspector panel toggle
                if (key === 'x') {
                    const inspectorPanel = document.getElementById('inspector-panel');
                    inspectorPanel.classList.toggle('visible');
                    playSound('passive');
                }
                // Docks toggle
                if (key === 'z') {
                    docksVisible = !docksVisible;
                    const docks = document.querySelectorAll('.dock');
                    docks.forEach(dock => {
                        if (docksVisible) {
                            dock.classList.remove('hidden');
                        } else {
                            dock.classList.add('hidden');
                        }
                    });
                    playSound('passive');
                }
                // Reset camera position (adjusted for elevated sphere at y=30)
                if (key === 'o') {
                    gsap.to(camera.position, {
                        duration: 1.5,
                        x: 0,
                        y: 30,
                        z: 10,
                        ease: 'power2.inOut'
                    });
                    camera.quaternion.set(0, 0, 0, 1); // Reset rotation
                    playSound('active');
                }
                // OmniSense Mode toggle
                if (key === 'l') {
                    toggleOmniSenseMode();
                    playSound('active');
                }
                // mniKeyboard toggle
                if (key === 'n') {
                    toggleOmniKeyboard();
                    playSound('active');
                }
                
                // Arrow keys ALWAYS rotate current cube when keyboard visible
                if (omniKeyboardVisible && !isTextField) {
                    const currentKey = getCurrentKey();
                    if (currentKey) {
                        if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            rotateKeyCube(currentKey, 'x', -Math.PI / 4);
                            playSound('active');
                        } else if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            rotateKeyCube(currentKey, 'x', Math.PI / 4);
                            playSound('active');
                        } else if (e.key === 'ArrowLeft') {
                            e.preventDefault();
                            rotateKeyCube(currentKey, 'y', -Math.PI / 4);
                            playSound('active');
                        } else if (e.key === 'ArrowRight') {
                            e.preventDefault();
                            rotateKeyCube(currentKey, 'y', Math.PI / 4);
                            playSound('active');
                        }
                    }
                }
                
                // Balance camera rotation (B key)
                if (key === 'b') {
                    // Smoothly reset camera rotation to normal axis
                    gsap.to(camera.rotation, {
                        duration: 0.8,
                        x: 0,
                        y: 0,
                        z: 0,
                        ease: 'power2.out'
                    });
                    playSound('active');
                }
                // Left Hand toggle (Left Shift)
                if (e.key === 'Shift' && e.location === 1) { // Left Shift
                    e.preventDefault();
                    toggleLeftHand();
                }
                // Right Hand toggle (Right Shift)
                if (e.key === 'Shift' && e.location === 2) { // Right Shift
                    e.preventDefault();
                    toggleRightHand();
                }
                // Conscious Hand toggle (Enter)
                if (e.key === 'Enter') {
                    e.preventDefault();
                    toggleConsciousHand();
                }
                // MySpace toggle (0 key)
                if (e.key === '0') {
                    e.preventDefault();
                    toggleMySpace();
                }
                // Pocket toggle (9 key)
                if (e.key === '9') {
                    e.preventDefault();
                    togglePocket();
                }
                // Side Tray toggle (T key)
                if (e.key === 't' || e.key === 'T') {
                    e.preventDefault();
                    const sideTray = document.getElementById('side-tray');
                    const topTray = document.getElementById('top-tray');
                    
                    const isHidden = sideTray.style.display === 'none';
                    
                    if (sideTray) {
                        sideTray.style.display = isHidden ? 'block' : 'none';
                    }
                    if (topTray) {
                        topTray.style.display = isHidden ? 'flex' : 'none';
                    }
                    
                    playSound('passive');
                }
            });

            window.addEventListener('keyup', (e) => {
                // Disable keyboard controls when typing in text fields
                const activeElement = document.activeElement;
                const isTextField = activeElement.tagName === 'INPUT' || 
                                   activeElement.tagName === 'TEXTAREA' || 
                                   activeElement.isContentEditable;
                
                if (isTextField) {
                    return; // Don't process keyboard shortcuts
                }
                
                const key = e.key.toLowerCase();
                
                // Track shift key release
                if (!e.shiftKey) {
                    keys.shift = false;
                }
                
                if (key in keys) {
                    keys[key] = false;
                    // Remove visual feedback for C key
                    if (key === 'c') {
                        document.body.classList.remove('fps-mode');
                    }
                }
            });

            // Mobile controls
            setupMobileControls();
            setupTransformPanel();
            initializeToolMenu();
            setupActionGrid();
            setupHamburgerMenus();
            setupDockDragDrop();
            setupTimer();
            setupTimezone();
            setupSearchPanel();
            setupHandMenus();
            initPocket();
            initVirtualKeyboard();
            setupUITransparency();
            setupParticleBehavior();
            setupMySpaceGrid();
            setupProfile();
            
            // Setup joystick directional buttons
            setupJoystickDirectionalButtons();
            
            // Setup 3D object hover and click interactions
            setup3DObjectInteractions();
            
            // Setup particle control panel
            setupParticleControlPanel();
            
            // Setup mobile tap-and-hold drag for minimized panels
            setupMobilePanelDrag();
            
            // Setup OmniMap panel
            setupOmniMapPanel();

            // Apply default theme
            applyTheme('silver');

            // Initialize OmniConduit Reality Node Network
            initializeOmniConduitSystem();

            // Start animation
            animate();
            
            // Show welcome screen
            showWelcomeScreen();
            
            // Setup left menu toggle button (OPN/CLS)
            setupLeftMenuButton();
        }
        
        function setupLeftMenuButton() {
            const menuBtn = document.getElementById('btn-menu');
            const controlButtons = document.querySelector('.control-buttons');
            
            if (menuBtn && controlButtons) {
                menuBtn.addEventListener('click', () => {
                    // Toggle all control buttons except the menu button itself
                    const allButtons = controlButtons.querySelectorAll('.control-btn:not(#btn-menu)');
                    const verticalButtons = controlButtons.querySelectorAll('.vertical-btn');
                    
                    allButtons.forEach(btn => {
                        btn.classList.toggle('hidden');
                    });
                    
                    // Toggle active state on menu button
                    menuBtn.classList.toggle('active');
                    
                    playSound('passive');
                });
            }
        }
        
        function showWelcomeScreen() {
            // Create welcome panel overlay
            const welcomePanel = document.createElement('div');
            welcomePanel.id = 'welcome-panel';
            welcomePanel.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: linear-gradient(135deg, 
                    rgba(200, 200, 210, 0.95), 
                    rgba(240, 240, 245, 0.95), 
                    rgba(220, 220, 230, 0.95),
                    rgba(250, 250, 255, 0.95));
                background-size: 400% 400%;
                animation: cloudFlow 15s ease infinite;
                z-index: 10000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                backdrop-filter: blur(20px);
            `;
            
            welcomePanel.innerHTML = `
                <!-- Central  Symbol -->
                <div id="central-symbol" style="
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-family: 'Orbitron', sans-serif;
                    font-size: 120px;
                    color: rgba(80, 80, 90, 1);
                    cursor: pointer;
                    text-shadow: 0 0 40px rgba(255, 255, 255, 0.9), 0 0 80px rgba(200, 200, 210, 0.6);
                    transition: all 0.3s;
                    z-index: 100;
                "></div>
                
                <!-- Branches Container - lines stemming from  -->
                <svg id="branches-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 90;">
                    <!-- Radiating lines from center -->
                    <line id="branch-1" x1="50%" y1="50%" x2="20%" y2="20%" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2" stroke-dasharray="5,5" style="opacity: 0;"/>
                    <line id="branch-2" x1="50%" y1="50%" x2="80%" y2="20%" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2" stroke-dasharray="5,5" style="opacity: 0;"/>
                    <line id="branch-3" x1="50%" y1="50%" x2="80%" y2="80%" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2" stroke-dasharray="5,5" style="opacity: 0;"/>
                    <line id="branch-4" x1="50%" y1="50%" x2="20%" y2="80%" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2" stroke-dasharray="5,5" style="opacity: 0;"/>
                    <line id="branch-5" x1="50%" y1="50%" x2="10%" y2="50%" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2" stroke-dasharray="5,5" style="opacity: 0;"/>
                    <line id="branch-6" x1="50%" y1="50%" x2="90%" y2="50%" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2" stroke-dasharray="5,5" style="opacity: 0;"/>
                    <line id="branch-7" x1="50%" y1="50%" x2="50%" y2="10%" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2" stroke-dasharray="5,5" style="opacity: 0;"/>
                    <line id="branch-8" x1="50%" y1="50%" x2="50%" y2="90%" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2" stroke-dasharray="5,5" style="opacity: 0;"/>
                </svg>
                
                <!-- Questions Container -->
                <div id="questions-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50;"></div>
                
                <!-- Floating Symbols Container -->
                <div id="symbols-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 40;"></div>
                
                <!-- Letter Reveal Container -->
                <div id="letter-reveal" style="
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-family: 'Orbitron', sans-serif;
                    font-size: 48px;
                    font-weight: 900;
                    color: rgba(80, 80, 90, 1);
                    text-shadow: 0 0 30px rgba(255, 255, 255, 0.9);
                    display: none;
                    z-index: 150;
                "></div>
                
                <style>
                    @keyframes cloudFlow {
                        0% { background-position: 0% 50%; }
                        25% { background-position: 50% 60%; }
                        50% { background-position: 100% 50%; }
                        75% { background-position: 50% 40%; }
                        100% { background-position: 0% 50%; }
                    }
                    
                    @keyframes fadeToBack {
                        0% { 
                            opacity: 1; 
                            transform: translate(-50%, -50%) scale(1); 
                            filter: blur(0px);
                        }
                        100% { 
                            opacity: 0; 
                            transform: translate(-50%, -50%) scale(1.5); 
                            filter: blur(5px);
                        }
                    }
                    
                    @keyframes floatAway {
                        0% { 
                            opacity: 1; 
                            transform: scale(1); 
                            filter: blur(0px);
                        }
                        100% { 
                            opacity: 0; 
                            transform: scale(2); 
                            filter: blur(3px);
                        }
                    }
                    
                    @keyframes diamondShake {
                        0% { 
                            transform: translate(-50%, -50%) rotate(0deg) scale(1.1);
                        }
                        10% { 
                            transform: translate(calc(-50% + 1px), calc(-50% + 0.5px)) rotate(0.5deg) scale(1.1);
                        }
                        20% { 
                            transform: translate(calc(-50% - 1px), calc(-50% + 1px)) rotate(-0.5deg) scale(1.1);
                        }
                        30% { 
                            transform: translate(calc(-50% + 1.5px), calc(-50% - 0.5px)) rotate(0.8deg) scale(1.1);
                        }
                        40% { 
                            transform: translate(calc(-50% - 1.5px), calc(-50% + 1.5px)) rotate(-0.8deg) scale(1.1);
                        }
                        50% { 
                            transform: translate(calc(-50% + 2px), calc(-50% - 1px)) rotate(1deg) scale(1.1);
                        }
                        60% { 
                            transform: translate(calc(-50% - 1.5px), calc(-50% + 0.5px)) rotate(-0.8deg) scale(1.1);
                        }
                        70% { 
                            transform: translate(calc(-50% + 1px), calc(-50% - 1.5px)) rotate(0.5deg) scale(1.1);
                        }
                        80% { 
                            transform: translate(calc(-50% - 0.5px), calc(-50% + 1px)) rotate(-0.3deg) scale(1.1);
                        }
                        90% { 
                            transform: translate(calc(-50% + 0.5px), calc(-50% - 0.5px)) rotate(0.2deg) scale(1.1);
                        }
                        100% { 
                            transform: translate(-50%, -50%) rotate(0deg) scale(1.1);
                        }
                    }
                    
                    #central-symbol:hover {
                        transform: translate(-50%, -50%) scale(1.1);
                        text-shadow: 0 0 60px rgba(255, 255, 255, 1), 0 0 100px rgba(200, 200, 210, 0.8);
                    }
                </style>
            `;
            
            document.body.appendChild(welcomePanel);
            
            // Get branch references for hover animation
            const branches = [];
            for (let i = 1; i <= 8; i++) {
                branches.push(document.getElementById(`branch-${i}`));
            }
            
            const centralSymbol = document.getElementById('central-symbol');
            const questionsContainer = document.getElementById('questions-container');
            const symbolsContainer = document.getElementById('symbols-container');
            const letterReveal = document.getElementById('letter-reveal');
            
            const questions = [
                "What is this?",
                "What is this for?",
                "Is this safe?",
                "Why a diamond?",
                "Does this go anywhere?",
                "Why does this exist?",
                "Why am I questioning this?"
            ];
            
            let hovering = false;
            let questionInterval;
            let symbolInterval;
            
            // Hover to spawn questions and symbols
            centralSymbol.addEventListener('mouseenter', () => {
                hovering = true;
                
                // Animate branches on hover with staggered timing
                branches.forEach((branch, index) => {
                    if (branch) {
                        setTimeout(() => {
                            branch.style.transition = 'opacity 0.8s ease-in-out';
                            branch.style.opacity = '1';
                            
                            // Pulse animation
                            const pulseInterval = setInterval(() => {
                                if (!hovering) {
                                    clearInterval(pulseInterval);
                                    branch.style.opacity = '0';
                                } else {
                                    branch.style.opacity = Math.random() * 0.5 + 0.5; // Random between 0.5 and 1
                                }
                            }, 2000 + index * 200);
                        }, index * 100);
                    }
                });
                
                // Add shake animation to symbol
                centralSymbol.style.animation = 'diamondShake 2s ease-in-out infinite';
                
                // Spawn questions every 800ms
                questionInterval = setInterval(() => {
                    if (!hovering) return;
                    
                    const question = questions[Math.floor(Math.random() * questions.length)];
                    const questionDiv = document.createElement('div');
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 150 + Math.random() * 200;
                    const x = 50 + Math.cos(angle) * distance / window.innerWidth * 100;
                    const y = 50 + Math.sin(angle) * distance / window.innerHeight * 100;
                    
                    questionDiv.style.cssText = `
                        position: absolute;
                        top: ${y}%;
                        left: ${x}%;
                        transform: translate(-50%, -50%);
                        padding: 12px 20px;
                        background: rgba(255, 255, 255, 0.1);
                        border: 2px solid rgba(255, 255, 255, 0.9);
                        border-radius: 8px;
                        color: rgba(80, 80, 90, 1);
                        font-family: 'Orbitron', sans-serif;
                        font-size: 14px;
                        font-weight: 600;
                        white-space: nowrap;
                        box-shadow: 0 0 30px rgba(255, 255, 255, 0.9), 0 0 50px rgba(255, 255, 255, 0.6);
                        animation: fadeToBack 3s ease-out forwards;
                    `;
                    questionDiv.textContent = question;
                    questionsContainer.appendChild(questionDiv);
                    
                    setTimeout(() => questionDiv.remove(), 3000);
                }, 800);
                
                // Spawn symbols every 600ms
                symbolInterval = setInterval(() => {
                    if (!hovering) return;
                    
                    const symbolDiv = document.createElement('div');
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 150;
                    const x = 50 + Math.cos(angle) * distance / window.innerWidth * 100;
                    const y = 50 + Math.sin(angle) * distance / window.innerHeight * 100;
                    
                    symbolDiv.style.cssText = `
                        position: absolute;
                        top: ${y}%;
                        left: ${x}%;
                        font-family: 'Orbitron', sans-serif;
                        font-size: 40px;
                        color: rgba(80, 80, 90, 1);
                        border: 2px solid rgba(255, 255, 255, 0.8);
                        border-radius: 50%;
                        padding: 10px;
                        box-shadow: 0 0 25px rgba(255, 255, 255, 0.9), 0 0 40px rgba(255, 255, 255, 0.6);
                        animation: floatAway 2.5s ease-out forwards;
                    `;
                    symbolDiv.textContent = '';
                    symbolsContainer.appendChild(symbolDiv);
                    
                    setTimeout(() => symbolDiv.remove(), 2500);
                }, 600);
            });
            
            centralSymbol.addEventListener('mouseleave', () => {
                hovering = false;
                clearInterval(questionInterval);
                clearInterval(symbolInterval);
                
                // Stop shake animation
                centralSymbol.style.animation = '';
                
                // Fade out branches
                branches.forEach(branch => {
                    if (branch) {
                        branch.style.transition = 'opacity 0.5s ease-out';
                        branch.style.opacity = '0';
                    }
                });
            });
            
            // Click to reveal text letter by letter
            let clicked = false;
            centralSymbol.addEventListener('click', () => {
                if (clicked) return;
                clicked = true;
                
                playSound('active');
                hovering = false;
                clearInterval(questionInterval);
                clearInterval(symbolInterval);
                
                // Hide central symbol
                centralSymbol.style.opacity = '0';
                
                // Hide branches
                branches.forEach(branch => {
                    if (branch) {
                        branch.style.opacity = '0';
                    }
                });
                
                // Show letter reveal
                letterReveal.style.display = 'block';
                
                const fullText = "Welcome to mniExp";
                let currentText = "";
                let index = 0;
                
                const letterInterval = setInterval(() => {
                    if (index < fullText.length) {
                        currentText += fullText[index];
                        letterReveal.textContent = currentText;
                        playSound('passive');
                        index++;
                    } else {
                        clearInterval(letterInterval);
                        
                        // Wait 1 second then start tunnel
                        setTimeout(() => {
                            welcomePanel.style.transition = 'opacity 0.5s';
                            welcomePanel.style.opacity = '0';
                            setTimeout(() => {
                                welcomePanel.remove();
                                startEntranceSequence();
                            }, 500);
                        }, 1000);
                    }
                }, 80);
            });
        }
        
        function startEntranceSequence() {
            isEntranceActive = true;
            entranceProgress = 0;
            
            // Fade in the canvas smoothly
            renderer.domElement.style.transition = 'opacity 0.5s';
            renderer.domElement.style.opacity = '1';
            
            // Move camera way above
            camera.position.set(0, 100000, 0);
            camera.lookAt(0, 0, 0);
            
            // Create primary tunnel cylinder (50% transparent white)
            const tunnelGeometry = new THREE.CylinderGeometry(15, 15, 200000, 32, 1, true);
            const tunnelMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            entranceTunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
            entranceTunnel.position.y = 50000;
            scene.add(entranceTunnel);
            
            // Create wireframe cylinder inside
            const wireframeGeometry = new THREE.CylinderGeometry(14, 14, 200000, 16, 1, true);
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                wireframe: true,
                transparent: true,
                opacity: 0.8
            });
            entranceWireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            entranceWireframe.position.y = 50000;
            scene.add(entranceWireframe);
            
            // Create ring geometries that come towards user
            for (let i = 0; i < 20; i++) {
                const ringGeometry = new THREE.TorusGeometry(12, 0.5, 16, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = i * 10000;
                ring.userData.initialY = ring.position.y;
                entranceRings.push(ring);
                scene.add(ring);
            }
            
            // Create bright descent cylinder (1.5x faster than camera)
            const descentGeometry = new THREE.CylinderGeometry(2, 2, 80, 32);
            const descentMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1.0
            });
            descentCylinder = new THREE.Mesh(descentGeometry, descentMaterial);
            descentCylinder.position.set(0, 100000 + 50, -30); // Start ahead of camera
            scene.add(descentCylinder);
            
            // Create entrance particles for mystical effect
            const entranceParticleCount = 500;
            const entranceParticleGeometry = new THREE.BufferGeometry();
            const entranceParticlePositions = new Float32Array(entranceParticleCount * 3);
            
            for (let i = 0; i < entranceParticleCount; i++) {
                const i3 = i * 3;
                // Particles distributed in a sphere around the tunnel
                const radius = 20 + Math.random() * 30;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                entranceParticlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                entranceParticlePositions[i3 + 1] = 100000 + (Math.random() * 20000 - 10000);
                entranceParticlePositions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
            }
            
            entranceParticleGeometry.setAttribute('position', new THREE.BufferAttribute(entranceParticlePositions, 3));
            const entranceParticleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            entranceParticles = new THREE.Points(entranceParticleGeometry, entranceParticleMaterial);
            scene.add(entranceParticles);
            
            // Disable controls during entrance
            controlsEnabled = false;
        }
        
        function updateEntranceSequence(delta) {
            if (!isEntranceActive) return;
            
            // 8 second descent with easing
            entranceProgress += delta / 8;
            
            if (entranceProgress < 1) {
                // Smooth easing function (ease-in-out cubic)
                const easeInOutCubic = (t) => {
                    return t < 0.5
                        ? 4 * t * t * t
                        : 1 - Math.pow(-2 * t + 2, 3) / 2;
                };
                
                const easedProgress = easeInOutCubic(entranceProgress);
                
                // Descend with easing
                const startY = 100000;
                const endY = 30; // Landing zone at y=30
                camera.position.y = startY - (startY - endY) * easedProgress;
                
                // Move bright descent cylinder 1.5x faster than camera
                if (descentCylinder) {
                    descentCylinder.position.y = (startY + 50) - (startY - endY) * easedProgress * 1.5;
                    descentCylinder.position.z = camera.position.z - 30; // Stay in front of camera
                }
                
                // Add gentle camera rotation during descent for dynamic feel
                camera.rotation.z = Math.sin(entranceProgress * Math.PI * 2) * 0.05;
                
                // Rotate tunnel - speed varies with progress
                const rotationSpeed = 1 + Math.sin(entranceProgress * Math.PI) * 0.5;
                if (entranceTunnel) entranceTunnel.rotation.y += delta * 2 * rotationSpeed;
                if (entranceWireframe) entranceWireframe.rotation.y -= delta * 3 * rotationSpeed;
                
                // Move rings towards user - speed up near end
                const ringSpeed = 20000 * (1 + easedProgress);
                entranceRings.forEach((ring, i) => {
                    ring.position.y -= delta * ringSpeed;
                    if (ring.position.y < camera.position.y - 1000) {
                        ring.position.y = camera.position.y + 20000;
                    }
                    ring.rotation.z += delta * (2 + easedProgress);
                    
                    // Fade rings in and out
                    const fadeIn = Math.min(1, entranceProgress * 3);
                    const fadeOut = entranceProgress > 0.7 ? (1 - (entranceProgress - 0.7) / 0.3) : 1;
                    ring.material.opacity = 0.3 * fadeIn * fadeOut;
                });
                
                // Pulse the tunnel opacity
                if (entranceTunnel) {
                    entranceTunnel.material.opacity = 0.15 + Math.sin(entranceProgress * Math.PI * 4) * 0.05;
                }
            } else {
                // Landing sequence
                endEntranceSequence();
            }
        }
        
        function endEntranceSequence() {
            isEntranceActive = false;
            
            // Reset camera rotation
            gsap.to(camera.rotation, {
                duration: 0.5,
                z: 0,
                ease: 'power2.out'
            });
            
            // Remove tunnel and rings
            if (entranceTunnel) {
                scene.remove(entranceTunnel);
                entranceTunnel = null;
            }
            if (entranceWireframe) {
                scene.remove(entranceWireframe);
                entranceWireframe = null;
            }
            entranceRings.forEach(ring => scene.remove(ring));
            entranceRings = [];
            
            // Remove the descent cylinder - it will be replaced by landing cylinder
            if (descentCylinder) {
                scene.remove(descentCylinder);
                descentCylinder = null;
            }
            
            // Create landing cylinder effect (Megaman style)
            const landingGeometry = new THREE.CylinderGeometry(6, 6, 40, 32, 1, true);
            const landingMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 1.0,
                side: THREE.DoubleSide
            });
            landingCylinder = new THREE.Mesh(landingGeometry, landingMaterial);
            landingCylinder.position.set(camera.position.x, camera.position.y, camera.position.z - 30);
            scene.add(landingCylinder);
            
            // Megaman-style landing animation: shrink then shoot up
            let landingProgress = 0;
            const landingAnimation = setInterval(() => {
                landingProgress += 0.03; // Speed of animation
                
                if (landingProgress < 0.5) {
                    // Phase 1: Cylinder shrinks and gets thinner (0 to 0.5)
                    const shrinkProgress = landingProgress / 0.5;
                    const scale = 1 - shrinkProgress * 0.7; // Shrink to 30% size
                    landingCylinder.scale.set(scale, 1, scale);
                    landingCylinder.material.opacity = 1.0;
                } else if (landingProgress < 1) {
                    // Phase 2: Cylinder shoots straight up rapidly (0.5 to 1)
                    const shootProgress = (landingProgress - 0.5) / 0.5;
                    const shootSpeed = shootProgress * shootProgress * 150; // Accelerating upward
                    landingCylinder.position.y += shootSpeed;
                    landingCylinder.material.opacity = 1 - shootProgress;
                    // Keep it thin
                    landingCylinder.scale.set(0.3, 1, 0.3);
                } else {
                    // Animation complete
                    scene.remove(landingCylinder);
                    landingCylinder = null;
                    clearInterval(landingAnimation);
                    controlsEnabled = true;
                }
            }, 16);
            
            // Smooth camera transition to final position with better easing
            gsap.to(camera.position, {
                duration: 1.5,
                x: 0,
                y: 30,
                z: 15,
                ease: 'power3.out',
                onUpdate: () => {
                    // During transition, gradually face the elevated sphere
                    camera.lookAt(0, 30, 0);
                },
                onComplete: () => {
                    // Once at final position, face forward towards horizon
                    camera.lookAt(0, 30, -100);
                }
            });
            
            playSound('active');
        }

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Mouse look - only when holding C key (Metroid Prime style)
            if (keys.c && !isRotating) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;

                // Apply FPS-style rotation
                if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
                    // Horizontal rotation (yaw) - rotate around world Y axis
                    camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -deltaX * lookSensitivity);
                    
                    // Vertical rotation (pitch) - rotate around camera's local X axis
                    const pitchAxis = new THREE.Vector3(1, 0, 0);
                    const pitchQuaternion = new THREE.Quaternion().setFromAxisAngle(pitchAxis, -deltaY * lookSensitivity);
                    camera.quaternion.multiply(pitchQuaternion);
                    
                    // Clamp pitch to prevent looking too far up or down
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(camera.quaternion);
                    
                    // If looking too far down, clamp it
                    if (forward.y < -0.99) {
                        const correctionAxis = new THREE.Vector3(1, 0, 0);
                        const correctionAngle = -0.01;
                        const correctionQuaternion = new THREE.Quaternion().setFromAxisAngle(correctionAxis, correctionAngle);
                        camera.quaternion.multiply(correctionQuaternion);
                    }
                    // If looking too far up, clamp it
                    else if (forward.y > 0.99) {
                        const correctionAxis = new THREE.Vector3(1, 0, 0);
                        const correctionAngle = 0.01;
                        const correctionQuaternion = new THREE.Quaternion().setFromAxisAngle(correctionAxis, correctionAngle);
                        camera.quaternion.multiply(correctionQuaternion);
                    }
                }
            } else {
                // Update last mouse position even when not looking
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }

            // Orbit rotation (when dragging without C key)
            if (isRotating && !keys.c) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                const rotationSpeed = 0.005;
                const euler = new THREE.Euler(
                    deltaY * rotationSpeed,
                    deltaX * rotationSpeed,
                    0,
                    'XYZ'
                );
                
                const quaternion = new THREE.Quaternion().setFromEuler(euler);
                camera.position.applyQuaternion(quaternion);
                camera.lookAt(cameraTarget);
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }

            // Raycasting for hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects);

            if (intersects.length > 0) {
                const hoveredObj = intersects[0].object;
                if (hoveredObj !== hoveredObject) {
                    if (hoveredObject && hoveredObject !== selectedObject) {
                        hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                        hoveredObject.material.opacity = hoveredObject.userData.type === 'grid' ? 0.2 : 0.8;
                    }
                    hoveredObject = hoveredObj;
                    if (hoveredObj !== selectedObject) {
                        hoveredObj.material.color.setHex(0x888888);
                        hoveredObj.material.opacity = 0.6;
                    }
                    playSound('hover');
                }
            } else {
                if (hoveredObject && hoveredObject !== selectedObject) {
                    hoveredObject.material.color.setHex(hoveredObject.userData.originalColor);
                    hoveredObject.material.opacity = hoveredObject.userData.type === 'grid' ? 0.2 : 0.8;
                }
                hoveredObject = null;
            }
        }

        function onMouseDown(event) {
            if (event.button === 0) {
                const rect = renderer.domElement.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                raycaster.setFromCamera({ x, y }, camera);
                const intersects = raycaster.intersectObjects(interactiveObjects);
                
                // Check for cube face clicks (higher priority in OmniSense mode)
                if (omniSenseMode && omniSenseCube) {
                    const cubeIntersects = raycaster.intersectObjects(cubeFaces, false);
                    if (cubeIntersects.length > 0) {
                        const clickedFace = cubeIntersects[0].object;
                        if (clickedFace.userData.type === 'cube-face') {
                            handleCubeFaceClick(clickedFace);
                            playSound('active');
                            return; // Don't process other clicks
                        }
                    }
                }

                if (intersects.length > 0) {
                    const clickedObj = intersects[0].object;
                    
                    // Check if clicked on scroll icon
                    if (clickedObj.userData.isScrollIcon) {
                        const parentObj = clickedObj.userData.parentObject;
                        if (parentObj) {
                            // Load JSON data and show viewer
                            const objectId = parentObj.uuid;
                            const savedData = localStorage.getItem(`object_data_${objectId}`);
                            if (savedData) {
                                const data = JSON.parse(savedData);
                                if (data.isJSON) {
                                    showJSONViewer(data.body);
                                    
                                    // Move camera to center for viewing
                                    gsap.to(camera.position, {
                                        duration: 1.5,
                                        x: 0,
                                        y: 0,
                                        z: 15,
                                        ease: 'power2.inOut'
                                    });
                                    gsap.to(cameraTarget, {
                                        duration: 1.5,
                                        x: 0,
                                        y: 0,
                                        z: 0,
                                        ease: 'power2.inOut'
                                    });
                                }
                            }
                        }
                        playSound('active');
                        return; // Don't continue with normal selection
                    }
                    
                    // Reset previous selection
                    if (selectedObject) {
                        selectedObject.material.color.setHex(selectedObject.userData.originalColor);
                        selectedObject.material.opacity = selectedObject.userData.type === 'grid' ? 0.2 : 0.8;
                        // Only set emissive if material supports it
                        if (selectedObject.material.emissive) {
                            selectedObject.material.emissive.setHex(0x000000);
                            selectedObject.material.emissiveIntensity = 0;
                        }
                    }
                    
                    selectedObject = clickedObj;
                    clickedObj.material.color.setHex(0xffffff);
                    clickedObj.material.opacity = 1.0;
                    // Only set emissive if material supports it
                    if (clickedObj.material.emissive !== undefined) {
                        clickedObj.material.emissive.setHex(0xffffff);
                        clickedObj.material.emissiveIntensity = 0.5;
                    }
                    playSound('active');
                    
                    // Update UI
                    updateInspectorPanel();
                    
                    // Animate camera
                    gsap.to(camera.position, {
                        duration: 1.5,
                        x: clickedObj.position.x * 1.5,
                        y: clickedObj.position.y * 1.5,
                        z: clickedObj.position.z + 10,
                        ease: 'power2.inOut',
                        onUpdate: () => {
                            camera.lookAt(clickedObj.position);
                        }
                    });
                    
                    gsap.to(cameraTarget, {
                        duration: 1.5,
                        x: clickedObj.position.x,
                        y: clickedObj.position.y,
                        z: clickedObj.position.z,
                        ease: 'power2.inOut'
                    });
                } else {
                    isRotating = true;
                    previousMousePosition = { x: event.clientX, y: event.clientY };
                }
            }
        }

        function onMouseUp() {
            isRotating = false;
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateInspectorPanel() {
            if (selectedObject) {
                const objName = selectedObject.userData.title || selectedObject.userData.label || 'Unknown';
                document.getElementById('selected-name').textContent = objName;
                
                // Update position
                document.getElementById('object-position').textContent = 
                    `X: ${selectedObject.position.x.toFixed(2)} | Y: ${selectedObject.position.y.toFixed(2)} | Z: ${selectedObject.position.z.toFixed(2)}`;
                
                // Update rotation (convert from radians to degrees)
                document.getElementById('object-rotation').textContent = 
                    `X: ${(selectedObject.rotation.x * 180 / Math.PI).toFixed(2)} | Y: ${(selectedObject.rotation.y * 180 / Math.PI).toFixed(2)} | Z: ${(selectedObject.rotation.z * 180 / Math.PI).toFixed(2)}`;
                
                // Update scale
                document.getElementById('object-scale').textContent = 
                    `X: ${selectedObject.scale.x.toFixed(2)} | Y: ${selectedObject.scale.y.toFixed(2)} | Z: ${selectedObject.scale.z.toFixed(2)}`;
                
                // Load saved object data from localStorage
                const objectId = selectedObject.uuid; // Use THREE.js UUID
                const savedData = localStorage.getItem(`object_data_${objectId}`);
                
                if (savedData) {
                    const data = JSON.parse(savedData);
                    document.getElementById('object-data-header').value = data.header || '';
                    document.getElementById('object-data-body').value = data.body || '';
                    document.getElementById('object-data-footer').value = data.footer || '';
                    
                    // Update labels with header, footer, and icon
                    updateObjectLabel(selectedObject, data.header, data.footer, data.icon);
                    
                    // Add scroll icon if JSON detected
                    if (data.isJSON) {
                        addScrollIconToObject(selectedObject);
                    }
                    
                    // Show selected icon in UI
                    if (data.icon) {
                        if (data.icon.type === 'image' && data.icon.imageData) {
                            document.getElementById('selected-icon-text').textContent = `Image selected`;
                        } else if (data.icon.value) {
                            document.getElementById('selected-icon-text').textContent = `Selected: ${data.icon.value}`;
                        }
                    }
                } else {
                    // Clear fields if no saved data
                    document.getElementById('object-data-header').value = '';
                    document.getElementById('object-data-body').value = '';
                    document.getElementById('object-data-footer').value = '';
                    document.getElementById('selected-icon-text').textContent = 'No icon selected';
                }
                
                document.getElementById('object-details').style.display = 'block';
            } else {
                document.getElementById('selected-name').textContent = 'None';
                document.getElementById('object-details').style.display = 'none';
            }
        }
        
        function setupInspectorDataSave() {
            const submitBtn = document.getElementById('object-data-submit');
            
            // Icon selector state
            let selectedIconType = 'emoji';
            let selectedIconValue = null;
            let selectedImageData = null;
            
            if (!submitBtn) {
                console.warn('Inspector submit button not found');
                return;
            }
            
            // Icon type button handlers
            document.querySelectorAll('.icon-type-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active from all
                    document.querySelectorAll('.icon-type-btn').forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'rgba(128, 128, 128, 0.3)';
                    });
                    
                    // Add active to clicked
                    btn.classList.add('active');
                    btn.style.background = 'rgba(128, 128, 128, 0.5)';
                    
                    selectedIconType = btn.getAttribute('data-type');
                    
                    // Show appropriate picker
                    document.getElementById('emoji-picker').style.display = selectedIconType === 'emoji' ? 'grid' : 'none';
                    document.getElementById('image-picker').style.display = selectedIconType === 'image' ? 'block' : 'none';
                    document.getElementById('fontawesome-picker').style.display = selectedIconType === 'fontawesome' ? 'grid' : 'none';
                    
                    playSound('passive');
                });
            });
            
            // Emoji selection
            document.querySelectorAll('.emoji-option').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedIconValue = btn.getAttribute('data-emoji');
                    document.getElementById('selected-icon-text').textContent = `Selected: ${selectedIconValue}`;
                    playSound('passive');
                });
            });
            
            // FontAwesome selection
            document.querySelectorAll('.fa-option').forEach(btn => {
                btn.addEventListener('click', () => {
                    selectedIconValue = btn.textContent; // Using emoji representation
                    document.getElementById('selected-icon-text').textContent = `Selected: ${selectedIconValue}`;
                    playSound('passive');
                });
            });
            
            // Image upload
            const imageUpload = document.getElementById('icon-image-upload');
            if (imageUpload) {
                imageUpload.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            selectedImageData = event.target.result;
                            const preview = document.getElementById('image-preview');
                            preview.innerHTML = `<img src="${selectedImageData}" style="max-width: 100%; max-height: 100%; object-fit: contain;">`;
                            document.getElementById('selected-icon-text').textContent = `Image: ${file.name}`;
                            playSound('passive');
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
            
            // Save button handler
            submitBtn.addEventListener('click', () => {
                if (selectedObject) {
                    const objectId = selectedObject.uuid;
                    const header = document.getElementById('object-data-header').value;
                    const body = document.getElementById('object-data-body').value;
                    const footer = document.getElementById('object-data-footer').value;
                    
                    // Prepare icon data
                    let iconData = null;
                    if (selectedIconValue || selectedImageData) {
                        iconData = {
                            type: selectedIconType,
                            value: selectedIconValue,
                            imageData: selectedImageData
                        };
                    }
                    
                    // Check if body contains JSON
                    let isJSON = false;
                    try {
                        if (body && body.trim().startsWith('{') || body.trim().startsWith('[')) {
                            JSON.parse(body);
                            isJSON = true;
                        }
                    } catch (e) {
                        isJSON = false;
                    }
                    
                    const data = {
                        header: header,
                        body: body,
                        footer: footer,
                        icon: iconData,
                        isJSON: isJSON,
                        savedAt: new Date().toISOString()
                    };
                    
                    localStorage.setItem(`object_data_${objectId}`, JSON.stringify(data));
                    
                    // Update labels and icons
                    updateObjectLabel(selectedObject, header, footer, iconData);
                    
                    // Add scroll icon if JSON detected
                    if (isJSON) {
                        addScrollIconToObject(selectedObject);
                    } else if (selectedObject.userData.scrollIcon) {
                        // Remove scroll icon if body is no longer JSON
                        selectedObject.remove(selectedObject.userData.scrollIcon);
                        selectedObject.userData.scrollIcon = null;
                    }
                    
                    // Visual feedback
                    submitBtn.textContent = 'SAVED!';
                    submitBtn.style.background = 'rgba(74, 226, 144, 0.3)';
                    submitBtn.style.borderColor = 'rgba(74, 226, 144, 0.5)';
                    
                    setTimeout(() => {
                        submitBtn.textContent = 'SAVE DATA';
                        submitBtn.style.background = 'rgba(128, 128, 128, 0.3)';
                        submitBtn.style.borderColor = 'rgba(128, 128, 128, 0.5)';
                    }, 2000);
                    
                    playSound('active');
                }
            });
        }
        
        function updateObjectLabel(object, headerText, footerText, iconData) {
            // Remove existing labels
            if (object.userData.headerLabel) {
                object.remove(object.userData.headerLabel);
                if (object.userData.headerLabel.geometry) object.userData.headerLabel.geometry.dispose();
                if (object.userData.headerLabel.material) object.userData.headerLabel.material.dispose();
                object.userData.headerLabel = null;
            }
            if (object.userData.footerLabel) {
                object.remove(object.userData.footerLabel);
                if (object.userData.footerLabel.geometry) object.userData.footerLabel.geometry.dispose();
                if (object.userData.footerLabel.material) object.userData.footerLabel.material.dispose();
                object.userData.footerLabel = null;
            }
            if (object.userData.iconSprite) {
                object.remove(object.userData.iconSprite);
                if (object.userData.iconSprite.geometry) object.userData.iconSprite.geometry.dispose();
                if (object.userData.iconSprite.material) object.userData.iconSprite.material.dispose();
                object.userData.iconSprite = null;
            }
            if (object.userData.scrollIcon) {
                object.remove(object.userData.scrollIcon);
                if (object.userData.scrollIcon.geometry) object.userData.scrollIcon.geometry.dispose();
                if (object.userData.scrollIcon.material) object.userData.scrollIcon.material.dispose();
                object.userData.scrollIcon = null;
            }
            
            // Create header label if text provided
            if (headerText && headerText.trim()) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                
                // Draw background
                context.fillStyle = 'rgba(80, 80, 90, 0.9)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Border
                context.strokeStyle = 'rgba(128, 128, 128, 0.5)';
                context.lineWidth = 2;
                context.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
                
                // Text with glow
                context.font = 'bold 48px Orbitron, sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.shadowColor = 'rgba(255, 255, 255, 0.8)';
                context.shadowBlur = 15;
                context.fillStyle = '#ffffff';
                context.fillText(headerText, canvas.width / 2, canvas.height / 2);
                context.fillText(headerText, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(4, 1, 1);
                sprite.position.set(0, 3.5, 0); // Higher to not cover object
                object.add(sprite);
                object.userData.headerLabel = sprite;
            }
            
            // Create footer label if text provided
            if (footerText && footerText.trim()) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                
                // Draw background
                context.fillStyle = 'rgba(80, 80, 90, 0.9)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Border
                context.strokeStyle = 'rgba(128, 128, 128, 0.5)';
                context.lineWidth = 2;
                context.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
                
                // Text with glow
                context.font = 'bold 38px Orbitron, sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.shadowColor = 'rgba(255, 255, 255, 0.8)';
                context.shadowBlur = 15;
                context.fillStyle = '#ffffff';
                context.fillText(footerText, canvas.width / 2, canvas.height / 2);
                context.fillText(footerText, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(4, 1, 1);
                sprite.position.set(0, -2.5, 0); // Bottom of object
                object.add(sprite);
                object.userData.footerLabel = sprite;
            }
            
            // Create icon sprite if icon data provided
            if (iconData && iconData.type && iconData.value) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 256;
                
                // Semi-transparent background
                context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Border
                context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                context.lineWidth = 4;
                context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                
                if (iconData.type === 'emoji' || iconData.type === 'fontawesome') {
                    // Draw emoji/icon
                    context.font = '120px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillStyle = '#ffffff';
                    context.fillText(iconData.value, canvas.width / 2, canvas.height / 2);
                } else if (iconData.type === 'image' && iconData.imageData) {
                    // Draw image
                    const img = new Image();
                    img.src = iconData.imageData;
                    img.onload = () => {
                        context.drawImage(img, 20, 20, canvas.width - 40, canvas.height - 40);
                        const texture = new THREE.CanvasTexture(canvas);
                        if (object.userData.iconSprite && object.userData.iconSprite.material) {
                            object.userData.iconSprite.material.map = texture;
                            object.userData.iconSprite.material.needsUpdate = true;
                        }
                    };
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(1.5, 1.5, 1);
                sprite.position.set(0, 0, 0.1); // Slightly in front of object
                object.add(sprite);
                object.userData.iconSprite = sprite;
            }
        }
        
        function addScrollIconToObject(object) {
            // Remove existing scroll icon
            if (object.userData.scrollIcon) {
                object.remove(object.userData.scrollIcon);
                if (object.userData.scrollIcon.geometry) object.userData.scrollIcon.geometry.dispose();
                if (object.userData.scrollIcon.material) object.userData.scrollIcon.material.dispose();
            }
            
            // Create scroll icon
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 128;
            
            // Background
            context.fillStyle = 'rgba(100, 100, 255, 0.8)';
            context.beginPath();
            context.arc(64, 64, 60, 0, Math.PI * 2);
            context.fill();
            
            // Border
            context.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            context.lineWidth = 4;
            context.stroke();
            
            // Scroll emoji
            context.font = 'bold 60px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = '#ffffff';
            context.fillText('', 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1, 1, 1);
            sprite.position.set(1.5, 1.5, 0); // Top right corner
            sprite.userData.isScrollIcon = true;
            sprite.userData.parentObject = object;
            
            object.add(sprite);
            object.userData.scrollIcon = sprite;
            
            // Add to interactive objects for clicking
            interactiveObjects.push(sprite);
        }
        
        function showJSONViewer(jsonString) {
            const panel = document.getElementById('json-viewer-panel');
            const content = document.getElementById('json-viewer-pre');
            
            if (!panel || !content) return;
            
            // Format JSON
            try {
                const parsed = JSON.parse(jsonString);
                content.textContent = JSON.stringify(parsed, null, 2);
            } catch (e) {
                content.textContent = jsonString;
            }
            
            // Show panel
            panel.style.display = 'block';
            playSound('passive');
        }
        
        function setupJSONViewer() {
            const panel = document.getElementById('json-viewer-panel');
            const minimizedTab = document.getElementById('json-viewer-minimized');
            const closeBtn = document.getElementById('close-json-viewer');
            const minimizeBtn = document.getElementById('minimize-json-viewer');
            const toggle3DBtn = document.getElementById('toggle-3d-viewer');
            const scrollUpBtn = document.getElementById('json-scroll-up');
            const scrollDownBtn = document.getElementById('json-scroll-down');
            const contentArea = document.getElementById('json-viewer-content');
            const opacitySlider = document.getElementById('json-viewer-opacity');
            const opacityValue = document.getElementById('json-viewer-opacity-value');
            
            // Opacity slider
            if (opacitySlider && opacityValue && panel) {
                opacitySlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    opacityValue.textContent = `${Math.round(value * 100)}%`;
                    panel.style.background = `rgba(25, 25, 30, ${value})`;
                    playSound('passive');
                });
            }
            
            // Make panel draggable
            const header = document.getElementById('json-viewer-header');
            if (header && panel) {
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                
                header.addEventListener('mousedown', (e) => {
                    if (e.target === header || header.contains(e.target)) {
                        isDragging = true;
                        const rect = panel.getBoundingClientRect();
                        initialX = e.clientX - rect.left;
                        initialY = e.clientY - rect.top;
                        panel.style.transform = 'none';
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        panel.style.left = currentX + 'px';
                        panel.style.top = currentY + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
            
            // Close button
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    panel.style.display = 'none';
                    playSound('passive');
                });
            }
            
            // Minimize button
            if (minimizeBtn && panel && minimizedTab) {
                minimizeBtn.addEventListener('click', () => {
                    panel.style.display = 'none';
                    minimizedTab.style.display = 'block';
                    playSound('passive');
                });
            }
            
            // Restore from minimized
            if (minimizedTab && panel) {
                minimizedTab.addEventListener('click', () => {
                    minimizedTab.style.display = 'none';
                    panel.style.display = 'block';
                    playSound('passive');
                });
            }
            
            // Toggle 3D View
            if (toggle3DBtn) {
                toggle3DBtn.addEventListener('click', () => {
                    // Close 2D panel
                    panel.style.display = 'none';
                    
                    // Create or show 3D panel
                    show3DDataPanel();
                    playSound('active');
                });
            }
            
            // Scroll buttons
            if (scrollUpBtn && contentArea) {
                scrollUpBtn.addEventListener('click', () => {
                    contentArea.scrollBy({ top: -100, behavior: 'smooth' });
                    playSound('passive');
                });
            }
            
            if (scrollDownBtn && contentArea) {
                scrollDownBtn.addEventListener('click', () => {
                    contentArea.scrollBy({ top: 100, behavior: 'smooth' });
                    playSound('passive');
                });
            }
            
            // Close on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (panel && panel.style.display === 'block') {
                        panel.style.display = 'none';
                        playSound('passive');
                    }
                }
            });
        }
        
        let scene3DDataPanel = null;
        let scene3DDataTexture = null;
        
        function show3DDataPanel() {
            const jsonContent = document.getElementById('json-viewer-pre').textContent;
            
            // Remove existing 3D panel if exists
            if (scene3DDataPanel) {
                scene.remove(scene3DDataPanel);
                if (scene3DDataTexture) scene3DDataTexture.dispose();
            }
            
            // Create canvas for text
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 2048;
            
            // Background
            context.fillStyle = 'rgba(25, 25, 30, 0.95)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Border
            context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            context.lineWidth = 4;
            context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
            
            // Header
            context.fillStyle = 'rgba(128, 128, 128, 0.3)';
            context.fillRect(0, 0, canvas.width, 80);
            context.font = 'bold 36px Orbitron';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(' DATA VIEWER', canvas.width / 2, 50);
            
            // JSON Content
            context.font = '20px Courier New';
            context.fillStyle = '#ffffff';
            context.textAlign = 'left';
            
            const lines = jsonContent.split('\n');
            let y = 120;
            const lineHeight = 28;
            const maxWidth = canvas.width - 40;
            
            lines.forEach(line => {
                if (y < canvas.height - 40) {
                    // Wrap long lines
                    const words = line.split(' ');
                    let currentLine = '';
                    
                    words.forEach(word => {
                        const testLine = currentLine + word + ' ';
                        const metrics = context.measureText(testLine);
                        
                        if (metrics.width > maxWidth && currentLine !== '') {
                            context.fillText(currentLine, 20, y);
                            y += lineHeight;
                            currentLine = word + ' ';
                        } else {
                            currentLine = testLine;
                        }
                    });
                    
                    context.fillText(currentLine, 20, y);
                    y += lineHeight;
                }
            });
            
            // Scroll controls hint
            context.font = 'bold 24px Orbitron';
            context.fillStyle = 'rgba(255, 255, 255, 0.7)';
            context.textAlign = 'center';
            context.fillText(' W Key - Scroll Up ', canvas.width / 2, canvas.height - 50);
            context.fillText(' S Key - Scroll Down ', canvas.width / 2, canvas.height - 20);
            
            // Create texture and material
            scene3DDataTexture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: scene3DDataTexture,
                transparent: true,
                opacity: 0.95,
                side: THREE.DoubleSide
            });
            
            // Create plane geometry
            const geometry = new THREE.PlaneGeometry(10, 20);
            scene3DDataPanel = new THREE.Mesh(geometry, material);
            
            // Position at center
            scene3DDataPanel.position.set(0, 0, 0);
            scene3DDataPanel.userData.is3DPanel = true;
            scene3DDataPanel.userData.scrollOffset = 0;
            scene3DDataPanel.userData.jsonContent = jsonContent;
            scene3DDataPanel.userData.canvasHeight = canvas.height;
            
            scene.add(scene3DDataPanel);
            
            // Move camera to viewing position (adjusted for elevated sphere at y=30)
            gsap.to(camera.position, {
                duration: 1.5,
                x: 0,
                y: 30,
                z: 15,
                ease: 'power2.inOut'
            });
            
            gsap.to(cameraTarget, {
                duration: 1.5,
                x: 0,
                y: 30,
                z: 0,
                ease: 'power2.inOut'
            });
            
            // Show 3D panel controls
            const controlsPanel = document.getElementById('panel-3d-controls');
            if (controlsPanel) {
                controlsPanel.style.display = 'block';
            }
            
            // Setup 3D panel controls
            setup3DPanelControls();
        }
        
        function setup3DPanelControls() {
            const controlsPanel = document.getElementById('panel-3d-controls');
            const closeBtn = document.getElementById('close-3d-controls');
            const header = document.getElementById('panel-3d-header');
            
            // Position controls
            const posX = document.getElementById('panel-3d-pos-x');
            const posY = document.getElementById('panel-3d-pos-y');
            const posZ = document.getElementById('panel-3d-pos-z');
            
            // Rotation controls
            const rotX = document.getElementById('panel-3d-rot-x');
            const rotY = document.getElementById('panel-3d-rot-y');
            const rotZ = document.getElementById('panel-3d-rot-z');
            
            // Scale controls
            const scaX = document.getElementById('panel-3d-sca-x');
            const scaY = document.getElementById('panel-3d-sca-y');
            const scaZ = document.getElementById('panel-3d-sca-z');
            
            // Color and opacity
            const colorPicker = document.getElementById('panel-3d-color');
            const colorValue = document.getElementById('panel-3d-color-value');
            const opacitySlider = document.getElementById('panel-3d-opacity');
            const opacityValue = document.getElementById('panel-3d-opacity-value');
            
            // Buttons
            const pocketBtn = document.getElementById('save-to-pocket-3d');
            const resetBtn = document.getElementById('reset-3d-panel');
            const removeBtn = document.getElementById('remove-3d-panel');
            
            // Close button
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    controlsPanel.style.display = 'none';
                    playSound('passive');
                });
            }
            
            // Position updates
            if (posX && scene3DDataPanel) {
                posX.addEventListener('input', (e) => {
                    scene3DDataPanel.position.x = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            if (posY && scene3DDataPanel) {
                posY.addEventListener('input', (e) => {
                    scene3DDataPanel.position.y = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            if (posZ && scene3DDataPanel) {
                posZ.addEventListener('input', (e) => {
                    scene3DDataPanel.position.z = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            
            // Rotation updates
            if (rotX && scene3DDataPanel) {
                rotX.addEventListener('input', (e) => {
                    scene3DDataPanel.rotation.x = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            if (rotY && scene3DDataPanel) {
                rotY.addEventListener('input', (e) => {
                    scene3DDataPanel.rotation.y = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            if (rotZ && scene3DDataPanel) {
                rotZ.addEventListener('input', (e) => {
                    scene3DDataPanel.rotation.z = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            
            // Scale updates
            if (scaX && scene3DDataPanel) {
                scaX.addEventListener('input', (e) => {
                    scene3DDataPanel.scale.x = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            if (scaY && scene3DDataPanel) {
                scaY.addEventListener('input', (e) => {
                    scene3DDataPanel.scale.y = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            if (scaZ && scene3DDataPanel) {
                scaZ.addEventListener('input', (e) => {
                    scene3DDataPanel.scale.z = parseFloat(e.target.value);
                    playSound('passive');
                });
            }
            
            // Color update
            if (colorPicker && colorValue && scene3DDataPanel) {
                colorPicker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    colorValue.textContent = color.toUpperCase();
                    updatePanelColor(color);
                    playSound('passive');
                });
            }
            
            // Opacity update
            if (opacitySlider && opacityValue && scene3DDataPanel) {
                opacitySlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    opacityValue.textContent = `${Math.round(value * 100)}%`;
                    scene3DDataPanel.material.opacity = value;
                    playSound('passive');
                });
            }
            
            // Reset button
            if (resetBtn && scene3DDataPanel) {
                resetBtn.addEventListener('click', () => {
                    // Reset to default position
                    scene3DDataPanel.position.set(0, 0, 0);
                    scene3DDataPanel.rotation.set(0, 0, 0);
                    scene3DDataPanel.scale.set(1, 1, 1);
                    
                    // Reset sliders
                    if (posX) posX.value = 0;
                    if (posY) posY.value = 0;
                    if (posZ) posZ.value = 0;
                    if (rotX) rotX.value = 0;
                    if (rotY) rotY.value = 0;
                    if (rotZ) rotZ.value = 0;
                    if (scaX) scaX.value = 1;
                    if (scaY) scaY.value = 1;
                    if (scaZ) scaZ.value = 1;
                    
                    // Reset camera
                    gsap.to(camera.position, {
                        duration: 1,
                        x: 0,
                        y: 0,
                        z: 15,
                        ease: 'power2.inOut'
                    });
                    
                    playSound('active');
                });
            }
            
            // Remove button
            if (removeBtn && scene3DDataPanel) {
                removeBtn.addEventListener('click', () => {
                    if (confirm('Remove 3D panel from scene?')) {
                        scene.remove(scene3DDataPanel);
                        scene3DDataPanel = null;
                        controlsPanel.style.display = 'none';
                        playSound('active');
                    }
                });
            }
            
            // Put in pocket
            if (pocketBtn) {
                pocketBtn.addEventListener('click', () => {
                    // Store panel data in pocket
                    const panelData = {
                        type: '3d-panel',
                        jsonContent: scene3DDataPanel.userData.jsonContent,
                        position: {
                            x: scene3DDataPanel.position.x,
                            y: scene3DDataPanel.position.y,
                            z: scene3DDataPanel.position.z
                        },
                        rotation: {
                            x: scene3DDataPanel.rotation.x,
                            y: scene3DDataPanel.rotation.y,
                            z: scene3DDataPanel.rotation.z
                        },
                        scale: {
                            x: scene3DDataPanel.scale.x,
                            y: scene3DDataPanel.scale.y,
                            z: scene3DDataPanel.scale.z
                        }
                    };
                    
                    // Find next available pocket slot
                    let slotIndex = 0;
                    while (slotIndex < maxPocketSlots && pocketItems[slotIndex]) {
                        slotIndex++;
                    }
                    
                    if (slotIndex < maxPocketSlots) {
                        pocketItems[slotIndex] = panelData;
                        localStorage.setItem(`pocket_item_${slotIndex}`, JSON.stringify(panelData));
                        
                        // Remove from scene
                        scene.remove(scene3DDataPanel);
                        scene3DDataPanel = null;
                        controlsPanel.style.display = 'none';
                        
                        // Visual feedback
                        pocketBtn.textContent = ' STORED!';
                        setTimeout(() => {
                            pocketBtn.textContent = ' SAVE TO POCKET';
                        }, 2000);
                        
                        playSound('active');
                    } else {
                        alert('Pocket is full!');
                    }
                });
            }
            
            // Make controls panel draggable
            if (header && controlsPanel) {
                let isDragging = false;
                let currentX;
                let currentY;
                let initialX;
                let initialY;
                
                header.addEventListener('mousedown', (e) => {
                    if (e.target === header || header.contains(e.target.querySelector('span'))) {
                        isDragging = true;
                        const rect = controlsPanel.getBoundingClientRect();
                        initialX = e.clientX - rect.left;
                        initialY = e.clientY - rect.top;
                        controlsPanel.style.transform = 'none';
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        e.preventDefault();
                        currentX = e.clientX - initialX;
                        currentY = e.clientY - initialY;
                        controlsPanel.style.right = 'auto';
                        controlsPanel.style.left = currentX + 'px';
                        controlsPanel.style.top = currentY + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }
        }
        
        function updatePanelColor(color) {
            if (!scene3DDataPanel) return;
            
            const jsonContent = scene3DDataPanel.userData.jsonContent;
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 2048;
            
            // Convert hex to RGB
            const r = parseInt(color.substr(1,2), 16);
            const g = parseInt(color.substr(3,2), 16);
            const b = parseInt(color.substr(5,2), 16);
            
            // Background with new color
            context.fillStyle = `rgba(${r}, ${g}, ${b}, 0.95)`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Border
            context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            context.lineWidth = 4;
            context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
            
            // Header
            context.fillStyle = 'rgba(128, 128, 128, 0.3)';
            context.fillRect(0, 0, canvas.width, 80);
            context.font = 'bold 36px Orbitron';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(' DATA VIEWER', canvas.width / 2, 50);
            
            // JSON Content
            context.font = '20px Courier New';
            context.fillStyle = '#ffffff';
            context.textAlign = 'left';
            
            const lines = jsonContent.split('\n');
            let y = 120;
            const lineHeight = 28;
            const maxWidth = canvas.width - 40;
            
            lines.forEach(line => {
                if (y < canvas.height - 40) {
                    const words = line.split(' ');
                    let currentLine = '';
                    
                    words.forEach(word => {
                        const testLine = currentLine + word + ' ';
                        const metrics = context.measureText(testLine);
                        
                        if (metrics.width > maxWidth && currentLine !== '') {
                            context.fillText(currentLine, 20, y);
                            y += lineHeight;
                            currentLine = word + ' ';
                        } else {
                            currentLine = testLine;
                        }
                    });
                    
                    context.fillText(currentLine, 20, y);
                    y += lineHeight;
                }
            });
            
            // Scroll hints
            context.font = 'bold 24px Orbitron';
            context.fillStyle = 'rgba(255, 255, 255, 0.7)';
            context.textAlign = 'center';
            context.fillText(' W Key - Scroll Up ', canvas.width / 2, canvas.height - 50);
            context.fillText(' S Key - Scroll Down ', canvas.width / 2, canvas.height - 20);
            
            // Update texture
            const newTexture = new THREE.CanvasTexture(canvas);
            scene3DDataPanel.material.map = newTexture;
            scene3DDataPanel.material.needsUpdate = true;
            
            // Dispose old texture
            if (scene3DDataTexture) scene3DDataTexture.dispose();
            scene3DDataTexture = newTexture;
        }
        
        // Add scroll functionality for 3D panel in animate loop
        window.scroll3DPanel = function(direction) {
            if (scene3DDataPanel && scene3DDataPanel.userData.is3DPanel) {
                const scrollAmount = 0.5;
                scene3DDataPanel.userData.scrollOffset += direction * scrollAmount;
                
                // Update texture offset for scrolling effect
                if (scene3DDataPanel.material.map) {
                    scene3DDataPanel.material.map.offset.y = scene3DDataPanel.userData.scrollOffset * 0.001;
                    scene3DDataPanel.material.map.needsUpdate = true;
                }
            }
        };


        function setupPanelControls() {
            const panel = document.getElementById('inspector-panel');
            const header = document.getElementById('panel-header');
            const minimizeBtn = document.getElementById('minimize-btn');
            const closeBtn = document.getElementById('close-btn');

            if (!panel || !header || !minimizeBtn || !closeBtn) {
                console.warn('Inspector panel elements not found');
                return;
            }

            // Minimize
            minimizeBtn.addEventListener('click', () => {
                panel.classList.toggle('minimized');
                const content = document.getElementById('panel-content');
                if (content) {
                    content.classList.toggle('hidden');
                }
                minimizeBtn.textContent = panel.classList.contains('minimized') ? '' : '_';
            });

            // Close (hide via toggle class)
            closeBtn.addEventListener('click', () => {
                panel.classList.remove('visible');
                playSound('passive');
            });

            // Drag
            header.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStartX = e.clientX - panel.offsetLeft;
                dragStartY = e.clientY - panel.offsetTop;
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    panel.style.left = (e.clientX - dragStartX) + 'px';
                    panel.style.top = (e.clientY - dragStartY) + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                isResizing = false;
            });
            
            // Inspector resize
            const resizeHandle = document.getElementById('inspector-resize-handle');
            let isResizing = false;
            let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight;
            
            if (resizeHandle) {
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    isResizing = true;
                    resizeStartX = e.clientX;
                    resizeStartY = e.clientY;
                    resizeStartWidth = panel.offsetWidth;
                    resizeStartHeight = panel.offsetHeight;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isResizing) {
                        const newWidth = resizeStartWidth + (e.clientX - resizeStartX);
                        const newHeight = resizeStartHeight + (e.clientY - resizeStartY);
                        panel.style.width = Math.max(320, newWidth) + 'px';
                        panel.style.maxHeight = Math.max(200, newHeight) + 'px';
                    }
                });
            }
            
            // Info Section Toggle
            const infoToggle = document.getElementById('info-toggle');
            const infoContent = document.getElementById('info-content');
            const infoArrow = document.getElementById('info-arrow');
            
            if (infoToggle && infoContent && infoArrow) {
                infoToggle.addEventListener('click', () => {
                    const isExpanded = infoContent.style.display !== 'none';
                    
                    if (isExpanded) {
                        // Collapse
                        infoContent.style.display = 'none';
                        infoArrow.style.transform = 'rotate(0deg)';
                        infoArrow.textContent = '';
                        infoToggle.querySelector('span:last-child').textContent = 'Click to expand';
                    } else {
                        // Expand
                        infoContent.style.display = 'block';
                        infoArrow.style.transform = 'rotate(90deg)';
                        infoArrow.textContent = '';
                        infoToggle.querySelector('span:last-child').textContent = 'Click to collapse';
                    }
                    playSound('passive');
                });
            }
            
            // MySpace Panel Setup
            const myspacePanel = document.getElementById('myspace-panel');
            const myspaceHeader = document.getElementById('myspace-panel-header');
            const myspaceMinimizeBtn = document.getElementById('myspace-minimize-btn');
            const myspaceCloseBtn = document.getElementById('myspace-close-btn');
            
            if (myspacePanel && myspaceHeader && myspaceMinimizeBtn && myspaceCloseBtn) {
                // Minimize
                myspaceMinimizeBtn.addEventListener('click', () => {
                    myspacePanel.classList.toggle('minimized');
                    const content = document.getElementById('myspace-panel-content');
                    if (content) {
                        content.classList.toggle('hidden');
                    }
                    myspaceMinimizeBtn.textContent = myspacePanel.classList.contains('minimized') ? '' : '_';
                });
                
                // Close
                myspaceCloseBtn.addEventListener('click', () => {
                    myspacePanel.style.display = 'none';
                    playSound('passive');
                });
                
                // Drag
                let myspaceDragging = false;
                let myspaceDragStartX, myspaceDragStartY;
                
                myspaceHeader.addEventListener('mousedown', (e) => {
                    myspaceDragging = true;
                    myspaceDragStartX = e.clientX - myspacePanel.offsetLeft;
                    myspaceDragStartY = e.clientY - myspacePanel.offsetTop;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (myspaceDragging) {
                        myspacePanel.style.left = (e.clientX - myspaceDragStartX) + 'px';
                        myspacePanel.style.top = (e.clientY - myspaceDragStartY) + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    myspaceDragging = false;
                    myspaceResizing = false;
                });
                
                // Resize
                const myspaceResizeHandle = document.getElementById('myspace-resize-handle');
                let myspaceResizing = false;
                let myspaceResizeStartX, myspaceResizeStartY, myspaceResizeStartWidth, myspaceResizeStartHeight;
                
                if (myspaceResizeHandle) {
                    myspaceResizeHandle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        myspaceResizing = true;
                        myspaceResizeStartX = e.clientX;
                        myspaceResizeStartY = e.clientY;
                        myspaceResizeStartWidth = myspacePanel.offsetWidth;
                        myspaceResizeStartHeight = myspacePanel.offsetHeight;
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (myspaceResizing) {
                            const newWidth = myspaceResizeStartWidth + (e.clientX - myspaceResizeStartX);
                            const newHeight = myspaceResizeStartHeight + (e.clientY - myspaceResizeStartY);
                            myspacePanel.style.width = Math.max(320, newWidth) + 'px';
                            myspacePanel.style.maxHeight = Math.max(200, newHeight) + 'px';
                        }
                    });
                }
                
                // Summon/DeSummon Toggle
                const summonBtn = document.getElementById('summon-toggle-btn');
                let myspaceSummoned = true;
                
                if (summonBtn) {
                    summonBtn.addEventListener('click', () => {
                        myspaceSummoned = !myspaceSummoned;
                        summonBtn.classList.toggle('active');
                        summonBtn.textContent = myspaceSummoned ? ' SUMMONED' : ' DESUMMONED';
                        
                        // Toggle MySpace grid visibility
                        if (mySpaceGroup) {
                            mySpaceGroup.visible = myspaceSummoned;
                        }
                        playSound('active');
                    });
                }
                
                // MyZone Toggle
                const myzoneBtn = document.getElementById('myzone-toggle-btn');
                let myzoneActive = false;
                
                if (myzoneBtn) {
                    myzoneBtn.addEventListener('click', () => {
                        myzoneActive = !myzoneActive;
                        myzoneBtn.classList.toggle('active');
                        myzoneBtn.textContent = myzoneActive ? ' LOCKED' : 'LOCK TO VIEW';
                        
                        window.myzoneLocked = myzoneActive;
                        playSound('active');
                    });
                }
                
                // Orbit Controls Panel Handlers
                const orbitPanel = document.getElementById('orbit-controls-panel');
                const orbitHeader = document.getElementById('orbit-panel-header');
                const orbitMinimizeBtn = document.getElementById('orbit-minimize-btn');
                const orbitCloseBtn = document.getElementById('orbit-close-btn');
                
                if (orbitPanel && orbitHeader && orbitMinimizeBtn && orbitCloseBtn) {
                    // Minimize
                    orbitMinimizeBtn.addEventListener('click', () => {
                        orbitPanel.classList.toggle('minimized');
                        const content = document.getElementById('orbit-panel-content');
                        if (content) {
                            content.classList.toggle('hidden');
                        }
                        orbitMinimizeBtn.textContent = orbitPanel.classList.contains('minimized') ? '' : '_';
                    });
                    
                    // Close
                    orbitCloseBtn.addEventListener('click', () => {
                        orbitPanel.style.display = 'none';
                        playSound('passive');
                    });
                    
                    // Drag
                    let orbitDragging = false;
                    let orbitDragStartX, orbitDragStartY;
                    
                    orbitHeader.addEventListener('mousedown', (e) => {
                        orbitDragging = true;
                        orbitDragStartX = e.clientX - orbitPanel.offsetLeft;
                        orbitDragStartY = e.clientY - orbitPanel.offsetTop;
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (orbitDragging) {
                            orbitPanel.style.left = (e.clientX - orbitDragStartX) + 'px';
                            orbitPanel.style.top = (e.clientY - orbitDragStartY) + 'px';
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        orbitDragging = false;
                        orbitResizing = false;
                    });
                    
                    // Resize
                    const orbitResizeHandle = orbitPanel.querySelector('.resize-handle');
                    let orbitResizing = false;
                    let orbitResizeStartX, orbitResizeStartY, orbitResizeStartWidth, orbitResizeStartHeight;
                    
                    if (orbitResizeHandle) {
                        orbitResizeHandle.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            orbitResizing = true;
                            orbitResizeStartX = e.clientX;
                            orbitResizeStartY = e.clientY;
                            orbitResizeStartWidth = orbitPanel.offsetWidth;
                            orbitResizeStartHeight = orbitPanel.offsetHeight;
                        });
                        
                        document.addEventListener('mousemove', (e) => {
                            if (orbitResizing) {
                                const newWidth = orbitResizeStartWidth + (e.clientX - orbitResizeStartX);
                                const newHeight = orbitResizeStartHeight + (e.clientY - orbitResizeStartY);
                                orbitPanel.style.width = Math.max(320, newWidth) + 'px';
                                orbitPanel.style.maxHeight = Math.max(200, newHeight) + 'px';
                            }
                        });
                    }
                }
                
                // Particle Behavior Panel Handlers
                const particlePanel = document.getElementById('particle-behavior-panel');
                const particleHeader = document.getElementById('particle-behavior-header');
                const particleMinimizeBtn = document.getElementById('particle-minimize-btn');
                const particleCloseBtn = document.getElementById('particle-close-btn');
                
                if (particlePanel && particleHeader && particleMinimizeBtn && particleCloseBtn) {
                    // Minimize
                    particleMinimizeBtn.addEventListener('click', () => {
                        particlePanel.classList.toggle('minimized');
                        const content = document.getElementById('particle-panel-content');
                        if (content) {
                            content.classList.toggle('hidden');
                        }
                        particleMinimizeBtn.textContent = particlePanel.classList.contains('minimized') ? '' : '_';
                    });
                    
                    // Close
                    particleCloseBtn.addEventListener('click', () => {
                        particlePanel.style.display = 'none';
                        playSound('passive');
                    });
                    
                    // Drag
                    let particleDragging = false;
                    let particleDragStartX, particleDragStartY;
                    
                    particleHeader.addEventListener('mousedown', (e) => {
                        particleDragging = true;
                        particleDragStartX = e.clientX - particlePanel.offsetLeft;
                        particleDragStartY = e.clientY - particlePanel.offsetTop;
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (particleDragging) {
                            particlePanel.style.left = (e.clientX - particleDragStartX) + 'px';
                            particlePanel.style.top = (e.clientY - particleDragStartY) + 'px';
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        particleDragging = false;
                        particleResizing = false;
                    });
                    
                    // Resize
                    const particleResizeHandle = particlePanel.querySelector('.resize-handle');
                    let particleResizing = false;
                    let particleResizeStartX, particleResizeStartY, particleResizeStartWidth, particleResizeStartHeight;
                    
                    if (particleResizeHandle) {
                        particleResizeHandle.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            particleResizing = true;
                            particleResizeStartX = e.clientX;
                            particleResizeStartY = e.clientY;
                            particleResizeStartWidth = particlePanel.offsetWidth;
                            particleResizeStartHeight = particlePanel.offsetHeight;
                        });
                        
                        document.addEventListener('mousemove', (e) => {
                            if (particleResizing) {
                                const newWidth = particleResizeStartWidth + (e.clientX - particleResizeStartX);
                                const newHeight = particleResizeStartHeight + (e.clientY - particleResizeStartY);
                                particlePanel.style.width = Math.max(320, newWidth) + 'px';
                                particlePanel.style.maxHeight = Math.max(200, newHeight) + 'px';
                            }
                        });
                    }
                }
                
                // User Controls Panel Handlers
                const userPanel = document.getElementById('user-controls-panel');
                const userHeader = document.getElementById('user-panel-header');
                const userMinimizeBtn = document.getElementById('user-minimize-btn');
                const userCloseBtn = document.getElementById('user-close-btn');
                
                if (userPanel && userHeader && userMinimizeBtn && userCloseBtn) {
                    // Minimize
                    userMinimizeBtn.addEventListener('click', () => {
                        userPanel.classList.toggle('minimized');
                        const content = document.getElementById('user-panel-content');
                        if (content) {
                            content.classList.toggle('hidden');
                        }
                        userMinimizeBtn.textContent = userPanel.classList.contains('minimized') ? '' : '_';
                    });
                    
                    // Close
                    userCloseBtn.addEventListener('click', () => {
                        userPanel.style.display = 'none';
                        playSound('passive');
                    });
                    
                    // Drag
                    let userDragging = false;
                    let userDragStartX, userDragStartY;
                    
                    userHeader.addEventListener('mousedown', (e) => {
                        userDragging = true;
                        userDragStartX = e.clientX - userPanel.offsetLeft;
                        userDragStartY = e.clientY - userPanel.offsetTop;
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (userDragging) {
                            userPanel.style.left = (e.clientX - userDragStartX) + 'px';
                            userPanel.style.top = (e.clientY - userDragStartY) + 'px';
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        userDragging = false;
                        userResizing = false;
                    });
                    
                    // Resize
                    const userResizeHandle = userPanel.querySelector('.resize-handle');
                    let userResizing = false;
                    let userResizeStartX, userResizeStartY, userResizeStartWidth, userResizeStartHeight;
                    
                    if (userResizeHandle) {
                        userResizeHandle.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            userResizing = true;
                            userResizeStartX = e.clientX;
                            userResizeStartY = e.clientY;
                            userResizeStartWidth = userPanel.offsetWidth;
                            userResizeStartHeight = userPanel.offsetHeight;
                        });
                        
                        document.addEventListener('mousemove', (e) => {
                            if (userResizing) {
                                const newWidth = userResizeStartWidth + (e.clientX - userResizeStartX);
                                const newHeight = userResizeStartHeight + (e.clientY - userResizeStartY);
                                userPanel.style.width = Math.max(320, newWidth) + 'px';
                                userPanel.style.maxHeight = Math.max(200, newHeight) + 'px';
                            }
                        });
                    }
                }
                
                // Default Space Panel Handlers
                const defaultSpacePanel = document.getElementById('default-space-panel');
                const defaultSpaceHeader = document.getElementById('default-space-header');
                const defaultSpaceMinimizeBtn = document.getElementById('default-space-minimize-btn');
                const defaultSpaceCloseBtn = document.getElementById('default-space-close-btn');
                
                if (defaultSpacePanel && defaultSpaceHeader && defaultSpaceMinimizeBtn && defaultSpaceCloseBtn) {
                    // Minimize
                    defaultSpaceMinimizeBtn.addEventListener('click', () => {
                        defaultSpacePanel.classList.toggle('minimized');
                        const content = document.getElementById('default-space-content');
                        if (content) {
                            content.classList.toggle('hidden');
                        }
                        defaultSpaceMinimizeBtn.textContent = defaultSpacePanel.classList.contains('minimized') ? '' : '_';
                    });
                    
                    // Close
                    defaultSpaceCloseBtn.addEventListener('click', () => {
                        defaultSpacePanel.style.display = 'none';
                        playSound('passive');
                    });
                    
                    // Drag
                    let defaultSpaceDragging = false;
                    let defaultSpaceDragStartX, defaultSpaceDragStartY;
                    
                    defaultSpaceHeader.addEventListener('mousedown', (e) => {
                        defaultSpaceDragging = true;
                        defaultSpaceDragStartX = e.clientX - defaultSpacePanel.offsetLeft;
                        defaultSpaceDragStartY = e.clientY - defaultSpacePanel.offsetTop;
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (defaultSpaceDragging) {
                            defaultSpacePanel.style.left = (e.clientX - defaultSpaceDragStartX) + 'px';
                            defaultSpacePanel.style.top = (e.clientY - defaultSpaceDragStartY) + 'px';
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        defaultSpaceDragging = false;
                        defaultSpaceResizing = false;
                    });
                    
                    // Resize
                    const defaultSpaceResizeHandle = defaultSpacePanel.querySelector('.resize-handle');
                    let defaultSpaceResizing = false;
                    let defaultSpaceResizeStartX, defaultSpaceResizeStartY, defaultSpaceResizeStartWidth, defaultSpaceResizeStartHeight;
                    
                    if (defaultSpaceResizeHandle) {
                        defaultSpaceResizeHandle.addEventListener('mousedown', (e) => {
                            e.stopPropagation();
                            defaultSpaceResizing = true;
                            defaultSpaceResizeStartX = e.clientX;
                            defaultSpaceResizeStartY = e.clientY;
                            defaultSpaceResizeStartWidth = defaultSpacePanel.offsetWidth;
                            defaultSpaceResizeStartHeight = defaultSpacePanel.offsetHeight;
                        });
                        
                        document.addEventListener('mousemove', (e) => {
                            if (defaultSpaceResizing) {
                                const newWidth = defaultSpaceResizeStartWidth + (e.clientX - defaultSpaceResizeStartX);
                                const newHeight = defaultSpaceResizeStartHeight + (e.clientY - defaultSpaceResizeStartY);
                                defaultSpacePanel.style.width = Math.max(320, newWidth) + 'px';
                                defaultSpacePanel.style.maxHeight = Math.max(200, newHeight) + 'px';
                            }
                        });
                    }
                    
                    // Dark/Light Mode Checkboxes
                    const darkModeCheckbox = document.getElementById('dark-mode-checkbox');
                    const lightModeCheckbox = document.getElementById('light-mode-checkbox');
                    
                    if (darkModeCheckbox && lightModeCheckbox) {
                        darkModeCheckbox.addEventListener('change', () => {
                            if (darkModeCheckbox.checked) {
                                lightModeCheckbox.checked = false;
                            }
                        });
                        
                        lightModeCheckbox.addEventListener('change', () => {
                            if (lightModeCheckbox.checked) {
                                darkModeCheckbox.checked = false;
                            }
                        });
                    }
                    
                    // Skybox file input
                    const skyboxFileInput = document.getElementById('skybox-file-input');
                    const skyboxFilename = document.getElementById('skybox-filename');
                    
                    if (skyboxFileInput && skyboxFilename) {
                        skyboxFileInput.addEventListener('change', (e) => {
                            const file = e.target.files[0];
                            if (file) {
                                skyboxFilename.textContent = file.name;
                            } else {
                                skyboxFilename.textContent = 'No file selected';
                            }
                        });
                    }
                    
                    // Remove skybox button
                    const removeSkyboxBtn = document.getElementById('remove-skybox-btn');
                    if (removeSkyboxBtn) {
                        removeSkyboxBtn.addEventListener('click', () => {
                            if (skyboxFileInput) {
                                skyboxFileInput.value = '';
                                skyboxFilename.textContent = 'No file selected';
                            }
                            // Remove skybox from scene
                            if (skyboxMesh && scene) {
                                scene.remove(skyboxMesh);
                                if (skyboxMesh.geometry) skyboxMesh.geometry.dispose();
                                if (skyboxMesh.material) {
                                    if (skyboxMesh.material.map) skyboxMesh.material.map.dispose();
                                    skyboxMesh.material.dispose();
                                }
                                skyboxMesh = null;
                                console.log('Skybox removed');
                            }
                            playSound('passive');
                        });
                    }
                }
                
                // UPDATE BUTTON HANDLERS
                
                // Slider value update handlers
                const sliderHandlers = [
                    { slider: 'particle-count-slider', display: 'particle-count-value' },
                    { slider: 'particle-size-slider', display: 'particle-size-value', decimals: 1 },
                    { slider: 'particle-x-range', display: 'particle-x-range-value' },
                    { slider: 'particle-y-range', display: 'particle-y-range-value' },
                    { slider: 'particle-z-range', display: 'particle-z-range-value' },
                    { slider: 'particle-speed-slider', display: 'particle-speed-value', decimals: 1 },
                    { slider: 'particle-opacity-slider', display: 'particle-opacity-value', isPercent: true },
                    { slider: 'user-move-speed', display: 'user-move-speed-value', decimals: 1 },
                    { slider: 'user-jump-speed', display: 'user-jump-speed-value', decimals: 1 },
                    { slider: 'user-sprint-mult', display: 'user-sprint-mult-value', decimals: 1, suffix: 'x' },
                    { slider: 'user-gravity', display: 'user-gravity-value', decimals: 1 },
                    { slider: 'user-look-sens', display: 'user-look-sens-value', decimals: 4 }
                ];
                
                sliderHandlers.forEach(({ slider, display, decimals = 0, isPercent = false, suffix = '' }) => {
                    const sliderEl = document.getElementById(slider);
                    const displayEl = document.getElementById(display);
                    if (sliderEl && displayEl) {
                        sliderEl.addEventListener('input', (e) => {
                            let value = parseFloat(e.target.value);
                            if (isPercent) {
                                displayEl.textContent = Math.round(value * 100) + '%';
                            } else {
                                displayEl.textContent = value.toFixed(decimals) + suffix;
                            }
                        });
                    }
                });
                
                // Particle Behavior Update Button
                const particleUpdateBtn = document.getElementById('particle-update-btn');
                if (particleUpdateBtn) {
                    particleUpdateBtn.addEventListener('click', () => {
                        // Get all particle settings
                        const count = parseInt(document.getElementById('particle-count-slider')?.value || 5000);
                        const size = parseFloat(document.getElementById('particle-size-slider')?.value || 1);
                        const color = document.getElementById('particle-color-picker')?.value || '#ffffff';
                        const xRange = parseInt(document.getElementById('particle-x-range')?.value || 100);
                        const yRange = parseInt(document.getElementById('particle-y-range')?.value || 100);
                        const zRange = parseInt(document.getElementById('particle-z-range')?.value || 100);
                        const speed = parseFloat(document.getElementById('particle-speed-slider')?.value || 1);
                        const opacity = parseFloat(document.getElementById('particle-opacity-slider')?.value || 0.8);
                        
                        console.log('Updating particles:', { count, size, color, xRange, yRange, zRange, speed, opacity });
                        
                        // Update global variables
                        particleSize = size;
                        particleColor = parseInt(color.replace('#', '0x'));
                        particleXRange = xRange;
                        particleYRange = yRange;
                        particleZRange = zRange;
                        particleSpeed = speed;
                        particleOpacity = opacity;
                        
                        // Update particle material color, size, and opacity
                        if (particleSystem && particleSystem.material) {
                            particleSystem.material.color.setStyle(color);
                            particleSystem.material.size = size * 0.05;
                            particleSystem.material.opacity = opacity;
                            particleSystem.material.needsUpdate = true;
                        }
                        
                        // Update particle velocities based on axis ranges and speed
                        if (particleVelocities) {
                            const speedFactor = speed * 0.02;
                            for (let i = 0; i < particleVelocities.length; i += 3) {
                                particleVelocities[i] = (Math.random() - 0.5) * (xRange / 100) * speedFactor;
                                particleVelocities[i + 1] = (Math.random() - 0.5) * (yRange / 100) * speedFactor;
                                particleVelocities[i + 2] = (Math.random() - 0.5) * (zRange / 100) * speedFactor;
                            }
                        }
                        
                        playSound('active');
                    });
                }
                
                // Orbit Controls Update Button
                const orbitUpdateBtn = document.getElementById('orbit-update-btn');
                if (orbitUpdateBtn) {
                    orbitUpdateBtn.addEventListener('click', () => {
                        console.log('Updating orbit controls...');
                        
                        // Apply updates (implement actual orbit controls updates here)
                        playSound('active');
                        alert('Orbit controls updated!');
                    });
                }
                
                // User Controls Update Button
                const userUpdateBtn = document.getElementById('user-update-btn');
                if (userUpdateBtn) {
                    userUpdateBtn.addEventListener('click', () => {
                        moveSpeed = parseFloat(document.getElementById('user-move-speed')?.value || 0.2);
                        jumpSpeed = parseFloat(document.getElementById('user-jump-speed')?.value || 1);
                        sprintMultiplier = parseFloat(document.getElementById('user-sprint-mult')?.value || 2);
                        userGravity = parseFloat(document.getElementById('user-gravity')?.value || 0.5);
                        lookSensitivity = parseFloat(document.getElementById('user-look-sens')?.value || 0.002);
                        
                        console.log('User controls updated:', { moveSpeed, jumpSpeed, sprintMultiplier, userGravity, lookSensitivity });
                        
                        playSound('active');
                    });
                }
                
                // God Mode Toggle
                const godmodeBtn = document.getElementById('user-godmode-btn');
                if (godmodeBtn) {
                    godmodeBtn.addEventListener('click', () => {
                        godMode = !godMode;
                        godmodeBtn.classList.toggle('active');
                        godmodeBtn.textContent = godMode ? ' GOD MODE ON' : 'GOD MODE OFF';
                        
                        if (godMode) {
                            // Apply God Mode settings
                            moveSpeed = 10;
                            userGravity = 0;
                            document.getElementById('user-move-speed').value = '10';
                            document.getElementById('user-move-speed-value').textContent = '10.0';
                            document.getElementById('user-gravity').value = '0';
                            document.getElementById('user-gravity-value').textContent = '0';
                            console.log('God Mode ON - moveSpeed:', moveSpeed, 'gravity:', userGravity);
                        } else {
                            // Reset to defaults
                            moveSpeed = 0.2;
                            userGravity = 0.5;
                            document.getElementById('user-move-speed').value = '0.2';
                            document.getElementById('user-move-speed-value').textContent = '0.2';
                            document.getElementById('user-gravity').value = '0.5';
                            document.getElementById('user-gravity-value').textContent = '0.5';
                            console.log('God Mode OFF - moveSpeed:', moveSpeed, 'gravity:', userGravity);
                        }
                        
                        playSound('active');
                    });
                }
                
                // Default Space Update Button
                const defaultSpaceUpdateBtn = document.getElementById('default-space-update-btn');
                if (defaultSpaceUpdateBtn) {
                    defaultSpaceUpdateBtn.addEventListener('click', () => {
                        const darkMode = document.getElementById('dark-mode-checkbox')?.checked;
                        const lightMode = document.getElementById('light-mode-checkbox')?.checked;
                        const bgColor = document.getElementById('default-bg-color-picker')?.value || '#a1a1a1';
                        const gridColor = document.getElementById('grid-color-picker')?.value || '#ffffff';
                        const skyboxFile = document.getElementById('skybox-file-input')?.files[0];
                        
                        console.log('Updating default space:', { darkMode, lightMode, bgColor, gridColor, skyboxFile });
                        
                        // Apply background color
                        if (scene) {
                            scene.background = new THREE.Color(bgColor);
                        }
                        
                        // Apply grid color
                        if (gridHelper) {
                            gridHelper.material.color.setStyle(gridColor);
                        }
                        
                        // Handle skybox if file is selected
                        if (skyboxFile) {
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                const isVideo = skyboxFile.type.startsWith('video/');
                                
                                if (isVideo) {
                                    // Create video texture
                                    const video = document.createElement('video');
                                    video.src = e.target.result;
                                    video.loop = true;
                                    video.muted = true;
                                    video.play();
                                    
                                    const videoTexture = new THREE.VideoTexture(video);
                                    videoTexture.minFilter = THREE.LinearFilter;
                                    videoTexture.magFilter = THREE.LinearFilter;
                                    
                                    // Remove old skybox if exists
                                    if (skyboxMesh) {
                                        scene.remove(skyboxMesh);
                                    }
                                    
                                    // Create sphere for video skybox
                                    const skyboxGeometry = new THREE.SphereGeometry(500, 60, 40);
                                    const skyboxMaterial = new THREE.MeshBasicMaterial({
                                        map: videoTexture,
                                        side: THREE.BackSide
                                    });
                                    skyboxMesh = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                                    scene.add(skyboxMesh);
                                    
                                    console.log('Video skybox loaded:', skyboxFile.name);
                                } else {
                                    // Create image texture
                                    const textureLoader = new THREE.TextureLoader();
                                    textureLoader.load(e.target.result, (texture) => {
                                        // Remove old skybox if exists
                                        if (skyboxMesh) {
                                            scene.remove(skyboxMesh);
                                        }
                                        
                                        // Create sphere for image skybox
                                        const skyboxGeometry = new THREE.SphereGeometry(500, 60, 40);
                                        const skyboxMaterial = new THREE.MeshBasicMaterial({
                                            map: texture,
                                            side: THREE.BackSide
                                        });
                                        skyboxMesh = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
                                        scene.add(skyboxMesh);
                                        
                                        console.log('Image skybox loaded:', skyboxFile.name);
                                    });
                                }
                            };
                            reader.readAsDataURL(skyboxFile);
                        }
                        
                        playSound('active');
                    });
                }
                
                // Rotation Controls
                const rotateUpBtn = document.getElementById('rotate-up-btn');
                const rotateDownBtn = document.getElementById('rotate-down-btn');
                const rotateLeftBtn = document.getElementById('rotate-left-btn');
                const rotateRightBtn = document.getElementById('rotate-right-btn');
                
                if (rotateUpBtn) {
                    rotateUpBtn.addEventListener('click', () => {
                        if (mySpaceGroup) {
                            gsap.to(mySpaceGroup.rotation, {
                                duration: 0.6,
                                x: mySpaceGroup.rotation.x + Math.PI / 4,
                                ease: 'power2.inOut'
                            });
                        }
                        playSound('passive');
                    });
                }
                
                if (rotateDownBtn) {
                    rotateDownBtn.addEventListener('click', () => {
                        if (mySpaceGroup) {
                            gsap.to(mySpaceGroup.rotation, {
                                duration: 0.6,
                                x: mySpaceGroup.rotation.x - Math.PI / 4,
                                ease: 'power2.inOut'
                            });
                        }
                        playSound('passive');
                    });
                }
                
                if (rotateLeftBtn) {
                    rotateLeftBtn.addEventListener('click', () => {
                        if (mySpaceGroup) {
                            gsap.to(mySpaceGroup.rotation, {
                                duration: 0.6,
                                y: mySpaceGroup.rotation.y - Math.PI / 4,
                                ease: 'power2.inOut'
                            });
                        }
                        playSound('passive');
                    });
                }
                
                if (rotateRightBtn) {
                    rotateRightBtn.addEventListener('click', () => {
                        if (mySpaceGroup) {
                            gsap.to(mySpaceGroup.rotation, {
                                duration: 0.6,
                                y: mySpaceGroup.rotation.y + Math.PI / 4,
                                ease: 'power2.inOut'
                            });
                        }
                        playSound('passive');
                    });
                }
                
                // Center Sphere Button
                const centerSphereBtn = document.getElementById('center-sphere-btn');
                
                if (centerSphereBtn) {
                    centerSphereBtn.addEventListener('click', () => {
                        if (mySpaceGroup) {
                            // Animate rotation back to zero (centered)
                            gsap.to(mySpaceGroup.rotation, {
                                duration: 0.8,
                                x: 0,
                                y: 0,
                                z: 0,
                                ease: 'power2.inOut'
                            });
                        }
                        playSound('active');
                    });
                }
                
                // Reset MySpace Button
                const resetMyspaceBtn = document.getElementById('reset-myspace-btn');
                
                if (resetMyspaceBtn) {
                    resetMyspaceBtn.addEventListener('click', () => {
                        if (mySpaceGroup) {
                            // Reset position and rotation
                            mySpaceGroup.position.set(0, 30, 0); // Position so sphere bottom is at y=0
                            mySpaceGroup.rotation.set(0, 0, 0);
                            
                            // Turn off MyZone lock if active
                            if (window.myzoneLocked) {
                                window.myzoneLocked = false;
                                const myzoneBtn = document.getElementById('myzone-toggle-btn');
                                if (myzoneBtn) {
                                    myzoneBtn.classList.remove('active');
                                    myzoneBtn.textContent = 'LOCK TO VIEW';
                                }
                            }
                        }
                        playSound('active');
                    });
                }
                
                // Sphere Auto-Rotation Checkboxes
                const sphereRotateXCheckbox = document.getElementById('sphere-rotate-x');
                const sphereRotateYCheckbox = document.getElementById('sphere-rotate-y');
                const sphereRotateZCheckbox = document.getElementById('sphere-rotate-z');
                
                if (sphereRotateXCheckbox) {
                    sphereRotateXCheckbox.addEventListener('change', (e) => {
                        sphereRotateX = e.target.checked;
                        playSound('passive');
                    });
                }
                
                if (sphereRotateYCheckbox) {
                    sphereRotateYCheckbox.addEventListener('change', (e) => {
                        sphereRotateY = e.target.checked;
                        playSound('passive');
                    });
                }
                
                if (sphereRotateZCheckbox) {
                    sphereRotateZCheckbox.addEventListener('change', (e) => {
                        sphereRotateZ = e.target.checked;
                        playSound('passive');
                    });
                }
                
                // Wallpaper Controls
                const wallpaperImageBtn = document.getElementById('wallpaper-image-btn');
                const wallpaperVideoBtn = document.getElementById('wallpaper-video-btn');
                const wallpaperDefaultBtn = document.getElementById('wallpaper-default-btn');
                const wallpaperUpload = document.getElementById('wallpaper-upload');
                const wallpaperUploadTrigger = document.getElementById('wallpaper-upload-trigger');
                const wallpaperPreview = document.getElementById('wallpaper-preview');
                
                let currentWallpaperMode = 'default';
                
                if (wallpaperImageBtn && wallpaperVideoBtn && wallpaperDefaultBtn) {
                    wallpaperImageBtn.addEventListener('click', () => {
                        currentWallpaperMode = 'image';
                        wallpaperImageBtn.classList.add('active');
                        wallpaperVideoBtn.classList.remove('active');
                        wallpaperDefaultBtn.classList.remove('active');
                        playSound('passive');
                    });
                    
                    wallpaperVideoBtn.addEventListener('click', () => {
                        currentWallpaperMode = 'video';
                        wallpaperVideoBtn.classList.add('active');
                        wallpaperImageBtn.classList.remove('active');
                        wallpaperDefaultBtn.classList.remove('active');
                        playSound('passive');
                    });
                    
                    wallpaperDefaultBtn.addEventListener('click', () => {
                        currentWallpaperMode = 'default';
                        wallpaperDefaultBtn.classList.add('active');
                        wallpaperImageBtn.classList.remove('active');
                        wallpaperVideoBtn.classList.remove('active');
                        
                        // Restore default gradient for panels
                        if (mySpaceGroup) {
                            mySpaceGroup.children.forEach(panel => {
                                if (panel.userData.type === 'myspace-sphere') {
                                    // Restore sphere's original gradient shader
                                    if (panel.material && panel.material.type !== 'ShaderMaterial') {
                                        const sphereMaterial = new THREE.ShaderMaterial({
                                            side: THREE.BackSide,
                                            uniforms: {
                                                color1: { value: new THREE.Color(0x333333) },
                                                color2: { value: new THREE.Color(0xffffff) }
                                            },
                                            vertexShader: `
                                                varying vec3 vPosition;
                                                void main() {
                                                    vPosition = position;
                                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                                }
                                            `,
                                            fragmentShader: `
                                                uniform vec3 color1;
                                                uniform vec3 color2;
                                                varying vec3 vPosition;
                                                void main() {
                                                    float mixValue = (vPosition.y + 30.0) / 60.0;
                                                    gl_FragColor = vec4(mix(color1, color2, mixValue), 1.0);
                                                }
                                            `
                                        });
                                        panel.material = sphereMaterial;
                                    }
                                } else if (panel.material && panel.material.map) {
                                    panel.material.map = null;
                                    panel.material.needsUpdate = true;
                                }
                            });
                        }
                        wallpaperPreview.textContent = 'Current: Default Gradient';
                        playSound('passive');
                    });
                }
                
                if (wallpaperUploadTrigger && wallpaperUpload) {
                    wallpaperUploadTrigger.addEventListener('click', () => {
                        wallpaperUpload.click();
                    });
                    
                    wallpaperUpload.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            if (currentWallpaperMode === 'image') {
                                const texture = new THREE.TextureLoader().load(event.target.result);
                                texture.wrapS = THREE.RepeatWrapping;
                                texture.wrapT = THREE.RepeatWrapping;
                                
                                if (mySpaceGroup) {
                                    mySpaceGroup.children.forEach(panel => {
                                        if (panel.userData.type === 'myspace-sphere') {
                                            // Replace sphere shader with textured material
                                            panel.material = new THREE.MeshBasicMaterial({
                                                map: texture,
                                                side: THREE.BackSide
                                            });
                                        } else if (panel.material) {
                                            panel.material.map = texture;
                                            panel.material.needsUpdate = true;
                                        }
                                    });
                                }
                                wallpaperPreview.textContent = `Current: ${file.name}`;
                            } else if (currentWallpaperMode === 'video') {
                                const video = document.createElement('video');
                                video.src = event.target.result;
                                video.loop = true;
                                video.muted = true;
                                video.play();
                                
                                const videoTexture = new THREE.VideoTexture(video);
                                videoTexture.wrapS = THREE.RepeatWrapping;
                                videoTexture.wrapT = THREE.RepeatWrapping;
                                
                                if (mySpaceGroup) {
                                    mySpaceGroup.children.forEach(panel => {
                                        if (panel.userData.type === 'myspace-sphere') {
                                            // Replace sphere shader with video texture material
                                            panel.material = new THREE.MeshBasicMaterial({
                                                map: videoTexture,
                                                side: THREE.BackSide
                                            });
                                        } else if (panel.material) {
                                            panel.material.map = videoTexture;
                                            panel.material.needsUpdate = true;
                                        }
                                    });
                                }
                                wallpaperPreview.textContent = `Current: ${file.name} (Video)`;
                            }
                            playSound('active');
                        };
                        reader.readAsDataURL(file);
                    });
                }
            }
            
            // Help Panel Setup
            const helpPanel = document.getElementById('help-panel');
            const helpHeader = document.getElementById('help-panel-header');
            const helpMinimizeBtn = document.getElementById('help-minimize-btn');
            const helpCloseBtn = document.getElementById('help-close-btn');
            
            if (helpPanel && helpHeader && helpMinimizeBtn && helpCloseBtn) {
                // Minimize/Expand
                helpMinimizeBtn.addEventListener('click', () => {
                    helpPanel.classList.toggle('minimized');
                    const content = document.getElementById('help-panel-content');
                    if (content) {
                        content.classList.toggle('hidden');
                    }
                    helpMinimizeBtn.textContent = helpPanel.classList.contains('minimized') ? '' : '_';
                    playSound('passive');
                });
                
                // Close
                helpCloseBtn.addEventListener('click', () => {
                    helpPanel.style.display = 'none';
                    playSound('passive');
                });
                
                // Drag
                let helpDragging = false;
                let helpDragStartX, helpDragStartY;
                
                helpHeader.addEventListener('mousedown', (e) => {
                    helpDragging = true;
                    helpDragStartX = e.clientX - helpPanel.offsetLeft;
                    helpDragStartY = e.clientY - helpPanel.offsetTop;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (helpDragging) {
                        helpPanel.style.left = (e.clientX - helpDragStartX) + 'px';
                        helpPanel.style.top = (e.clientY - helpDragStartY) + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    helpDragging = false;
                });
            }
            
            // Cube Face Panel Setup
            const cubeFacePanel = document.getElementById('cube-face-panel');
            const cubeFaceHeader = document.getElementById('cube-face-panel-header');
            const cubeFaceMinimizeBtn = document.getElementById('cube-face-minimize-btn');
            const cubeFaceCloseBtn = document.getElementById('cube-face-close-btn');
            
            if (cubeFacePanel && cubeFaceHeader && cubeFaceMinimizeBtn && cubeFaceCloseBtn) {
                // Minimize/Expand
                cubeFaceMinimizeBtn.addEventListener('click', () => {
                    cubeFacePanel.classList.toggle('minimized');
                    const content = document.getElementById('cube-face-panel-content');
                    if (content) {
                        content.classList.toggle('hidden');
                    }
                    cubeFaceMinimizeBtn.textContent = cubeFacePanel.classList.contains('minimized') ? '' : '_';
                    playSound('passive');
                });
                
                // Close
                cubeFaceCloseBtn.addEventListener('click', () => {
                    cubeFacePanel.style.display = 'none';
                    // Reset edge pulse speed
                    cubePulseSpeed = 1.0;
                    playSound('passive');
                });
                
                // Drag
                let cubeFaceDragging = false;
                let cubeFaceDragStartX, cubeFaceDragStartY;
                
                cubeFaceHeader.addEventListener('mousedown', (e) => {
                    cubeFaceDragging = true;
                    cubeFaceDragStartX = e.clientX - cubeFacePanel.offsetLeft;
                    cubeFaceDragStartY = e.clientY - cubeFacePanel.offsetTop;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (cubeFaceDragging) {
                        cubeFacePanel.style.left = (e.clientX - cubeFaceDragStartX) + 'px';
                        cubeFacePanel.style.top = (e.clientY - cubeFaceDragStartY) + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    cubeFaceDragging = false;
                });
            }
            
            // Dock and Panel Drag System
            function initDockDragSystem() {
                const docks = ['dock-bottom', 'dock-top', 'dock-left', 'dock-right'];
                let draggedPanel = null;
                let draggedCube = null;
                let dockDropZones = [];
                
                // Get all panels that can be minimized
                const draggablePanels = [
                    'inspector-panel',
                    'help-panel',
                    'cube-face-panel',
                    'omnisense-panel',
                    'orbit-panel',
                    'particle-panel',
                    'user-panel',
                    'default-space-panel'
                ];
                
                // Make minimized panels draggable
                draggablePanels.forEach(panelId => {
                    const panel = document.getElementById(panelId);
                    const minimizeBtn = document.getElementById(panelId.replace('-panel', '-minimize-btn'));
                    
                    if (panel && minimizeBtn) {
                        // When minimized, make panel draggable
                        minimizeBtn.addEventListener('click', () => {
                            setTimeout(() => {
                                if (panel.classList.contains('minimized')) {
                                    enablePanelDragging(panel);
                                } else {
                                    disablePanelDragging(panel);
                                }
                            }, 100);
                        });
                    }
                });
                
                function enablePanelDragging(panel) {
                    const header = panel.querySelector('.panel-header');
                    if (!header) return;
                    
                    // Visual feedback
                    panel.style.cursor = 'grab';
                    panel.style.border = '2px dashed rgba(0, 102, 255, 0.5)';
                    
                    // Make it absolute positioned for dragging
                    if (panel.style.position !== 'fixed') {
                        panel.style.position = 'fixed';
                    }
                    
                    header.draggable = true;
                    
                    header.addEventListener('dragstart', (e) => {
                        draggedPanel = panel;
                        panel.style.opacity = '0.5';
                        panel.style.cursor = 'grabbing';
                        
                        // Store panel info
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/html', panel.innerHTML);
                        
                        // Highlight drop zones (docks that are visible)
                        highlightDropZones();
                    });
                    
                    header.addEventListener('dragend', (e) => {
                        panel.style.opacity = '1';
                        panel.style.cursor = 'grab';
                        draggedPanel = null;
                        
                        // Remove highlights
                        removeDropZoneHighlights();
                    });
                }
                
                function disablePanelDragging(panel) {
                    const header = panel.querySelector('.panel-header');
                    if (!header) return;
                    
                    panel.style.cursor = 'default';
                    panel.style.border = '2px solid rgba(0, 102, 255, 0.5)';
                    header.draggable = false;
                }
                
                function highlightDropZones() {
                    docks.forEach(dockId => {
                        const dock = document.getElementById(dockId);
                        if (dock && !dock.classList.contains('hidden')) {
                            dock.style.background = 'rgba(0, 102, 255, 0.3)';
                            dock.style.border = '2px solid rgba(0, 255, 0, 0.8)';
                            dock.style.boxShadow = '0 0 20px rgba(0, 255, 0, 0.5)';
                        }
                    });
                }
                
                function removeDropZoneHighlights() {
                    docks.forEach(dockId => {
                        const dock = document.getElementById(dockId);
                        if (dock) {
                            dock.style.background = '';
                            dock.style.border = '';
                            dock.style.boxShadow = '';
                        }
                    });
                }
                
                // Set up drop zones on docks
                docks.forEach(dockId => {
                    const dock = document.getElementById(dockId);
                    if (!dock) return;
                    
                    dock.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        
                        // Extra highlight on hover
                        dock.style.background = 'rgba(0, 255, 0, 0.4)';
                    });
                    
                    dock.addEventListener('dragleave', (e) => {
                        // Restore normal highlight
                        dock.style.background = 'rgba(0, 102, 255, 0.3)';
                    });
                    
                    dock.addEventListener('drop', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        if (draggedPanel) {
                            // Create dock cube from panel
                            createDockCube(draggedPanel, dock);
                            
                            // Hide the original panel
                            draggedPanel.style.display = 'none';
                            
                            playSound('active');
                        }
                        
                        removeDropZoneHighlights();
                    });
                });
                
                function createDockCube(panel, dock) {
                    // Get panel name
                    const panelTitle = panel.querySelector('.panel-header span')?.textContent || 'PANEL';
                    const panelId = panel.id;
                    
                    // Create cube element
                    const cube = document.createElement('div');
                    cube.className = 'dock-item dock-cube';
                    cube.setAttribute('data-panel-id', panelId);
                    cube.draggable = true; // Make cube draggable
                    cube.style.cssText = `
                        width: 50px;
                        height: 50px;
                        background: rgba(25, 25, 30, 0.95);
                        border: 1px solid rgba(0, 102, 255, 0.5);
                        border-radius: 8px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        cursor: grab;
                        position: relative;
                        transition: all 0.3s;
                        margin: 4px;
                    `;
                    
                    // Add diagonal text
                    const text = document.createElement('div');
                    text.textContent = panelTitle.replace(' ', '').substring(0, 8);
                    text.style.cssText = `
                        transform: rotate(-45deg);
                        font-size: 8px;
                        font-weight: 700;
                        color: rgba(255, 255, 255, 0.9);
                        letter-spacing: 0.5px;
                        font-family: 'Orbitron', sans-serif;
                        text-align: center;
                        line-height: 1.2;
                        word-break: break-word;
                        max-width: 40px;
                        pointer-events: none;
                    `;
                    
                    cube.appendChild(text);
                    
                    // Hover effect
                    cube.addEventListener('mouseenter', () => {
                        cube.style.transform = 'scale(1.1) rotate(5deg)';
                        cube.style.background = 'rgba(0, 102, 255, 0.3)';
                        cube.style.borderColor = 'rgba(0, 255, 0, 0.8)';
                    });
                    
                    cube.addEventListener('mouseleave', () => {
                        cube.style.transform = 'scale(1) rotate(0deg)';
                        cube.style.background = 'rgba(25, 25, 30, 0.95)';
                        cube.style.borderColor = 'rgba(0, 102, 255, 0.5)';
                    });
                    
                    // Double-click to restore panel (click is now reserved for dragging)
                    cube.addEventListener('dblclick', () => {
                        const restoredPanel = document.getElementById(panelId);
                        if (restoredPanel) {
                            restoredPanel.style.display = 'block';
                            restoredPanel.classList.remove('minimized');
                            const content = restoredPanel.querySelector('.panel-content');
                            if (content) {
                                content.style.display = 'block';
                            }
                            const minimizeBtn = restoredPanel.querySelector('.panel-btn');
                            if (minimizeBtn) {
                                minimizeBtn.textContent = '_';
                            }
                        }
                        
                        // Remove cube from dock
                        cube.remove();
                        
                        // Save state
                        saveDockState();
                        
                        playSound('active');
                    });
                    
                    // Add to dock
                    dock.appendChild(cube);
                    
                    // Save to localStorage
                    saveDockState();
                }
                
                function saveDockState() {
                    const dockState = {};
                    
                    docks.forEach(dockId => {
                        const dock = document.getElementById(dockId);
                        if (dock) {
                            const cubes = dock.querySelectorAll('.dock-cube');
                            dockState[dockId] = Array.from(cubes).map(cube => ({
                                panelId: cube.getAttribute('data-panel-id'),
                                text: cube.querySelector('div').textContent
                            }));
                        }
                    });
                    
                    localStorage.setItem('dockState', JSON.stringify(dockState));
                }
                
                function loadDockState() {
                    const savedState = localStorage.getItem('dockState');
                    if (!savedState) return;
                    
                    try {
                        const dockState = JSON.parse(savedState);
                        
                        Object.keys(dockState).forEach(dockId => {
                            const dock = document.getElementById(dockId);
                            const panelConfigs = dockState[dockId];
                            
                            panelConfigs.forEach(config => {
                                const panel = document.getElementById(config.panelId);
                                if (panel && dock) {
                                    createDockCube(panel, dock);
                                    panel.style.display = 'none';
                                }
                            });
                        });
                    } catch (e) {
                        console.error('Error loading dock state:', e);
                    }
                }
                
                // Load saved dock state on init
                loadDockState();
                
                // Auto-populate all panels into docks randomly (left and bottom only)
                function autoPopulatePanelsInDocks() {
                    // DISABLED: Manual cubes are now in HTML, auto-dock buttons handle docking
                    // No auto-population needed
                    return;
                }
                
                // Make dock cubes draggable OUT of docks
                function enableDockCubeDragging() {
                    // Use event delegation for dynamically created cubes
                    docks.forEach(dockId => {
                        const dock = document.getElementById(dockId);
                        if (!dock) return;
                        
                        dock.addEventListener('dragstart', (e) => {
                            if (e.target.classList.contains('dock-cube')) {
                                draggedCube = e.target;
                                e.target.style.opacity = '0.5';
                                e.dataTransfer.effectAllowed = 'move';
                                
                                // Allow dropping on document body (anywhere outside docks)
                                document.body.style.outline = '3px dashed rgba(0, 255, 0, 0.5)';
                            }
                        });
                        
                        dock.addEventListener('dragend', (e) => {
                            if (e.target.classList.contains('dock-cube')) {
                                e.target.style.opacity = '1';
                                document.body.style.outline = '';
                            }
                        });
                    });
                    
                    // Allow dropping cubes anywhere on the page
                    document.body.addEventListener('dragover', (e) => {
                        // Only allow if dragging a cube
                        if (draggedCube) {
                            e.preventDefault();
                            e.dataTransfer.dropEffect = 'move';
                        }
                    });
                    
                    document.body.addEventListener('drop', (e) => {
                        if (draggedCube) {
                            e.preventDefault();
                            
                            // Get panel ID from cube
                            const panelId = draggedCube.getAttribute('data-panel-id');
                            const panel = document.getElementById(panelId);
                            
                            if (panel) {
                                // Restore panel at drop position
                                panel.style.display = 'block';
                                panel.classList.remove('minimized');
                                panel.style.left = (e.clientX - 200) + 'px'; // Center on cursor
                                panel.style.top = (e.clientY - 30) + 'px';
                                
                                // Expand panel content
                                const content = panel.querySelector('.panel-content');
                                if (content) {
                                    content.style.display = 'block';
                                }
                                
                                // Update minimize button
                                const minimizeBtn = panel.querySelector('.panel-btn');
                                if (minimizeBtn && minimizeBtn.textContent === '') {
                                    minimizeBtn.textContent = '_';
                                }
                            }
                            
                            // Remove cube from dock
                            draggedCube.remove();
                            draggedCube = null;
                            
                            // Save updated dock state
                            saveDockState();
                            
                            playSound('active');
                            document.body.style.outline = '';
                        }
                    });
                }
                
                // Initialize auto-population
                setTimeout(() => {
                    autoPopulatePanelsInDocks();
                    enableDockCubeDragging();
                }, 100);
            }
            
            // Initialize dock drag system
            initDockDragSystem();
            
            // Auto-Dock Button Handlers
            function setupAutoDockButton(panelId, dockBtnId, targetDockId) {
                const dockBtn = document.getElementById(dockBtnId);
                const panel = document.getElementById(panelId);
                
                if (dockBtn && panel) {
                    dockBtn.addEventListener('click', () => {
                        // Get target dock (default to bottom if not specified)
                        const dockId = targetDockId || 'dock-bottom';
                        const dock = document.getElementById(dockId);
                        
                        if (dock) {
                            // Check if dock is visible, if not open it
                            if (dock.classList.contains('hidden')) {
                                dock.classList.remove('hidden');
                            }
                            
                            // Create dock cube for this panel
                            const panelTitle = panel.querySelector('.panel-title')?.textContent || 'PANEL';
                            
                            const cube = document.createElement('div');
                            cube.className = 'dock-item dock-cube';
                            cube.setAttribute('data-panel-id', panelId);
                            cube.draggable = true;
                            cube.style.cssText = `
                                width: 50px;
                                height: 50px;
                                background: rgba(25, 25, 30, 0.95);
                                border: 1px solid rgba(0, 102, 255, 0.5);
                                border-radius: 8px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                cursor: grab;
                                position: relative;
                                transition: all 0.3s;
                                margin: 4px;
                            `;
                            
                            const text = document.createElement('div');
                            text.textContent = panelTitle.replace(' ', '').replace('?-', '').replace('', '').substring(0, 8);
                            text.style.cssText = `
                                transform: rotate(-45deg);
                                font-size: 8px;
                                font-weight: 700;
                                color: rgba(255, 255, 255, 0.9);
                                letter-spacing: 0.5px;
                                font-family: 'Orbitron', sans-serif;
                                text-align: center;
                                line-height: 1.2;
                                word-break: break-word;
                                max-width: 40px;
                                pointer-events: none;
                            `;
                            
                            cube.appendChild(text);
                            
                            // Hover effects
                            cube.addEventListener('mouseenter', () => {
                                cube.style.transform = 'scale(1.1) rotate(5deg)';
                                cube.style.background = 'rgba(0, 102, 255, 0.3)';
                                cube.style.borderColor = 'rgba(0, 255, 0, 0.8)';
                            });
                            
                            cube.addEventListener('mouseleave', () => {
                                cube.style.transform = 'scale(1) rotate(0deg)';
                                cube.style.background = 'rgba(25, 25, 30, 0.95)';
                                cube.style.borderColor = 'rgba(0, 102, 255, 0.5)';
                            });
                            
                            // Double-click to restore
                            cube.addEventListener('dblclick', () => {
                                panel.style.display = 'block';
                                panel.classList.remove('minimized');
                                const content = panel.querySelector('.panel-content');
                                if (content) {
                                    content.style.display = 'block';
                                }
                                cube.remove();
                                playSound('active');
                            });
                            
                            // Add to dock
                            dock.appendChild(cube);
                            
                            // Hide panel
                            panel.style.display = 'none';
                            panel.classList.add('minimized');
                            
                            playSound('active');
                        }
                    });
                }
            }
            
            // Setup all auto-dock buttons
            setupAutoDockButton('inspector-panel', 'inspector-dock-btn', 'dock-left');
            setupAutoDockButton('help-panel', 'help-dock-btn', 'dock-right');
            setupAutoDockButton('particle-behavior-panel', 'particle-dock-btn', 'dock-bottom');
            setupAutoDockButton('orbit-controls-panel', 'orbit-dock-btn', 'dock-left');
            setupAutoDockButton('user-controls-panel', 'user-dock-btn', 'dock-left');
            setupAutoDockButton('default-space-panel', 'default-space-dock-btn', 'dock-left');
            setupAutoDockButton('cube-face-panel', 'cube-face-dock-btn', 'dock-bottom');
            setupAutoDockButton('omnisense-panel', 'omnisense-dock-btn', 'dock-bottom');
            
            // OmniSense Panel Setup
            const omniSensePanel = document.getElementById('omnisense-panel');
            const omniSenseHeader = document.getElementById('omnisense-panel-header');
            const omniSenseMinimizeBtn = document.getElementById('omnisense-minimize-btn');
            const omniSenseCloseBtn = document.getElementById('omnisense-close-btn');
            
            if (omniSensePanel && omniSenseHeader && omniSenseMinimizeBtn && omniSenseCloseBtn) {
                // Minimize/Expand
                omniSenseMinimizeBtn.addEventListener('click', () => {
                    omniSensePanel.classList.toggle('minimized');
                    const content = document.getElementById('omnisense-panel-content');
                    if (content) {
                        if (omniSensePanel.classList.contains('minimized')) {
                            content.style.display = 'none';
                            omniSensePanel.style.height = '60px';
                            omniSenseMinimizeBtn.textContent = '';
                        } else {
                            content.style.display = 'block';
                            omniSensePanel.style.height = 'auto';
                            omniSenseMinimizeBtn.textContent = '_';
                        }
                    }
                    playSound('passive');
                });
                
                // Close
                omniSenseCloseBtn.addEventListener('click', () => {
                    omniSensePanel.style.display = 'none';
                    playSound('passive');
                });
                
                // Drag
                let omniSenseDragging = false;
                let omniSenseDragStartX, omniSenseDragStartY;
                
                omniSenseHeader.addEventListener('mousedown', (e) => {
                    // Only drag if not minimized or if dragging from non-button area
                    if (!e.target.classList.contains('panel-btn')) {
                        omniSenseDragging = true;
                        omniSenseDragStartX = e.clientX - omniSensePanel.offsetLeft;
                        omniSenseDragStartY = e.clientY - omniSensePanel.offsetTop;
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (omniSenseDragging) {
                        omniSensePanel.style.left = (e.clientX - omniSenseDragStartX) + 'px';
                        omniSensePanel.style.top = (e.clientY - omniSenseDragStartY) + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    omniSenseDragging = false;
                });
                
                // Camera Height Slider
                const heightSlider = document.getElementById('omnisense-height-slider');
                const heightValue = document.getElementById('omnisense-height-value');
                
                if (heightSlider && heightValue) {
                    heightSlider.addEventListener('input', (e) => {
                        const newHeight = parseInt(e.target.value);
                        heightValue.textContent = newHeight;
                        omniSenseCameraHeight = newHeight;
                        
                        // If in OmniSense mode, move camera
                        if (omniSenseMode) {
                            gsap.to(camera.position, {
                                duration: 0.5,
                                y: newHeight,
                                ease: 'power2.out'
                            });
                        }
                    });
                }
                
                // Grid Opacity Slider
                const gridOpacitySlider = document.getElementById('omnisense-grid-opacity-slider');
                const gridOpacityValue = document.getElementById('omnisense-grid-opacity-value');
                
                if (gridOpacitySlider && gridOpacityValue) {
                    gridOpacitySlider.addEventListener('input', (e) => {
                        const opacity = parseInt(e.target.value) / 100;
                        gridOpacityValue.textContent = e.target.value + '%';
                        
                        if (gridHelper) {
                            gridHelper.material.opacity = opacity;
                        }
                    });
                }
                
                // Rotation Speed Slider
                const rotationSpeedSlider = document.getElementById('omnisense-rotation-speed-slider');
                const rotationSpeedValue = document.getElementById('omnisense-rotation-speed-value');
                
                if (rotationSpeedSlider && rotationSpeedValue) {
                    rotationSpeedSlider.addEventListener('input', (e) => {
                        const speed = parseFloat(e.target.value);
                        rotationSpeedValue.textContent = speed.toFixed(1);
                        cubeRotationSpeed = speed * 0.001;
                    });
                }
                
                // Save State Button
                const saveStateBtn = document.getElementById('omnisense-save-state');
                if (saveStateBtn) {
                    saveStateBtn.addEventListener('click', () => {
                        const state = {
                            cameraHeight: omniSenseCameraHeight,
                            gridOpacity: gridHelper?.material.opacity || 0.6,
                            cubeRotationSpeed: cubeRotationSpeed,
                            cubeRotating: cubeRotating,
                            timestamp: Date.now()
                        };
                        
                        localStorage.setItem('omniSenseState', JSON.stringify(state));
                        playSound('active');
                        console.log('OmniSense state saved');
                    });
                }
                
                // Load State Button
                const loadStateBtn = document.getElementById('omnisense-load-state');
                if (loadStateBtn) {
                    loadStateBtn.addEventListener('click', () => {
                        const savedState = localStorage.getItem('omniSenseState');
                        if (savedState) {
                            try {
                                const state = JSON.parse(savedState);
                                
                                omniSenseCameraHeight = state.cameraHeight || 200;
                                cubeRotationSpeed = state.cubeRotationSpeed || 0.001;
                                cubeRotating = state.cubeRotating !== undefined ? state.cubeRotating : true;
                                
                                // Update UI
                                if (heightSlider) heightSlider.value = omniSenseCameraHeight;
                                if (heightValue) heightValue.textContent = omniSenseCameraHeight;
                                if (gridOpacitySlider) gridOpacitySlider.value = (state.gridOpacity || 0.6) * 100;
                                if (gridOpacityValue) gridOpacityValue.textContent = Math.round((state.gridOpacity || 0.6) * 100) + '%';
                                if (rotationSpeedSlider) rotationSpeedSlider.value = (cubeRotationSpeed * 1000).toFixed(1);
                                if (rotationSpeedValue) rotationSpeedValue.textContent = (cubeRotationSpeed * 1000).toFixed(1);
                                
                                // Apply to scene if in OmniSense mode
                                if (omniSenseMode) {
                                    gsap.to(camera.position, { duration: 1, y: omniSenseCameraHeight });
                                    if (gridHelper) gridHelper.material.opacity = state.gridOpacity || 0.6;
                                }
                                
                                playSound('active');
                                console.log('OmniSense state loaded');
                            } catch (e) {
                                console.error('Error loading OmniSense state:', e);
                            }
                        }
                    });
                }
                
                // Reset Button
                const resetBtn = document.getElementById('omnisense-reset');
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        omniSenseCameraHeight = 200;
                        cubeRotationSpeed = 0.001;
                        cubeRotating = true;
                        
                        // Update UI
                        if (heightSlider) heightSlider.value = 200;
                        if (heightValue) heightValue.textContent = '200';
                        if (gridOpacitySlider) gridOpacitySlider.value = 60;
                        if (gridOpacityValue) gridOpacityValue.textContent = '60%';
                        if (rotationSpeedSlider) rotationSpeedSlider.value = 1;
                        if (rotationSpeedValue) rotationSpeedValue.textContent = '1.0';
                        
                        // Apply to scene
                        if (omniSenseMode) {
                            gsap.to(camera.position, { duration: 1, y: 200 });
                        }
                        if (gridHelper) gridHelper.material.opacity = 0.6;
                        
                        playSound('active');
                        console.log('OmniSense reset to defaults');
                    });
                }
            }
            
            // Chat Panel
            const chatPanel = document.getElementById('chat-panel');
            const chatClose = document.getElementById('chat-close');
            
            if (chatClose && chatPanel) {
                chatClose.addEventListener('click', () => {
                    chatPanel.style.display = 'none';
                    const btnChat = document.getElementById('btn-chat');
                    if (btnChat) {
                        btnChat.classList.remove('active');
                    }
                    playSound('passive');
                });
            }
            
            // Chat Panel Drag
            const chatPanelHeader = document.getElementById('chat-panel-header');
            if (chatPanelHeader && chatPanel) {
                let chatDragging = false;
                let chatDragStartX, chatDragStartY;
                
                chatPanelHeader.addEventListener('mousedown', (e) => {
                    chatDragging = true;
                    chatDragStartX = e.clientX - chatPanel.offsetLeft;
                    chatDragStartY = e.clientY - chatPanel.offsetTop;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (chatDragging) {
                        chatPanel.style.left = (e.clientX - chatDragStartX) + 'px';
                        chatPanel.style.top = (e.clientY - chatDragStartY) + 'px';
                        chatPanel.style.bottom = 'auto';
                        chatPanel.style.right = 'auto';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    chatDragging = false;
                });
            }
            
            // View Panel
            const openViewPanelBtn = document.getElementById('open-view-panel-btn');
            const viewPanel = document.getElementById('view-panel');
            const viewPanelClose = document.getElementById('view-panel-close');
            
            if (openViewPanelBtn && viewPanel) {
                openViewPanelBtn.addEventListener('click', () => {
                    if (selectedObject) {
                        // Load data into view panel
                        const objectId = selectedObject.uuid;
                        const savedData = localStorage.getItem(`object_data_${objectId}`);
                        
                        if (savedData) {
                            const data = JSON.parse(savedData);
                            document.getElementById('view-header').textContent = data.header || '';
                            document.getElementById('view-body').textContent = data.body || '';
                            document.getElementById('view-footer').textContent = data.footer || '';
                        } else {
                            document.getElementById('view-header').textContent = '';
                            document.getElementById('view-body').textContent = '';
                            document.getElementById('view-footer').textContent = '';
                        }
                        
                        viewPanel.style.display = 'block';
                        playSound('active');
                    } else {
                        alert('No object selected. Please select an object first.');
                    }
                });
            }
            
            if (viewPanelClose) {
                viewPanelClose.addEventListener('click', () => {
                    viewPanel.style.display = 'none';
                    playSound('passive');
                });
            }
            
            // View Panel Drag
            const viewPanelHeader = document.getElementById('view-panel-header');
            let isViewDragging = false;
            let viewDragStartX, viewDragStartY;
            
            if (viewPanelHeader && viewPanel) {
                viewPanelHeader.addEventListener('mousedown', (e) => {
                    // Don't drag if clicking close button
                    if (e.target.closest('#view-panel-close')) return;
                    
                    isViewDragging = true;
                    viewDragStartX = e.clientX - viewPanel.offsetLeft;
                    viewDragStartY = e.clientY - viewPanel.offsetTop;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isViewDragging) {
                        viewPanel.style.left = (e.clientX - viewDragStartX) + 'px';
                        viewPanel.style.top = (e.clientY - viewDragStartY) + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isViewDragging = false;
                    isViewResizing = false;
                });
            }
            
            // View Panel Resize
            const viewResizeHandle = document.getElementById('view-panel-resize-handle');
            let isViewResizing = false;
            let viewResizeStartX, viewResizeStartY, viewResizeStartWidth, viewResizeStartHeight;
            
            if (viewResizeHandle && viewPanel) {
                viewResizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    isViewResizing = true;
                    viewResizeStartX = e.clientX;
                    viewResizeStartY = e.clientY;
                    viewResizeStartWidth = viewPanel.offsetWidth;
                    viewResizeStartHeight = viewPanel.offsetHeight;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (isViewResizing) {
                        const newWidth = viewResizeStartWidth + (e.clientX - viewResizeStartX);
                        const newHeight = viewResizeStartHeight + (e.clientY - viewResizeStartY);
                        viewPanel.style.width = Math.max(300, newWidth) + 'px';
                        viewPanel.style.maxHeight = Math.max(200, newHeight) + 'px';
                    }
                });
            }
            
            // Copy to clipboard functionality
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const field = btn.getAttribute('data-copy');
                    let textToCopy = '';
                    
                    if (field === 'header') {
                        textToCopy = document.getElementById('view-header').textContent;
                    } else if (field === 'body') {
                        textToCopy = document.getElementById('view-body').textContent;
                    } else if (field === 'footer') {
                        textToCopy = document.getElementById('view-footer').textContent;
                    }
                    
                    if (textToCopy && textToCopy !== '') {
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            const originalText = btn.textContent;
                            btn.textContent = ' COPIED';
                            btn.style.background = 'rgba(74, 226, 144, 0.3)';
                            btn.style.borderColor = 'rgba(74, 226, 144, 0.5)';
                            
                            setTimeout(() => {
                                btn.textContent = originalText;
                                btn.style.background = 'rgba(128, 128, 128, 0.3)';
                                btn.style.borderColor = 'rgba(128, 128, 128, 0.5)';
                            }, 2000);
                            
                            playSound('active');
                        });
                    }
                });
            });

            // FAQ panel close
            const faqClose = document.getElementById('faq-close');
            if (faqClose) {
                faqClose.addEventListener('click', () => {
                    document.getElementById('faq-panel').classList.remove('visible');
                });
            }
        }

        function setupMobileControls() {
            const joystickStick = document.getElementById('joystick-stick');
            const joystickBase = joystickStick.parentElement;
            
            // Performance optimization for mobile
            let lastJoystickUpdate = 0;
            const joystickThrottle = 16; // ~60fps max

            // Joystick touch/mouse controls
            joystickStick.addEventListener('mousedown', startJoystick);
            joystickStick.addEventListener('touchstart', startJoystick, { passive: false });

            function startJoystick(e) {
                e.preventDefault();
                joystickActive = true;
                const rect = joystickBase.getBoundingClientRect();
                joystickStartPos = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                document.addEventListener('mousemove', moveJoystick);
                document.addEventListener('touchmove', moveJoystick, { passive: false });
                document.addEventListener('mouseup', stopJoystick);
                document.addEventListener('touchend', stopJoystick);
            }

            function moveJoystick(e) {
                if (!joystickActive) return;
                
                // Throttle updates for performance on mobile
                const now = performance.now();
                if (now - lastJoystickUpdate < joystickThrottle) {
                    return;
                }
                lastJoystickUpdate = now;
                
                e.preventDefault(); // Prevent scrolling on mobile
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - joystickStartPos.x;
                const deltaY = clientY - joystickStartPos.y;

                const distance = Math.min(45, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);

                const maxOffset = 45;
                const offsetX = Math.cos(angle) * distance;
                const offsetY = Math.sin(angle) * distance;

                joystickStick.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

                // Move camera based on joystick
                const moveX = (offsetX / maxOffset) * moveSpeed;
                const moveZ = (offsetY / maxOffset) * moveSpeed;

                camera.position.x += moveX;
                camera.position.z += moveZ;
                cameraTarget.x += moveX;
                cameraTarget.z += moveZ;
            }

            function stopJoystick() {
                joystickActive = false;
                joystickStick.style.transform = 'translate(-50%, -50%)';
                document.removeEventListener('mousemove', moveJoystick);
                document.removeEventListener('touchmove', moveJoystick);
                document.removeEventListener('mouseup', stopJoystick);
                document.removeEventListener('touchend', stopJoystick);
            }

            // Mobile touch for FPS camera look (single finger on canvas)
            const canvas = renderer.domElement;
            let touchStartX = 0;
            let touchStartY = 0;
            let isTouchLooking = false;
            let lastTouchUpdate = 0;
            const touchThrottle = 16; // ~60fps max

            canvas.addEventListener('touchstart', (e) => {
                // Only handle single finger touch for camera look
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    isTouchLooking = true;
                }
            }, { passive: true });

            canvas.addEventListener('touchmove', (e) => {
                if (isTouchLooking && e.touches.length === 1) {
                    // Throttle for performance
                    const now = performance.now();
                    if (now - lastTouchUpdate < touchThrottle) {
                        return;
                    }
                    lastTouchUpdate = now;
                    
                    e.preventDefault();
                    const touch = e.touches[0];
                    
                    const deltaX = touch.clientX - touchStartX;
                    const deltaY = touch.clientY - touchStartY;
                    
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;

                    // Apply FPS-style rotation (same as C key mouse look)
                    if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
                        // Horizontal rotation (yaw)
                        camera.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), -deltaX * lookSensitivity * 2);
                        
                        // Vertical rotation (pitch)
                        const pitchAxis = new THREE.Vector3(1, 0, 0);
                        const pitchQuaternion = new THREE.Quaternion().setFromAxisAngle(pitchAxis, -deltaY * lookSensitivity * 2);
                        camera.quaternion.multiply(pitchQuaternion);
                        
                        // Clamp pitch
                        const forward = new THREE.Vector3(0, 0, -1);
                        forward.applyQuaternion(camera.quaternion);
                        
                        if (forward.y < -0.99) {
                            const correctionAxis = new THREE.Vector3(1, 0, 0);
                            const correctionQuaternion = new THREE.Quaternion().setFromAxisAngle(correctionAxis, -0.01);
                            camera.quaternion.multiply(correctionQuaternion);
                        } else if (forward.y > 0.99) {
                            const correctionAxis = new THREE.Vector3(1, 0, 0);
                            const correctionQuaternion = new THREE.Quaternion().setFromAxisAngle(correctionAxis, 0.01);
                            camera.quaternion.multiply(correctionQuaternion);
                        }
                    }
                }
            });

            canvas.addEventListener('touchend', () => {
                isTouchLooking = false;
            });

            // Setup RH Joystick
            const rhJoystickStick = document.getElementById('rh-joystick-stick');
            const rhJoystickBase = rhJoystickStick.parentElement;
            let rhJoystickActive = false;
            let rhJoystickStartPos = { x: 0, y: 0 };

            rhJoystickStick.addEventListener('mousedown', startRHJoystick);
            rhJoystickStick.addEventListener('touchstart', startRHJoystick, { passive: false });

            function startRHJoystick(e) {
                e.preventDefault();
                rhJoystickActive = true;
                const rect = rhJoystickBase.getBoundingClientRect();
                rhJoystickStartPos = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                document.addEventListener('mousemove', moveRHJoystick);
                document.addEventListener('touchmove', moveRHJoystick, { passive: false });
                document.addEventListener('mouseup', stopRHJoystick);
                document.addEventListener('touchend', stopRHJoystick);
            }

            function moveRHJoystick(e) {
                if (!rhJoystickActive) return;
                
                const now = performance.now();
                if (now - lastJoystickUpdate < joystickThrottle) {
                    return;
                }
                lastJoystickUpdate = now;
                
                e.preventDefault();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - rhJoystickStartPos.x;
                const deltaY = clientY - rhJoystickStartPos.y;

                const distance = Math.min(45, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);

                const maxOffset = 45;
                const offsetX = Math.cos(angle) * distance;
                const offsetY = Math.sin(angle) * distance;

                rhJoystickStick.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

                // Move camera based on joystick
                const moveX = (offsetX / maxOffset) * moveSpeed;
                const moveZ = (offsetY / maxOffset) * moveSpeed;

                camera.position.x += moveX;
                camera.position.z += moveZ;
                cameraTarget.x += moveX;
                cameraTarget.z += moveZ;
            }

            function stopRHJoystick() {
                rhJoystickActive = false;
                rhJoystickStick.style.transform = 'translate(-50%, -50%)';
                document.removeEventListener('mousemove', moveRHJoystick);
                document.removeEventListener('touchmove', moveRHJoystick);
                document.removeEventListener('mouseup', stopRHJoystick);
                document.removeEventListener('touchend', stopRHJoystick);
            }

            // Setup CH Joystick
            const chJoystickStick = document.getElementById('ch-joystick-stick');
            const chJoystickBase = chJoystickStick.parentElement;
            let chJoystickActive = false;
            let chJoystickStartPos = { x: 0, y: 0 };

            chJoystickStick.addEventListener('mousedown', startCHJoystick);
            chJoystickStick.addEventListener('touchstart', startCHJoystick, { passive: false });

            function startCHJoystick(e) {
                e.preventDefault();
                chJoystickActive = true;
                const rect = chJoystickBase.getBoundingClientRect();
                chJoystickStartPos = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                document.addEventListener('mousemove', moveCHJoystick);
                document.addEventListener('touchmove', moveCHJoystick, { passive: false });
                document.addEventListener('mouseup', stopCHJoystick);
                document.addEventListener('touchend', stopCHJoystick);
            }

            function moveCHJoystick(e) {
                if (!chJoystickActive) return;
                
                const now = performance.now();
                if (now - lastJoystickUpdate < joystickThrottle) {
                    return;
                }
                lastJoystickUpdate = now;
                
                e.preventDefault();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const deltaX = clientX - chJoystickStartPos.x;
                const deltaY = clientY - chJoystickStartPos.y;

                const distance = Math.min(45, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);

                const maxOffset = 45;
                const offsetX = Math.cos(angle) * distance;
                const offsetY = Math.sin(angle) * distance;

                chJoystickStick.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;

                // Move camera based on joystick
                const moveX = (offsetX / maxOffset) * moveSpeed;
                const moveZ = (offsetY / maxOffset) * moveSpeed;

                camera.position.x += moveX;
                camera.position.z += moveZ;
                cameraTarget.x += moveX;
                cameraTarget.z += moveZ;
            }

            function stopCHJoystick() {
                chJoystickActive = false;
                chJoystickStick.style.transform = 'translate(-50%, -50%)';
                document.removeEventListener('mousemove', moveCHJoystick);
                document.removeEventListener('touchmove', moveCHJoystick);
                document.removeEventListener('mouseup', stopCHJoystick);
                document.removeEventListener('touchend', stopCHJoystick);
            }
        }

        function setupTransformPanel() {
            const transformPanel = document.getElementById('transform-panel');
            const transformClose = document.getElementById('transform-close');
            const transformTitle = document.getElementById('transform-title');
            
            const btnPos = document.getElementById('btn-pos');
            const btnRot = document.getElementById('btn-rot');
            const btnScale = document.getElementById('btn-scale');

            const transformX = document.getElementById('transform-x');
            const transformY = document.getElementById('transform-y');
            const transformZ = document.getElementById('transform-z');
            const stepSize = document.getElementById('step-size');

            transformClose.addEventListener('click', () => {
                transformPanel.style.display = 'none';
                currentTransformMode = null;
                btnPos.classList.remove('active');
                btnRot.classList.remove('active');
                btnScale.classList.remove('active');
            });

            btnPos.addEventListener('click', () => {
                showTransformPanel('POSITION', 'position', btnPos);
            });

            btnRot.addEventListener('click', () => {
                showTransformPanel('ROTATION', 'rotation', btnRot);
            });

            btnScale.addEventListener('click', () => {
                showTransformPanel('SCALE', 'scale', btnScale);
            });

            function showTransformPanel(title, mode, button) {
                transformTitle.textContent = title;
                currentTransformMode = mode;
                transformPanel.style.display = 'block';

                // Update active states
                btnPos.classList.remove('active');
                btnRot.classList.remove('active');
                btnScale.classList.remove('active');
                button.classList.add('active');

                // Update values based on selected object OR camera
                if (selectedObject) {
                    // Object is selected - show object transforms
                    if (mode === 'position') {
                        transformX.value = selectedObject.position.x.toFixed(2);
                        transformY.value = selectedObject.position.y.toFixed(2);
                        transformZ.value = selectedObject.position.z.toFixed(2);
                    } else if (mode === 'rotation') {
                        transformX.value = (selectedObject.rotation.x * 180 / Math.PI).toFixed(2);
                        transformY.value = (selectedObject.rotation.y * 180 / Math.PI).toFixed(2);
                        transformZ.value = (selectedObject.rotation.z * 180 / Math.PI).toFixed(2);
                    } else if (mode === 'scale') {
                        transformX.value = selectedObject.scale.x.toFixed(2);
                        transformY.value = selectedObject.scale.y.toFixed(2);
                        transformZ.value = selectedObject.scale.z.toFixed(2);
                    }
                } else {
                    // Nothing selected - show camera transforms
                    if (mode === 'position') {
                        transformX.value = camera.position.x.toFixed(2);
                        transformY.value = camera.position.y.toFixed(2);
                        transformZ.value = camera.position.z.toFixed(2);
                    } else if (mode === 'rotation') {
                        transformX.value = (camera.rotation.x * 180 / Math.PI).toFixed(2);
                        transformY.value = (camera.rotation.y * 180 / Math.PI).toFixed(2);
                        transformZ.value = (camera.rotation.z * 180 / Math.PI).toFixed(2);
                    } else if (mode === 'scale') {
                        // Camera doesn't have scale, show 1.0
                        transformX.value = '1.00';
                        transformY.value = '1.00';
                        transformZ.value = '1.00';
                    }
                }
            }

            // Apply transform changes
            function applyTransform() {
                if (!currentTransformMode) return;

                const x = parseFloat(transformX.value) || 0;
                const y = parseFloat(transformY.value) || 0;
                const z = parseFloat(transformZ.value) || 0;

                if (selectedObject) {
                    // Apply to selected object
                    if (currentTransformMode === 'position') {
                        selectedObject.position.set(x, y, z);
                    } else if (currentTransformMode === 'rotation') {
                        selectedObject.rotation.set(
                            x * Math.PI / 180,
                            y * Math.PI / 180,
                            z * Math.PI / 180
                        );
                    } else if (currentTransformMode === 'scale') {
                        selectedObject.scale.set(x, y, z);
                    }
                    updateInspectorPanel();
                } else {
                    // Apply to camera (user)
                    if (currentTransformMode === 'position') {
                        camera.position.set(x, y, z);
                    } else if (currentTransformMode === 'rotation') {
                        camera.rotation.set(
                            x * Math.PI / 180,
                            y * Math.PI / 180,
                            z * Math.PI / 180
                        );
                    }
                    // Scale doesn't apply to camera
                }

                playSound('active');
            }

            // Submit button applies changes
            const transformSubmit = document.getElementById('transform-submit');
            transformSubmit.addEventListener('click', () => {
                applyTransform();
            });

            // Arrow keys for fine control (but don't apply immediately)
            [transformX, transformY, transformZ].forEach(input => {
                input.addEventListener('keydown', (e) => {
                    const step = parseFloat(stepSize.value) || 1;
                    const currentValue = parseFloat(input.value) || 0;

                    if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        input.value = (currentValue + step).toFixed(2);
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        input.value = (currentValue - step).toFixed(2);
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        applyTransform();
                    }
                });
            });
        }

        function setupActionGrid() {
            const actionButtons = document.querySelectorAll('.action-btn');
            
            actionButtons.forEach((btn, index) => {
                btn.addEventListener('click', () => {
                    // Toggle active state
                    btn.classList.toggle('active');
                    
                    // Custom action for each button
                    console.log(`Action button ${index + 1} clicked`);
                    playSound('passive');
                    
                    // You can add specific functionality for each button here
                    // For example, save states, trigger animations, etc.
                });
            });
        }

        function setupHamburgerMenus() {
            const leftHamburger = document.getElementById('left-hamburger');
            const rightHamburger = document.getElementById('right-hamburger');
            const leftMenu = document.getElementById('left-menu');
            const rightMenu = document.getElementById('right-menu');
            const leftBreadcrumb = document.getElementById('left-breadcrumb');
            const rightBreadcrumb = document.getElementById('right-breadcrumb');

            // Toggle left menu
            leftHamburger.addEventListener('click', () => {
                leftMenu.classList.toggle('open');
                leftHamburger.classList.toggle('menu-open');
                playSound('passive');
            });

            // Toggle right menu
            rightHamburger.addEventListener('click', () => {
                rightMenu.classList.toggle('open');
                rightHamburger.classList.toggle('menu-open');
                playSound('passive');
            });

            // Handle menu item clicks for both menus
            const allMenuItems = document.querySelectorAll('.menu-item');
            allMenuItems.forEach(item => {
                const header = item.querySelector('.menu-item-header');
                
                header.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Toggle submenu expansion
                    item.classList.toggle('expanded');
                    
                    const page = item.getAttribute('data-page');
                    const isLeftMenu = item.closest('#left-menu');
                    const breadcrumb = isLeftMenu ? leftBreadcrumb : rightBreadcrumb;
                    const menuTitle = isLeftMenu ? 'Admin & System' : 'Navigation';
                    
                    // Update breadcrumb
                    const pageName = header.querySelector('span').textContent;
                    breadcrumb.innerHTML = `
                        <span class="breadcrumb-item" data-level="root">${menuTitle}</span>
                        <span class="breadcrumb-separator"></span>
                        <span class="breadcrumb-item breadcrumb-current">${pageName}</span>
                    `;
                    
                    playSound('passive');
                });
            });

            // Handle submenu item clicks
            const allSubmenuItems = document.querySelectorAll('.submenu-item');
            allSubmenuItems.forEach(subitem => {
                subitem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    const submenuId = subitem.getAttribute('data-submenu');
                    
                    // Handle special admin items
                    if (submenuId === 'admin-restart') {
                        document.getElementById('restart-prompt').classList.add('visible');
                        playSound('active');
                        return;
                    }
                    
                    if (submenuId === 'admin-theme') {
                        initThemeSelector();
                        document.getElementById('theme-prompt').classList.add('visible');
                        playSound('active');
                        return;
                    }
                    
                    if (submenuId === 'admin-08') {
                        document.getElementById('particle-behavior-panel').style.display = 'block';
                        playSound('active');
                        return;
                    }
                    
                    if (submenuId === 'admin-particle') {
                        const particlePanel = document.getElementById('particle-behavior-panel');
                        if (particlePanel) {
                            particlePanel.style.display = 'block';
                            particlePanel.classList.remove('minimized');
                            const content = document.getElementById('particle-panel-content');
                            if (content) {
                                content.classList.remove('hidden');
                            }
                            document.getElementById('particle-minimize-btn').textContent = '_';
                        }
                        playSound('active');
                        return;
                    }
                    
                    if (submenuId === 'systems-controllers') {
                        const orbitPanel = document.getElementById('orbit-controls-panel');
                        if (orbitPanel) {
                            orbitPanel.style.display = 'block';
                            orbitPanel.classList.remove('minimized');
                            const content = document.getElementById('orbit-panel-content');
                            if (content) {
                                content.classList.remove('hidden');
                            }
                            document.getElementById('orbit-minimize-btn').textContent = '_';
                        }
                        playSound('active');
                        return;
                    }
                    
                    if (submenuId === 'spaces-default') {
                        const defaultSpacePanel = document.getElementById('default-space-panel');
                        if (defaultSpacePanel) {
                            defaultSpacePanel.style.display = 'block';
                            defaultSpacePanel.classList.remove('minimized');
                            const content = document.getElementById('default-space-content');
                            if (content) {
                                content.classList.remove('hidden');
                            }
                            document.getElementById('default-space-minimize-btn').textContent = '_';
                        }
                        playSound('active');
                        return;
                    }
                    
                    if (submenuId === 'myspace' || submenuId === 'spaces-myspace' || submenuId === 'systems-myspace') {
                        // Open MySpace Control Panel
                        const myspacePanel = document.getElementById('myspace-panel');
                        if (myspacePanel) {
                            myspacePanel.style.display = 'block';
                            myspacePanel.classList.remove('minimized');
                            const content = document.getElementById('myspace-panel-content');
                            if (content) {
                                content.classList.remove('hidden');
                            }
                            document.getElementById('myspace-minimize-btn').textContent = '_';
                        }
                        playSound('active');
                        return;
                    }
                    
                    if (submenuId === 'system-01') {
                        // Open MySpace Grid Panel
                        document.getElementById('myspace-grid-panel').style.display = 'block';
                        playSound('active');
                        return;
                    }
                    
                    if (submenuId === 'system-11') {
                        // Toggle header bar visibility
                        const headerBar = document.getElementById('header-bar');
                        if (headerBar.style.display === 'none') {
                            headerBar.style.display = 'flex';
                        } else {
                            headerBar.style.display = 'none';
                        }
                        playSound('active');
                        return;
                    }
                    
                    const parentItem = subitem.closest('.menu-item');
                    const page = parentItem.getAttribute('data-page');
                    const isLeftMenu = subitem.closest('#left-menu');
                    const breadcrumb = isLeftMenu ? leftBreadcrumb : rightBreadcrumb;
                    const menuTitle = isLeftMenu ? 'Admin & System' : 'Navigation';
                    const pageName = parentItem.querySelector('.menu-item-header span').textContent;
                    
                    // Update breadcrumb with submenu
                    breadcrumb.innerHTML = `
                        <span class="breadcrumb-item" data-level="root">${menuTitle}</span>
                        <span class="breadcrumb-separator"></span>
                        <span class="breadcrumb-item" data-level="page">${pageName}</span>
                        <span class="breadcrumb-separator"></span>
                        <span class="breadcrumb-item breadcrumb-current">${subitem.textContent}</span>
                    `;
                    
                    playSound('active');
                    
                    console.log('Submenu clicked:', submenuId, 'Parent:', page);
                    
                    // Handle nested submenus (has-children)
                    if (subitem.classList.contains('has-children')) {
                        e.stopPropagation();
                        
                        // Find the corresponding nested content
                        const nestedContent = document.getElementById(`submenu-content-${submenuId}`);
                        
                        if (nestedContent) {
                            const isVisible = nestedContent.style.display !== 'none';
                            
                            // Hide all nested submenus first
                            document.querySelectorAll('.nested-submenu').forEach(ns => {
                                ns.style.display = 'none';
                            });
                            
                            // Toggle the clicked one
                            if (!isVisible) {
                                nestedContent.style.display = 'block';
                                
                                // Position it next to the parent submenu item
                                const rect = subitem.getBoundingClientRect();
                                nestedContent.style.position = 'fixed';
                                nestedContent.style.left = rect.right + 'px';
                                nestedContent.style.top = rect.top + 'px';
                                nestedContent.style.background = 'rgba(25, 25, 30, 0.95)';
                                nestedContent.style.border = '1px solid rgba(128, 128, 128, 0.5)';
                                nestedContent.style.borderRadius = '8px';
                                nestedContent.style.padding = '8px';
                                nestedContent.style.minWidth = '200px';
                                nestedContent.style.zIndex = '10002';
                                nestedContent.style.backdropFilter = 'blur(20px)';
                            }
                            
                            playSound('passive');
                        }
                        return;
                    }
                    // You can add navigation logic here
                });
            });

            // Breadcrumb navigation
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('breadcrumb-item') && e.target.getAttribute('data-level')) {
                    const level = e.target.getAttribute('data-level');
                    const isLeftMenu = e.target.closest('#left-menu');
                    const breadcrumb = isLeftMenu ? leftBreadcrumb : rightBreadcrumb;
                    const menuTitle = isLeftMenu ? 'Admin & System' : 'Navigation';
                    
                    if (level === 'root') {
                        breadcrumb.innerHTML = `
                            <span class="breadcrumb-item breadcrumb-current">${menuTitle}</span>
                        `;
                        // Collapse all submenus
                        const menu = isLeftMenu ? leftMenu : rightMenu;
                        menu.querySelectorAll('.menu-item').forEach(item => {
                            item.classList.remove('expanded');
                        });
                    } else if (level === 'page') {
                        const pageName = e.target.textContent;
                        breadcrumb.innerHTML = `
                            <span class="breadcrumb-item" data-level="root">${menuTitle}</span>
                            <span class="breadcrumb-separator"></span>
                            <span class="breadcrumb-item breadcrumb-current">${pageName}</span>
                        `;
                    }
                    playSound('passive');
                }
            });

            // Close menus when clicking outside
            document.addEventListener('click', (e) => {
                if (!leftMenu.contains(e.target) && !leftHamburger.contains(e.target)) {
                    leftMenu.classList.remove('open');
                    leftHamburger.classList.remove('menu-open');
                }
                if (!rightMenu.contains(e.target) && !rightHamburger.contains(e.target)) {
                    rightMenu.classList.remove('open');
                    rightHamburger.classList.remove('menu-open');
                }
            });
        }

        function setupDockDragDrop() {
            const dockItems = document.querySelectorAll('.dock-item');
            const docks = document.querySelectorAll('.dock');
            let draggedItem = null;

            dockItems.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedItem = item;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    playSound('hover');
                });

                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    draggedItem = null;
                });
            });

            docks.forEach(dock => {
                dock.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    dock.classList.add('drag-over');
                });

                dock.addEventListener('dragleave', () => {
                    dock.classList.remove('drag-over');
                });

                dock.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dock.classList.remove('drag-over');
                    
                    if (draggedItem && draggedItem.parentElement !== dock) {
                        // Remove from old dock
                        draggedItem.parentElement.removeChild(draggedItem);
                        
                        // Add to new dock
                        dock.appendChild(draggedItem);
                        
                        playSound('active');
                    }
                });
            });
        }

        function setupTimer() {
            const timerElement = document.getElementById('session-timer');
            
            function updateTimer() {
                const elapsed = Date.now() - sessionStartTime;
                const hours = Math.floor(elapsed / 3600000);
                const minutes = Math.floor((elapsed % 3600000) / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                const milliseconds = elapsed % 1000;
                
                timerElement.textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            }
            
            // Update timer every 10ms for smooth milliseconds
            timerInterval = setInterval(updateTimer, 10);
            updateTimer(); // Initial call
        }

        function setupTimezone() {
            const timezoneDisplay = document.getElementById('timezone-display');
            const timezoneSelector = document.getElementById('timezone-selector');
            const currentTimeEl = document.getElementById('current-time');
            const timezoneAbbr = document.getElementById('timezone-abbr');
            const autoDetectBtn = document.getElementById('auto-detect-tz');
            
            let selectedTimezone = localStorage.getItem('userTimezone') || 'America/New_York';
            let timezoneInterval;
            
            const timezoneAbbreviations = {
                'America/New_York': 'EST',
                'America/Chicago': 'CST',
                'America/Denver': 'MST',
                'America/Los_Angeles': 'PST',
                'Europe/London': 'GMT',
                'Europe/Paris': 'CET',
                'Asia/Tokyo': 'JST',
                'Australia/Sydney': 'AEDT'
            };
            
            function updateClock() {
                const now = new Date();
                const options = { 
                    timeZone: selectedTimezone,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: true
                };
                const timeString = now.toLocaleTimeString('en-US', options);
                currentTimeEl.textContent = timeString;
                timezoneAbbr.textContent = timezoneAbbreviations[selectedTimezone] || 'UTC';
            }
            
            // Toggle timezone selector
            timezoneDisplay.addEventListener('click', (e) => {
                e.stopPropagation();
                const isVisible = timezoneSelector.style.display === 'block';
                timezoneSelector.style.display = isVisible ? 'none' : 'block';
                playSound('passive');
            });
            
            // Close selector when clicking outside
            document.addEventListener('click', (e) => {
                if (!timezoneDisplay.contains(e.target)) {
                    timezoneSelector.style.display = 'none';
                }
            });
            
            // Timezone option selection
            document.querySelectorAll('.timezone-option').forEach(option => {
                option.addEventListener('click', () => {
                    selectedTimezone = option.getAttribute('data-tz');
                    localStorage.setItem('userTimezone', selectedTimezone);
                    updateClock();
                    timezoneSelector.style.display = 'none';
                    playSound('active');
                });
                
                // Hover effect
                option.addEventListener('mouseenter', () => {
                    option.style.background = 'rgba(128, 128, 128, 0.3)';
                });
                option.addEventListener('mouseleave', () => {
                    option.style.background = 'transparent';
                });
            });
            
            // Auto-detect timezone
            if (autoDetectBtn) {
                autoDetectBtn.addEventListener('click', () => {
                    try {
                        const detectedTZ = Intl.DateTimeFormat().resolvedOptions().timeZone;
                        selectedTimezone = detectedTZ;
                        localStorage.setItem('userTimezone', detectedTZ);
                        updateClock();
                        timezoneSelector.style.display = 'none';
                        playSound('active');
                        
                        // Show feedback
                        autoDetectBtn.textContent = ` Detected: ${detectedTZ}`;
                        setTimeout(() => {
                            autoDetectBtn.textContent = ' Auto-Detect Location';
                        }, 2000);
                    } catch (error) {
                        console.error('Could not detect timezone', error);
                    }
                });
            }
            
            // Start clock
            updateClock();
            timezoneInterval = setInterval(updateClock, 1000);
        }

        function setupSearchPanel() {
            const searchPanel = document.getElementById('search-panel');
            const searchInput = document.getElementById('search-input');
            
            searchPanel.addEventListener('click', (e) => {
                if (searchPanel.classList.contains('collapsed')) {
                    searchPanel.classList.remove('collapsed');
                    searchPanel.classList.add('expanded');
                    playSound('passive');
                    // Focus input after animation
                    setTimeout(() => searchInput.focus(), 300);
                }
            });
            
            // Click outside to collapse
            document.addEventListener('click', (e) => {
                if (!searchPanel.contains(e.target) && searchPanel.classList.contains('expanded')) {
                    searchPanel.classList.remove('expanded');
                    searchPanel.classList.add('collapsed');
                    searchInput.value = ''; // Clear on collapse
                }
            });
            
            // Search functionality
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                console.log('Search query:', query);
                // You can add actual search functionality here
            });
            
            // Prevent Enter from closing
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    console.log('Search submitted:', searchInput.value);
                    // Add search action here
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // FPS tracking
            const currentTime = performance.now();
            const delta = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            fpsFrames++;
            fpsTime += delta;
            
            if (fpsTime >= 1000) {
                fps = Math.round((fpsFrames * 1000) / fpsTime);
                document.getElementById('fps-counter').textContent = `${fps}`;
                fpsFrames = 0;
                fpsTime = 0;
            }
            
            // Update performance metrics every frame
            const frameTimeMs = Math.round(delta * 10) / 10; // Round to 1 decimal
            document.getElementById('frame-time').textContent = `${frameTimeMs}ms`;
            
            const particleCountDisplay = particleSystem ? particleSystem.geometry.attributes.position.count : 0;
            document.getElementById('particle-count').textContent = `${particleCountDisplay}p`;
            
            const camX = Math.round(camera.position.x);
            const camY = Math.round(camera.position.y);
            const camZ = Math.round(camera.position.z);
            document.getElementById('cam-pos').textContent = `${camX},${camY},${camZ}`;
            
            // Update entrance sequence
            if (isEntranceActive) {
                updateEntranceSequence(delta / 1000);
                renderer.render(scene, camera);
                return; // Skip other updates during entrance
            }
            
            // Levitation animation for keyboard
            if (omniKeyboardGroup && omniKeyboardVisible) {
                const time = currentTime * 0.001; // Convert to seconds
                const floatOffset = Math.sin(time * 1.5) * 0.05; // Subtle float up/down
                omniKeyboardGroup.position.y = omniKeyboardOffsetY + floatOffset;
                
                // Pulse the glow planes underneath each cube
                omniKeyboardCubes.forEach(cube => {
                    cube.children.forEach(child => {
                        if (child.geometry && child.geometry.type === 'PlaneGeometry' && child.material.color.getHex() === 0xffffff) {
                            child.material.opacity = 0.15 + Math.sin(time * 2) * 0.1; // Pulse between 0.05 and 0.25
                        }
                    });
                });
            }
            
            // Performance optimization for mobile/iPad
            const isMobile = window.innerWidth < 1024;
            if (isMobile) {
                // Reduce particle system updates on mobile
                if (Math.random() > 0.5) {
                    // Skip half the particle updates for better performance
                    renderer.render(scene, camera);
                    return;
                }
            }
            
            // Animate particle energy state
            if (particleSystem) {
                // When C key is held (focus mode), make particle tunnel follow mouse
                if (keys.c) {
                    // Convert mouse coordinates to camera-local offset
                    // mouse.x and mouse.y are in range -1 to 1
                    const offsetScale = 5; // How much particles offset from center
                    particleSystem.position.x = mouse.x * offsetScale;
                    particleSystem.position.y = mouse.y * offsetScale;
                } else {
                    // Reset to center when not focusing
                    particleSystem.position.x = 0;
                    particleSystem.position.y = 0;
                }
                
                const positions = particleSystem.geometry.attributes.position.array;
                
                if (particleBehaviorMode === 'calm') {
                    // CALM MODE: Original gentle floating behavior
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        // Update positions with gentle movement
                        positions[i3] += particleVelocities[i3];
                        positions[i3 + 1] += particleVelocities[i3 + 1];
                        positions[i3 + 2] += particleVelocities[i3 + 2];
                        
                        // Calculate distance from center
                        const x = positions[i3];
                        const y = positions[i3 + 1];
                        const z = positions[i3 + 2];
                        const distance = Math.sqrt(x * x + y * y + z * z);
                        
                        // Keep particles within sphere bounds (8-12 radius)
                        if (distance > 12 || distance < 8) {
                            // Reverse velocity if hitting boundaries
                            const normalX = x / distance;
                            const normalY = y / distance;
                            const normalZ = z / distance;
                            
                            // Reflect velocity
                            const dot = particleVelocities[i3] * normalX + 
                                       particleVelocities[i3 + 1] * normalY + 
                                       particleVelocities[i3 + 2] * normalZ;
                            
                            particleVelocities[i3] -= 2 * dot * normalX;
                            particleVelocities[i3 + 1] -= 2 * dot * normalY;
                            particleVelocities[i3 + 2] -= 2 * dot * normalZ;
                            
                            // Clamp to boundary
                            const targetRadius = distance > 12 ? 12 : 8;
                            positions[i3] = normalX * targetRadius;
                            positions[i3 + 1] = normalY * targetRadius;
                            positions[i3 + 2] = normalZ * targetRadius;
                        }
                        
                        // Add gentle pulsing effect
                        const pulseSpeed = 0.001;
                        const pulseAmount = Math.sin(Date.now() * pulseSpeed + i * 0.1) * 0.01;
                        positions[i3] *= (1 + pulseAmount);
                        positions[i3 + 1] *= (1 + pulseAmount);
                        positions[i3 + 2] *= (1 + pulseAmount);
                    }
                    
                    // Gentle rotation for calm mode
                    particleSystem.rotation.y += 0.0005;
                    
                } else if (particleBehaviorMode === 'forward') {
                    // FORWARD MODE: Particles flow straight toward user (lightspeed tunnel)
                    const flowSpeed = forwardFlowSpeed * 2;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        // Move particles straight toward camera (negative Z in camera space)
                        positions[i3 + 2] -= flowSpeed;
                        
                        // Reset particles that pass through camera
                        if (positions[i3 + 2] < -5) {
                            // Respawn at far edge in CIRCULAR pattern (tunnel effect)
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.sqrt(Math.random()) * 10; // Circular distribution
                            
                            positions[i3] = Math.cos(angle) * radius; // X position
                            positions[i3 + 1] = Math.sin(angle) * radius; // Y position
                            positions[i3 + 2] = 15; // Far Z edge
                        }
                    }
                    
                } else if (particleBehaviorMode === 'backward') {
                    // BACKWARD MODE: Particles flow away from user (reverse tunnel)
                    const flowSpeed = backwardFlowSpeed * 2;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        // Move particles away from camera (positive Z)
                        positions[i3 + 2] += flowSpeed;
                        
                        // Reset particles that go too far
                        if (positions[i3 + 2] > 15) {
                            // Respawn at near edge in CIRCULAR pattern (tunnel effect)
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.sqrt(Math.random()) * 10; // Circular distribution
                            
                            positions[i3] = Math.cos(angle) * radius; // X position
                            positions[i3 + 1] = Math.sin(angle) * radius; // Y position
                            positions[i3 + 2] = -5; // Near Z edge
                        }
                    }
                    
                } else if (particleBehaviorMode === 'upward') {
                    // UPWARD MODE: Particles rise upward
                    const flowSpeed = upwardFlowSpeed * 2;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        // Move particles upward (positive Y)
                        positions[i3 + 1] += flowSpeed;
                        
                        // Reset particles that go too far
                        if (positions[i3 + 1] > 30) {
                            // Respawn at bottom in XZ plane
                            positions[i3] = (Math.random() - 0.5) * 50; // X position
                            positions[i3 + 1] = -30; // Bottom Y edge
                            positions[i3 + 2] = (Math.random() - 0.5) * 50; // Z position
                        }
                    }
                    
                } else if (particleBehaviorMode === 'downward') {
                    // DOWNWARD MODE: Particles fall downward
                    const flowSpeed = downwardFlowSpeed * 2;
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        // Move particles downward (negative Y)
                        positions[i3 + 1] -= flowSpeed;
                        
                        // Reset particles that go too far
                        if (positions[i3 + 1] < -30) {
                            // Respawn at top in XZ plane
                            positions[i3] = (Math.random() - 0.5) * 50; // X position
                            positions[i3 + 1] = 30; // Top Y edge
                            positions[i3 + 2] = (Math.random() - 0.5) * 50; // Z position
                        }
                    }
                    
                } else if (particleBehaviorMode === 'connected') {
                    // CONNECTED MODE: Draw lines between nearby particles (particles.js style)
                    // First do gentle float like CALM
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        positions[i3] += particleVelocities[i3];
                        positions[i3 + 1] += particleVelocities[i3 + 1];
                        positions[i3 + 2] += particleVelocities[i3 + 2];
                        
                        const x = positions[i3];
                        const y = positions[i3 + 1];
                        const z = positions[i3 + 2];
                        const distance = Math.sqrt(x * x + y * y + z * z);
                        
                        if (distance > 12 || distance < 8) {
                            const normalX = x / distance;
                            const normalY = y / distance;
                            const normalZ = z / distance;
                            
                            const dot = particleVelocities[i3] * normalX + 
                                       particleVelocities[i3 + 1] * normalY + 
                                       particleVelocities[i3 + 2] * normalZ;
                            
                            particleVelocities[i3] -= 2 * dot * normalX;
                            particleVelocities[i3 + 1] -= 2 * dot * normalY;
                            particleVelocities[i3 + 2] -= 2 * dot * normalZ;
                            
                            const targetRadius = distance > 12 ? 12 : 8;
                            positions[i3] = normalX * targetRadius;
                            positions[i3 + 1] = normalY * targetRadius;
                            positions[i3 + 2] = normalZ * targetRadius;
                        }
                    }
                    
                    // Draw connection lines
                    // Remove old lines if they exist
                    if (window.particleLines) {
                        scene.remove(window.particleLines);
                        window.particleLines.geometry.dispose();
                        window.particleLines.material.dispose();
                    }
                    
                    const lineGeometry = new THREE.BufferGeometry();
                    const linePositions = [];
                    const maxDistance = 5 * connectionFrequency; // Frequency affects connection distance
                    
                    // Check connections between particles
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        const x1 = positions[i3];
                        const y1 = positions[i3 + 1];
                        const z1 = positions[i3 + 2];
                        
                        // Only check a subset of particles for performance
                        const checkCount = Math.floor(10 * connectionFrequency) + 1;
                        for (let j = 0; j < checkCount; j++) {
                            const randomIdx = Math.floor(Math.random() * particleCount);
                            if (randomIdx === i) continue;
                            
                            const j3 = randomIdx * 3;
                            const x2 = positions[j3];
                            const y2 = positions[j3 + 1];
                            const z2 = positions[j3 + 2];
                            
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const dz = z2 - z1;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            
                            if (dist < maxDistance) {
                                linePositions.push(x1, y1, z1);
                                linePositions.push(x2, y2, z2);
                            }
                        }
                    }
                    
                    if (linePositions.length > 0) {
                        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0xffffff,
                            opacity: 0.3 * connectionFrequency,
                            transparent: true,
                            blending: THREE.AdditiveBlending
                        });
                        window.particleLines = new THREE.LineSegments(lineGeometry, lineMaterial);
                        camera.add(window.particleLines); // Attach to camera like particles
                    }
                    
                    particleSystem.rotation.y += 0.0003;
                    
                } else if (particleBehaviorMode === 'glitch') {
                    // GLITCH MODE: Random teleportation/glitch effect
                    const glitchChance = glitchIntensity * 0.1; // Higher intensity = more glitches
                    const glitchDistance = glitchIntensity * 5; // How far particles can teleport
                    
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        // Random chance to glitch
                        if (Math.random() < glitchChance) {
                            // Teleport to random nearby position
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.sqrt(Math.random()) * glitchDistance;
                            const zOffset = (Math.random() - 0.5) * glitchDistance;
                            
                            positions[i3] += Math.cos(angle) * radius;
                            positions[i3 + 1] += Math.sin(angle) * radius;
                            positions[i3 + 2] += zOffset;
                        } else {
                            // Normal gentle movement
                            positions[i3] += particleVelocities[i3] * 0.5;
                            positions[i3 + 1] += particleVelocities[i3 + 1] * 0.5;
                            positions[i3 + 2] += particleVelocities[i3 + 2] * 0.5;
                        }
                        
                        // Keep in bounds
                        const x = positions[i3];
                        const y = positions[i3 + 1];
                        const z = positions[i3 + 2];
                        const distance = Math.sqrt(x * x + y * y + z * z);
                        
                        if (distance > 12) {
                            const normalX = x / distance;
                            const normalY = y / distance;
                            const normalZ = z / distance;
                            positions[i3] = normalX * 12;
                            positions[i3 + 1] = normalY * 12;
                            positions[i3 + 2] = normalZ * 12;
                        }
                    }
                    
                    // Jittery rotation
                    particleSystem.rotation.y += (Math.random() - 0.5) * 0.01 * glitchIntensity;
                    
                } else if (particleBehaviorMode === 'constellation') {
                    // CONSTELLATION MODE: Random connections between all particles
                    // Gentle float like CALM
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        
                        positions[i3] += particleVelocities[i3];
                        positions[i3 + 1] += particleVelocities[i3 + 1];
                        positions[i3 + 2] += particleVelocities[i3 + 2];
                        
                        const x = positions[i3];
                        const y = positions[i3 + 1];
                        const z = positions[i3 + 2];
                        const distance = Math.sqrt(x * x + y * y + z * z);
                        
                        if (distance > 12 || distance < 8) {
                            const normalX = x / distance;
                            const normalY = y / distance;
                            const normalZ = z / distance;
                            
                            const dot = particleVelocities[i3] * normalX + 
                                       particleVelocities[i3 + 1] * normalY + 
                                       particleVelocities[i3 + 2] * normalZ;
                            
                            particleVelocities[i3] -= 2 * dot * normalX;
                            particleVelocities[i3 + 1] -= 2 * dot * normalY;
                            particleVelocities[i3 + 2] -= 2 * dot * normalZ;
                            
                            const targetRadius = distance > 12 ? 12 : 8;
                            positions[i3] = normalX * targetRadius;
                            positions[i3 + 1] = normalY * targetRadius;
                            positions[i3 + 2] = normalZ * targetRadius;
                        }
                    }
                    
                    // Draw random constellation lines
                    if (window.particleLines) {
                        scene.remove(window.particleLines);
                        window.particleLines.geometry.dispose();
                        window.particleLines.material.dispose();
                    }
                    
                    const lineGeometry = new THREE.BufferGeometry();
                    const linePositions = [];
                    
                    // Each particle randomly connects to a few nearby particles
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        const x1 = positions[i3];
                        const y1 = positions[i3 + 1];
                        const z1 = positions[i3 + 2];
                        
                        // Random number of connections per particle (1-3)
                        const connectionCount = Math.floor(Math.random() * 3) + 1;
                        
                        for (let c = 0; c < connectionCount; c++) {
                            const randomIdx = Math.floor(Math.random() * particleCount);
                            if (randomIdx === i) continue;
                            
                            const j3 = randomIdx * 3;
                            const x2 = positions[j3];
                            const y2 = positions[j3 + 1];
                            const z2 = positions[j3 + 2];
                            
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const dz = z2 - z1;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                            
                            if (dist < constellationDistance) {
                                linePositions.push(x1, y1, z1);
                                linePositions.push(x2, y2, z2);
                            }
                        }
                    }
                    
                    if (linePositions.length > 0) {
                        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: 0xffffff,
                            opacity: 0.2,
                            transparent: true,
                            blending: THREE.AdditiveBlending
                        });
                        window.particleLines = new THREE.LineSegments(lineGeometry, lineMaterial);
                        camera.add(window.particleLines); // Attach to camera like particles
                    }
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // Camera breathing effect - enhanced for more pronounced feel
            breathTime += 0.016 * breathSpeed; // Assuming ~60fps
            const breathOffset = Math.sin(breathTime) * breathIntensity;
            const breathRotation = Math.sin(breathTime * 1.3) * 0.003; // Slight tilt
            
            // Apply breathing to camera position (up/down)
            if (!keys.r && !keys.f) { // Only when not manually moving up/down
                const breathDelta = breathOffset - (camera.userData.lastBreathOffset || 0);
                camera.position.y += breathDelta;
                camera.userData.lastBreathOffset = breathOffset;
            } else {
                camera.userData.lastBreathOffset = 0;
            }
            
            // Apply subtle rotation breathing (slight tilt)
            if (!keys.c) { // Only when not using mouse look
                camera.rotation.z = breathRotation;
            }
            
            // Check if 3D data panel is active
            const has3DPanel = scene3DDataPanel && scene3DDataPanel.userData.is3DPanel;
            
            // Calculate current movement speed (with sprint multiplier if shift is held)
            const currentSpeed = keys.shift ? moveSpeed * sprintMultiplier : moveSpeed;
            
            // WASD camera movement (or 3D panel scrolling if active)
            if (keys.w) {
                if (has3DPanel) {
                    // Scroll 3D panel up
                    if (window.scroll3DPanel) window.scroll3DPanel(-1);
                } else {
                    const forward = new THREE.Vector3(0, 0, -1);
                    forward.applyQuaternion(camera.quaternion);
                    camera.position.add(forward.multiplyScalar(currentSpeed));
                }
            }
            if (keys.s) {
                if (has3DPanel) {
                    // Scroll 3D panel down
                    if (window.scroll3DPanel) window.scroll3DPanel(1);
                } else {
                    const backward = new THREE.Vector3(0, 0, 1);
                    backward.applyQuaternion(camera.quaternion);
                    camera.position.add(backward.multiplyScalar(currentSpeed));
                }
            }
            if (keys.a) {
                const left = new THREE.Vector3(-1, 0, 0);
                left.applyQuaternion(camera.quaternion);
                camera.position.add(left.multiplyScalar(currentSpeed));
            }
            if (keys.d) {
                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                camera.position.add(right.multiplyScalar(currentSpeed));
            }
            if (keys.r) {
                camera.position.y += currentSpeed;
            }
            if (keys.f) {
                camera.position.y -= currentSpeed;
            }
            
            // Update inspector panel in real-time if object is selected
            if (selectedObject && document.getElementById('inspector-panel').classList.contains('visible')) {
                document.getElementById('object-position').textContent = 
                    `X: ${selectedObject.position.x.toFixed(2)} | Y: ${selectedObject.position.y.toFixed(2)} | Z: ${selectedObject.position.z.toFixed(2)}`;
                document.getElementById('object-rotation').textContent = 
                    `X: ${(selectedObject.rotation.x * 180 / Math.PI).toFixed(2)} | Y: ${(selectedObject.rotation.y * 180 / Math.PI).toFixed(2)} | Z: ${(selectedObject.rotation.z * 180 / Math.PI).toFixed(2)}`;
                document.getElementById('object-scale').textContent = 
                    `X: ${selectedObject.scale.x.toFixed(2)} | Y: ${selectedObject.scale.y.toFixed(2)} | Z: ${selectedObject.scale.z.toFixed(2)}`;
            }
            
            // Update coordinate guide in navbar
            document.getElementById('coord-pos-x').textContent = `X: ${camera.position.x.toFixed(2)}`;
            document.getElementById('coord-pos-y').textContent = `Y: ${camera.position.y.toFixed(2)}`;
            document.getElementById('coord-pos-z').textContent = `Z: ${camera.position.z.toFixed(2)}`;
            
            const rotX = (camera.rotation.x * 180 / Math.PI).toFixed(2);
            const rotY = (camera.rotation.y * 180 / Math.PI).toFixed(2);
            const rotZ = (camera.rotation.z * 180 / Math.PI).toFixed(2);
            document.getElementById('coord-rot-x').textContent = `X: ${rotX}`;
            document.getElementById('coord-rot-y').textContent = `Y: ${rotY}`;
            document.getElementById('coord-rot-z').textContent = `Z: ${rotZ}`;
            
            document.getElementById('coord-sca-x').textContent = `X: ${camera.scale.x.toFixed(2)}`;
            document.getElementById('coord-sca-y').textContent = `Y: ${camera.scale.y.toFixed(2)}`;
            document.getElementById('coord-sca-z').textContent = `Z: ${camera.scale.z.toFixed(2)}`;
            
            // Update ruler markers
            const xMarker = document.getElementById('x-marker');
            const yMarker = document.getElementById('y-marker');
            const zMarker = document.getElementById('z-marker');
            if (xMarker && yMarker && zMarker) {
                // Map camera position (-50 to +50) to ruler position (0% to 100%)
                const xPercent = ((camera.position.x + 50) / 100) * 100;
                const yPercent = ((camera.position.y + 50) / 100) * 100;
                const zPercent = ((camera.position.z + 50) / 100) * 100;
                xMarker.style.left = Math.max(0, Math.min(100, xPercent)) + '%';
                yMarker.style.top = Math.max(0, Math.min(100, 100 - yPercent)) + '%'; // Inverted for visual consistency
                zMarker.style.top = Math.max(0, Math.min(100, 100 - zPercent)) + '%'; // Inverted for visual consistency
            }
            
            // MyZone: Lock grid to camera view
            if (window.myzoneLocked && mySpaceGroup) {
                mySpaceGroup.position.copy(camera.position);
                mySpaceGroup.position.z -= 30; // 30 units in front of camera
                mySpaceGroup.quaternion.copy(camera.quaternion);
            }
            
            // Sphere Auto-Rotation
            if (window.mySpaceSphere) {
                const rotationSpeed = 0.005; // Slow continuous rotation
                
                if (sphereRotateX) {
                    window.mySpaceSphere.rotation.x += rotationSpeed;
                }
                if (sphereRotateY) {
                    window.mySpaceSphere.rotation.y += rotationSpeed;
                }
                if (sphereRotateZ) {
                    window.mySpaceSphere.rotation.z += rotationSpeed;
                }
            }
            
            // OmniSense Cube Animation
            if (omniSenseCube && omniSenseCube.visible) {
                // Rotate cube
                if (cubeRotating) {
                    omniSenseCube.rotation.y += cubeRotationSpeed;
                }
                
                // Pulse edges
                if (cubeEdges) {
                    const time = Date.now() * 0.001;
                    cubeEdges.children.forEach((edge) => {
                        if (edge.userData.type === 'cube-edge') {
                            const phase = edge.userData.pulsePhase;
                            const pulse = Math.sin(time * cubePulseSpeed + phase) * 0.5 + 0.5;
                            
                            // Interpolate between blue and white
                            const color = new THREE.Color();
                            color.lerpColors(
                                new THREE.Color(0x0066ff), // Blue
                                new THREE.Color(0xffffff), // White
                                pulse
                            );
                            edge.material.color.copy(color);
                            edge.material.opacity = 0.5 + pulse * 0.5;
                        }
                    });
                }
            }
            
            renderer.render(scene, camera);
        }

        // Start
        init();
        
        // Populate tray with minimized panels
        const sideTrayContent = document.getElementById('side-tray-content');
        if (sideTrayContent) {
            const panels = [
                { id: 'orbit-controls-panel', icon: '', label: 'ORBT' },
                { id: 'particle-behavior-panel', icon: '', label: 'PRTCL' },
                { id: 'user-controls-panel', icon: '', label: 'USER' },
                { id: 'default-space-panel', icon: '', label: 'SPACE' },
                { id: 'myspace-panel', icon: '', label: 'MYSP' },
                { id: 'inspector-panel', icon: '', label: 'INSPCT' },
                { id: 'help-panel', icon: '', label: 'HELP' }
            ];
            
            panels.forEach(panel => {
                const icon = document.createElement('div');
                icon.style.cssText = `
                    width: 44px;
                    height: 44px;
                    background: rgba(128, 128, 128, 0.3);
                    border: 1px solid rgba(128, 128, 128, 0.5);
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    cursor: pointer;
                    font-size: 20px;
                    transition: all 0.3s;
                    position: relative;
                `;
                icon.innerHTML = panel.icon;
                icon.title = panel.label;
                
                icon.addEventListener('mouseenter', () => {
                    icon.style.background = 'rgba(128, 128, 128, 0.5)';
                    icon.style.transform = 'scale(1.1)';
                });
                
                icon.addEventListener('mouseleave', () => {
                    icon.style.background = 'rgba(128, 128, 128, 0.3)';
                    icon.style.transform = 'scale(1)';
                });
                
                icon.addEventListener('click', () => {
                    const panelEl = document.getElementById(panel.id);
                    if (panelEl) {
                        panelEl.style.display = 'block';
                        panelEl.classList.remove('minimized');
                        const content = panelEl.querySelector('.panel-content');
                        if (content) {
                            content.classList.remove('hidden');
                        }
                        const minimizeBtn = panelEl.querySelector('.panel-btn:not(.close-btn)');
                        if (minimizeBtn) {
                            minimizeBtn.textContent = '_';
                        }
                        playSound('active');
                    }
                });
                
                sideTrayContent.appendChild(icon);
            });
        }
        
        // Initialize particles.js with custom  symbols emanating from center
        setTimeout(() => {
            if (typeof particlesJS !== 'undefined') {
                particlesJS('particles-js', {
                    particles: {
                        number: {
                            value: 80,
                            density: {
                                enable: false
                            }
                        },
                        color: {
                            value: '#ffffff'
                        },
                        shape: {
                            type: ['circle', 'text'],
                            text: {
                                value: '',
                                font: 'Orbitron',
                                style: '',
                                weight: '400'
                            }
                        },
                        opacity: {
                            value: 0.7,
                            random: true,
                            anim: {
                                enable: true,
                                speed: 1,
                                opacity_min: 0.2,
                                sync: false
                            }
                        },
                        size: {
                            value: 3,
                            random: true,
                            anim: {
                                enable: true,
                                speed: 3,
                                size_min: 1,
                                sync: false
                            }
                        },
                        line_linked: {
                            enable: true,
                            distance: 150,
                            color: '#ffffff',
                            opacity: 0.4,
                            width: 1
                        },
                        move: {
                            enable: true,
                            speed: 6,
                            direction: 'none',
                            random: false,
                            straight: false,
                            out_mode: 'out',
                            bounce: false,
                            attract: {
                                enable: false,
                                rotateX: 600,
                                rotateY: 1200
                            }
                        }
                    },
                    interactivity: {
                        detect_on: 'canvas',
                        events: {
                            onhover: {
                                enable: true,
                                mode: 'repulse'
                            },
                            onclick: {
                                enable: true,
                                mode: 'push'
                            },
                            resize: true
                        },
                        modes: {
                            repulse: {
                                distance: 200,
                                duration: 0.4
                            },
                            push: {
                                particles_nb: 4
                            }
                        }
                    },
                    retina_detect: true
                });
                
                // Custom script to make particles emanate from center
                setTimeout(() => {
                    if (window.pJSDom && window.pJSDom[0]) {
                        const pJS = window.pJSDom[0].pJS;
                        const canvas = pJS.canvas.el;
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 2;
                        
                        // Position all particles at center initially
                        pJS.particles.array.forEach((particle, index) => {
                            // Start from center
                            particle.x = centerX;
                            particle.y = centerY;
                            
                            // Give each particle an outward velocity
                            const angle = (Math.PI * 2 * index) / pJS.particles.array.length;
                            const speed = 1 + Math.random() * 2;
                            particle.vx = Math.cos(angle) * speed;
                            particle.vy = Math.sin(angle) * speed;
                        });
                    }
                }, 100);
                
                console.log('Particles.js initialized with custom  symbols');
                
                // Keep particles visible permanently
            }
            // Silently skip if particles.js not loaded
        }, 500);

        // Make functions globally accessible for inline handlers
        window.showWisdomPrompt = showWisdomPrompt;
    </script>

</body>
</html>
